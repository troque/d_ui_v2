{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"lodash\");\n\n/**\n * XML query methods.\n * @private\n */\nmodule.exports = {\n  /**\n   * Append a child to the node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @returns {undefined}\n   */\n  appendChild: function appendChild(node, child) {\n    if (!node.children) node.children = [];\n    node.children.push(child);\n  },\n  /**\n   * Append a child if one with the given name is not found.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The child node name.\n   * @returns {{}} The child.\n   */\n  appendChildIfNotFound: function appendChildIfNotFound(node, name) {\n    var child = this.findChild(node, name);\n    if (!child) {\n      child = {\n        name: name,\n        attributes: {},\n        children: []\n      };\n      this.appendChild(node, child);\n    }\n    return child;\n  },\n  /**\n   * Find a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name to find.\n   * @returns {undefined|{}} The child if found.\n   */\n  findChild: function findChild(node, name) {\n    return _.find(node.children, {\n      name: name\n    });\n  },\n  /**\n   * Get an attribute from a child node.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {string} attribute - The name of the attribute.\n   * @returns {undefined|*} The value of the attribute if found.\n   */\n  getChildAttribute: function getChildAttribute(node, name, attribute) {\n    var child = this.findChild(node, name);\n    if (child) return child.attributes && child.attributes[attribute];\n  },\n  /**\n   * Returns a value indicating whether the node has a child with the given name.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @returns {boolean} True if found, false otherwise.\n   */\n  hasChild: function hasChild(node, name) {\n    return _.some(node.children, {\n      name: name\n    });\n  },\n  /**\n   * Insert the child after the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} after - The node to insert after.\n   * @returns {undefined}\n   */\n  insertAfter: function insertAfter(node, child, after) {\n    if (!node.children) node.children = [];\n    var index = node.children.indexOf(after);\n    node.children.splice(index + 1, 0, child);\n  },\n  /**\n   * Insert the child before the specified node.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {{}} before - The node to insert before.\n   * @returns {undefined}\n   */\n  insertBefore: function insertBefore(node, child, before) {\n    if (!node.children) node.children = [];\n    var index = node.children.indexOf(before);\n    node.children.splice(index, 0, child);\n  },\n  /**\n   * Insert a child node in the correct order.\n   * @param {{}} node - The parent node.\n   * @param {{}} child - The child node.\n   * @param {Array.<string>} nodeOrder - The order of the node names.\n   * @returns {undefined}\n   */\n  insertInOrder: function insertInOrder(node, child, nodeOrder) {\n    var childIndex = nodeOrder.indexOf(child.name);\n    if (node.children && childIndex >= 0) {\n      for (var i = childIndex + 1; i < nodeOrder.length; i++) {\n        var sibling = this.findChild(node, nodeOrder[i]);\n        if (sibling) {\n          this.insertBefore(node, child, sibling);\n          return;\n        }\n      }\n    }\n    this.appendChild(node, child);\n  },\n  /**\n   * Check if the node is empty (no attributes and no children).\n   * @param {{}} node - The node.\n   * @returns {boolean} True if empty, false otherwise.\n   */\n  isEmpty: function isEmpty(node) {\n    return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n  },\n  /**\n   * Remove a child node.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child node or name of node.\n   * @returns {undefined}\n   */\n  removeChild: function removeChild(node, child) {\n    if (!node.children) return;\n    if (typeof child === 'string') {\n      _.remove(node.children, {\n        name: child\n      });\n    } else {\n      var index = node.children.indexOf(child);\n      if (index >= 0) node.children.splice(index, 1);\n    }\n  },\n  /**\n   * Set/unset the attributes on the node.\n   * @param {{}} node - The node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {undefined}\n   */\n  setAttributes: function setAttributes(node, attributes) {\n    _.forOwn(attributes, function (value, attribute) {\n      if (_.isNil(value)) {\n        if (node.attributes) delete node.attributes[attribute];\n      } else {\n        if (!node.attributes) node.attributes = {};\n        node.attributes[attribute] = value;\n      }\n    });\n  },\n  /**\n   * Set attributes on a child node, creating the child if necessary.\n   * @param {{}} node - The parent node.\n   * @param {string} name - The name of the child node.\n   * @param {{}} attributes - The attributes to set.\n   * @returns {{}} The child.\n   */\n  setChildAttributes: function setChildAttributes(node, name, attributes) {\n    var _this = this;\n    var child = this.findChild(node, name);\n    _.forOwn(attributes, function (value, attribute) {\n      if (_.isNil(value)) {\n        if (child && child.attributes) delete child.attributes[attribute];\n      } else {\n        if (!child) {\n          child = {\n            name: name,\n            attributes: {},\n            children: []\n          };\n          _this.appendChild(node, child);\n        }\n        if (!child.attributes) child.attributes = {};\n        child.attributes[attribute] = value;\n      }\n    });\n    return child;\n  },\n  /**\n   * Remove the child node if empty.\n   * @param {{}} node - The parent node.\n   * @param {string|{}} child - The child or name of child node.\n   * @returns {undefined}\n   */\n  removeChildIfEmpty: function removeChildIfEmpty(node, child) {\n    if (typeof child === 'string') child = this.findChild(node, child);\n    if (child && this.isEmpty(child)) this.removeChild(node, child);\n  }\n};","map":{"version":3,"names":["_","require","module","exports","appendChild","node","child","children","push","appendChildIfNotFound","name","findChild","attributes","find","getChildAttribute","attribute","hasChild","some","insertAfter","after","index","indexOf","splice","insertBefore","before","insertInOrder","nodeOrder","childIndex","i","length","sibling","isEmpty","removeChild","remove","setAttributes","forOwn","value","isNil","setChildAttributes","removeChildIfEmpty"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/xmlq.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\n/**\n * XML query methods.\n * @private\n */\nmodule.exports = {\n    /**\n     * Append a child to the node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @returns {undefined}\n     */\n    appendChild(node, child) {\n        if (!node.children) node.children = [];\n        node.children.push(child);\n    },\n\n    /**\n     * Append a child if one with the given name is not found.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The child node name.\n     * @returns {{}} The child.\n     */\n    appendChildIfNotFound(node, name) {\n        let child = this.findChild(node, name);\n        if (!child) {\n            child = { name, attributes: {}, children: [] };\n            this.appendChild(node, child);\n        }\n\n        return child;\n    },\n\n    /**\n     * Find a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name to find.\n     * @returns {undefined|{}} The child if found.\n     */\n    findChild(node, name) {\n        return _.find(node.children, { name });\n    },\n\n    /**\n     * Get an attribute from a child node.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {string} attribute - The name of the attribute.\n     * @returns {undefined|*} The value of the attribute if found.\n     */\n    getChildAttribute(node, name, attribute) {\n        const child = this.findChild(node, name);\n        if (child) return child.attributes && child.attributes[attribute];\n    },\n\n    /**\n     * Returns a value indicating whether the node has a child with the given name.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @returns {boolean} True if found, false otherwise.\n     */\n    hasChild(node, name) {\n        return _.some(node.children, { name });\n    },\n\n    /**\n     * Insert the child after the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} after - The node to insert after.\n     * @returns {undefined}\n     */\n    insertAfter(node, child, after) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(after);\n        node.children.splice(index + 1, 0, child);\n    },\n\n    /**\n     * Insert the child before the specified node.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {{}} before - The node to insert before.\n     * @returns {undefined}\n     */\n    insertBefore(node, child, before) {\n        if (!node.children) node.children = [];\n        const index = node.children.indexOf(before);\n        node.children.splice(index, 0, child);\n    },\n\n    /**\n     * Insert a child node in the correct order.\n     * @param {{}} node - The parent node.\n     * @param {{}} child - The child node.\n     * @param {Array.<string>} nodeOrder - The order of the node names.\n     * @returns {undefined}\n     */\n    insertInOrder(node, child, nodeOrder) {\n        const childIndex = nodeOrder.indexOf(child.name);\n        if (node.children && childIndex >= 0) {\n            for (let i = childIndex + 1; i < nodeOrder.length; i++) {\n                const sibling = this.findChild(node, nodeOrder[i]);\n                if (sibling) {\n                    this.insertBefore(node, child, sibling);\n                    return;\n                }\n            }\n        }\n\n        this.appendChild(node, child);\n    },\n\n    /**\n     * Check if the node is empty (no attributes and no children).\n     * @param {{}} node - The node.\n     * @returns {boolean} True if empty, false otherwise.\n     */\n    isEmpty(node) {\n        return _.isEmpty(node.children) && _.isEmpty(node.attributes);\n    },\n\n    /**\n     * Remove a child node.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child node or name of node.\n     * @returns {undefined}\n     */\n    removeChild(node, child) {\n        if (!node.children) return;\n        if (typeof child === 'string') {\n            _.remove(node.children, { name: child });\n        } else {\n            const index = node.children.indexOf(child);\n            if (index >= 0) node.children.splice(index, 1);\n        }\n    },\n\n    /**\n     * Set/unset the attributes on the node.\n     * @param {{}} node - The node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {undefined}\n     */\n    setAttributes(node, attributes) {\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (node.attributes) delete node.attributes[attribute];\n            } else {\n                if (!node.attributes) node.attributes = {};\n                node.attributes[attribute] = value;\n            }\n        });\n    },\n\n    /**\n     * Set attributes on a child node, creating the child if necessary.\n     * @param {{}} node - The parent node.\n     * @param {string} name - The name of the child node.\n     * @param {{}} attributes - The attributes to set.\n     * @returns {{}} The child.\n     */\n    setChildAttributes(node, name, attributes) {\n        let child = this.findChild(node, name);\n        _.forOwn(attributes, (value, attribute) => {\n            if (_.isNil(value)) {\n                if (child && child.attributes) delete child.attributes[attribute];\n            } else {\n                if (!child) {\n                    child = { name, attributes: {}, children: [] };\n                    this.appendChild(node, child);\n                }\n\n                if (!child.attributes) child.attributes = {};\n                child.attributes[attribute] = value;\n            }\n        });\n\n        return child;\n    },\n\n    /**\n     * Remove the child node if empty.\n     * @param {{}} node - The parent node.\n     * @param {string|{}} child - The child or name of child node.\n     * @returns {undefined}\n     */\n    removeChildIfEmpty(node, child) {\n        if (typeof child === 'string') child = this.findChild(node, child);\n        if (child && this.isEmpty(child)) this.removeChild(node, child);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}