{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Cell = require(\"./Cell\");\nconst Row = require(\"./Row\");\nconst Column = require(\"./Column\");\nconst Range = require(\"./Range\");\nconst Relationships = require(\"./Relationships\");\nconst xmlq = require(\"./xmlq\");\nconst regexify = require(\"./regexify\");\nconst addressConverter = require(\"./addressConverter\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst colorIndexes = require(\"./colorIndexes\");\nconst PageBreaks = require(\"./PageBreaks\");\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\", \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\", \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\", \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\", \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\", \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\", \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\", \"extLst\"];\n\n/**\n * A worksheet.\n */\nclass Sheet {\n  // /**\n  //  * Creates a new instance of Sheet.\n  //  * @param {Workbook} workbook - The parent workbook.\n  //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n  //  * @param {{}} node - The sheet node.\n  //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n  //  */\n  constructor(workbook, idNode, node, relationshipsNode) {\n    this._init(workbook, idNode, node, relationshipsNode);\n  }\n\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the sheet is the active sheet in the workbook.\n   * @returns {boolean} True if active, false otherwise.\n   */ /**\n      * Make the sheet the active sheet in the workkbok.\n      * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n      * @returns {Sheet} The sheet.\n      */\n  active() {\n    return new ArgHandler('Sheet.active').case(() => {\n      return this.workbook().activeSheet() === this;\n    }).case('boolean', active => {\n      if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n      this.workbook().activeSheet(this);\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Get the active cell in the sheet.\n   * @returns {Cell} The active cell.\n   */ /**\n      * Set the active cell in the workbook.\n      * @param {string|Cell} cell - The cell or address of cell to activate.\n      * @returns {Sheet} The sheet.\n      */ /**\n         * Set the active cell in the workbook by row and column.\n         * @param {number} rowNumber - The row number of the cell.\n         * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n         * @returns {Sheet} The sheet.\n         */\n  activeCell() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n    let selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n    return new ArgHandler('Sheet.activeCell').case(() => {\n      const cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n      return this.cell(cellAddress);\n    }).case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n      const cell = this.cell(rowNumber, columnNameOrNumber);\n      return this.activeCell(cell);\n    }).case('*', cell => {\n      if (!selectionNode) {\n        selectionNode = {\n          name: \"selection\",\n          attributes: {},\n          children: []\n        };\n        xmlq.appendChild(sheetViewNode, selectionNode);\n      }\n      if (!(cell instanceof Cell)) cell = this.cell(cell);\n      selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets the cell with the given address.\n   * @param {string} address - The address of the cell.\n   * @returns {Cell} The cell.\n   */ /**\n      * Gets the cell with the given row and column numbers.\n      * @param {number} rowNumber - The row number of the cell.\n      * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n      * @returns {Cell} The cell.\n      */\n  cell() {\n    return new ArgHandler('Sheet.cell').case('string', address => {\n      const ref = addressConverter.fromAddress(address);\n      if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n      return this.row(ref.rowNumber).cell(ref.columnNumber);\n    }).case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n      return this.row(rowNumber).cell(columnNameOrNumber);\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets a column in the sheet.\n   * @param {string|number} columnNameOrNumber - The name or number of the column.\n   * @returns {Column} The column.\n   */\n  column(columnNameOrNumber) {\n    const columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;\n\n    // If we're already created a column for this column number, return it.\n    if (this._columns[columnNumber]) return this._columns[columnNumber];\n\n    // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n    // First, see if there is an existing col node.\n    const existingColNode = this._colNodes[columnNumber];\n    let colNode;\n    if (existingColNode) {\n      // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n      if (existingColNode.attributes.min < columnNumber) {\n        // Clone the node and set the max to the column before our new col.\n        const beforeColNode = _.cloneDeep(existingColNode);\n        beforeColNode.attributes.max = columnNumber - 1;\n\n        // Update the col nodes cache.\n        for (let i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n          this._colNodes[i] = beforeColNode;\n        }\n      }\n\n      // Make a clone for the new column. Set the min/max to the column number and cache it.\n      colNode = _.cloneDeep(existingColNode);\n      colNode.attributes.min = columnNumber;\n      colNode.attributes.max = columnNumber;\n      this._colNodes[columnNumber] = colNode;\n\n      // If the max of the existing node is greater than the nre one, create a col node for that too.\n      if (existingColNode.attributes.max > columnNumber) {\n        const afterColNode = _.cloneDeep(existingColNode);\n        afterColNode.attributes.min = columnNumber + 1;\n        for (let i = afterColNode.attributes.min; i <= afterColNode.attributes.max; i++) {\n          this._colNodes[i] = afterColNode;\n        }\n      }\n    } else {\n      // The was no existing node so create a new one.\n      colNode = {\n        name: 'col',\n        attributes: {\n          min: columnNumber,\n          max: columnNumber\n        },\n        children: []\n      };\n      this._colNodes[columnNumber] = colNode;\n    }\n\n    // Create the new column and cache it.\n    const column = new Column(this, colNode);\n    this._columns[columnNumber] = column;\n    return column;\n  }\n\n  /**\n   * Gets a defined name scoped to the sheet.\n   * @param {string} name - The defined name.\n   * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n   */ /**\n      * Set a defined name scoped to the sheet.\n      * @param {string} name - The defined name.\n      * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n      * @returns {Workbook} The workbook.\n      */\n  definedName() {\n    return new ArgHandler(\"Workbook.definedName\").case('string', name => {\n      return this.workbook().scopedDefinedName(this, name);\n    }).case(['string', '*'], (name, refersTo) => {\n      this.workbook().scopedDefinedName(this, name, refersTo);\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Deletes the sheet and returns the parent workbook.\n   * @returns {Workbook} The workbook.\n   */\n  delete() {\n    this.workbook().deleteSheet(this);\n    return this.workbook();\n  }\n\n  /**\n   * Find the given pattern in the sheet and optionally replace it.\n   * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n   * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n   * @returns {Array.<Cell>} The matching cells.\n   */\n  find(pattern, replacement) {\n    pattern = regexify(pattern);\n    let matches = [];\n    this._rows.forEach(row => {\n      if (!row) return;\n      matches = matches.concat(row.find(pattern, replacement));\n    });\n    return matches;\n  }\n\n  /**\n   * Gets a value indicating whether this sheet's grid lines are visible.\n   * @returns {boolean} True if selected, false if not.\n   */ /**\n      * Sets whether this sheet's grid lines are visible.\n      * @param {boolean} selected - True to make visible, false to hide.\n      * @returns {Sheet} The sheet.\n      */\n  gridLinesVisible() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n    return new ArgHandler('Sheet.gridLinesVisible').case(() => {\n      return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n    }).case('boolean', visible => {\n      sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets a value indicating if the sheet is hidden or not.\n   * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n   */ /**\n      * Set whether the sheet is hidden or not.\n      * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n      * @returns {Sheet} The sheet.\n      */\n  hidden() {\n    return new ArgHandler('Sheet.hidden').case(() => {\n      if (this._idNode.attributes.state === 'hidden') return true;\n      if (this._idNode.attributes.state === 'veryHidden') return \"very\";\n      return false;\n    }).case('*', hidden => {\n      if (hidden) {\n        const visibleSheets = _.filter(this.workbook().sheets(), sheet => !sheet.hidden());\n        if (visibleSheets.length === 1 && visibleSheets[0] === this) {\n          throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n        }\n\n        // If activate, activate the first other visible sheet.\n        if (this.active()) {\n          const activeIndex = visibleSheets[0] === this ? 1 : 0;\n          visibleSheets[activeIndex].active(true);\n        }\n      }\n      if (hidden === 'very') this._idNode.attributes.state = 'veryHidden';else if (hidden) this._idNode.attributes.state = 'hidden';else delete this._idNode.attributes.state;\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Move the sheet.\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Sheet} The sheet.\n   */\n  move(indexOrBeforeSheet) {\n    this.workbook().moveSheet(this, indexOrBeforeSheet);\n    return this;\n  }\n\n  /**\n   * Get the name of the sheet.\n   * @returns {string} The sheet name.\n   */ /**\n      * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n      * @param {string} name - The name to set to the sheet.\n      * @returns {Sheet} The sheet.\n      */\n  name() {\n    return new ArgHandler('Sheet.name').case(() => {\n      return `${this._idNode.attributes.name}`;\n    }).case('string', name => {\n      this._idNode.attributes.name = name;\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets a range from the given range address.\n   * @param {string} address - The range address (e.g. 'A1:B3').\n   * @returns {Range} The range.\n   */ /**\n      * Gets a range from the given cells or cell addresses.\n      * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n      * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n      * @returns {Range} The range.\n      */ /**\n         * Gets a range from the given row numbers and column names or numbers.\n         * @param {number} startRowNumber - The starting cell row number.\n         * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n         * @param {number} endRowNumber - The ending cell row number.\n         * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n         * @returns {Range} The range.\n         */\n  range() {\n    return new ArgHandler('Sheet.range').case('string', address => {\n      const ref = addressConverter.fromAddress(address);\n      if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n      return this.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n    }).case(['*', '*'], (startCell, endCell) => {\n      if (typeof startCell === \"string\") startCell = this.cell(startCell);\n      if (typeof endCell === \"string\") endCell = this.cell(endCell);\n      return new Range(startCell, endCell);\n    }).case(['number', '*', 'number', '*'], (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) => {\n      return this.range(this.cell(startRowNumber, startColumnNameOrNumber), this.cell(endRowNumber, endColumnNameOrNumber));\n    }).handle(arguments);\n  }\n\n  /**\n   * Unsets sheet autoFilter.\n   * @returns {Sheet} This sheet.\n   */ /**\n      * Sets sheet autoFilter to a Range.\n      * @param {Range} range - The autoFilter range.\n      * @returns {Sheet} This sheet.\n      */\n  autoFilter(range) {\n    this._autoFilter = range;\n    return this;\n  }\n\n  /**\n   * Gets the row with the given number.\n   * @param {number} rowNumber - The row number.\n   * @returns {Row} The row with the given number.\n   */\n  row(rowNumber) {\n    if (rowNumber < 1) throw new RangeError(`Invalid row number ${rowNumber}. Remember that spreadsheets use 1-based indexing.`);\n    if (this._rows[rowNumber]) return this._rows[rowNumber];\n    const rowNode = {\n      name: 'row',\n      attributes: {\n        r: rowNumber\n      },\n      children: []\n    };\n    const row = new Row(this, rowNode);\n    this._rows[rowNumber] = row;\n    return row;\n  }\n\n  /**\n   * Get the tab color. (See style [Color](#color).)\n   * @returns {undefined|Color} The color or undefined if not set.\n   */ /**\n      * Sets the tab color. (See style [Color](#color).)\n      * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n      */\n  tabColor() {\n    return new ArgHandler(\"Sheet.tabColor\").case(() => {\n      const tabColorNode = xmlq.findChild(this._sheetPrNode, \"tabColor\");\n      if (!tabColorNode) return;\n      const color = {};\n      if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n      if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n      return color;\n    }).case(\"string\", rgb => this.tabColor({\n      rgb\n    })).case(\"integer\", theme => this.tabColor({\n      theme\n    })).case(\"nil\", () => {\n      xmlq.removeChild(this._sheetPrNode, \"tabColor\");\n      return this;\n    }).case(\"object\", color => {\n      const tabColorNode = xmlq.appendChildIfNotFound(this._sheetPrNode, \"tabColor\");\n      xmlq.setAttributes(tabColorNode, {\n        rgb: color.rgb && color.rgb.toUpperCase(),\n        indexed: null,\n        theme: color.theme,\n        tint: color.tint\n      });\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets a value indicating whether this sheet is selected.\n   * @returns {boolean} True if selected, false if not.\n   */ /**\n      * Sets whether this sheet is selected.\n      * @param {boolean} selected - True to select, false to deselected.\n      * @returns {Sheet} The sheet.\n      */\n  tabSelected() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n    return new ArgHandler('Sheet.tabSelected').case(() => {\n      return sheetViewNode.attributes.tabSelected === 1;\n    }).case('boolean', selected => {\n      if (selected) sheetViewNode.attributes.tabSelected = 1;else delete sheetViewNode.attributes.tabSelected;\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets a value indicating whether this sheet is rtl (Right To Left).\n   * @returns {boolean} True if rtl, false if ltr.\n   */ /**\n      * Sets whether this sheet is rtl.\n      * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n      * @returns {Sheet} The sheet.\n      */\n  rightToLeft() {\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n    return new ArgHandler('Sheet.rightToLeft').case(() => {\n      return sheetViewNode.attributes.rightToLeft;\n    }).case('boolean', rtl => {\n      if (rtl) sheetViewNode.attributes.rightToLeft = true;else delete sheetViewNode.attributes.rightToLeft;\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n   * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n   */\n  usedRange() {\n    const minRowNumber = _.findIndex(this._rows);\n    const maxRowNumber = this._rows.length - 1;\n    let minColumnNumber = 0;\n    let maxColumnNumber = 0;\n    for (let i = 0; i < this._rows.length; i++) {\n      const row = this._rows[i];\n      if (!row) continue;\n      const minUsedColumnNumber = row.minUsedColumnNumber();\n      const maxUsedColumnNumber = row.maxUsedColumnNumber();\n      if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n      if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n    }\n\n    // Return undefined if nothing in the sheet is used.\n    if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n    return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n  }\n\n  /**\n   * Gets the parent workbook.\n   * @returns {Workbook} The parent workbook.\n   */\n  workbook() {\n    return this._workbook;\n  }\n\n  /**\n   * Gets all page breaks.\n   * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n   */\n  pageBreaks() {\n    return this._pageBreaks;\n  }\n\n  /**\n   * Gets the vertical page breaks.\n   * @returns {PageBreaks} vertical PageBreaks.\n   */\n  verticalPageBreaks() {\n    return this._pageBreaks.colBreaks;\n  }\n\n  /**\n   * Gets the horizontal page breaks.\n   * @returns {PageBreaks} horizontal PageBreaks.\n   */\n  horizontalPageBreaks() {\n    return this._pageBreaks.rowBreaks;\n  }\n\n  /* INTERNAL */\n\n  /**\n   * Clear cells that are using a given shared formula ID.\n   * @param {number} sharedFormulaId - The shared formula ID.\n   * @returns {undefined}\n   * @ignore\n   */\n  clearCellsUsingSharedFormula(sharedFormulaId) {\n    this._rows.forEach(row => {\n      if (!row) return;\n      row.clearCellsUsingSharedFormula(sharedFormulaId);\n    });\n  }\n\n  /**\n   * Get an existing column style ID.\n   * @param {number} columnNumber - The column number.\n   * @returns {undefined|number} The style ID.\n   * @ignore\n   */\n  existingColumnStyleId(columnNumber) {\n    // This will work after setting Column.style because Column updates the attributes live.\n    const colNode = this._colNodes[columnNumber];\n    return colNode && colNode.attributes.style;\n  }\n\n  /**\n   * Call a callback for each column number that has a node defined for it.\n   * @param {Function} callback - The callback.\n   * @returns {undefined}\n   * @ignore\n   */\n  forEachExistingColumnNumber(callback) {\n    _.forEach(this._colNodes, (node, columnNumber) => {\n      if (!node) return;\n      callback(columnNumber);\n    });\n  }\n\n  /**\n   * Call a callback for each existing row.\n   * @param {Function} callback - The callback.\n   * @returns {undefined}\n   * @ignore\n   */\n  forEachExistingRow(callback) {\n    _.forEach(this._rows, (row, rowNumber) => {\n      if (row) callback(row, rowNumber);\n    });\n    return this;\n  }\n\n  /**\n   * Get the hyperlink attached to the cell with the given address.\n   * @param {string} address - The address of the hyperlinked cell.\n   * @returns {string|undefined} The hyperlink or undefined if not set.\n   */ /**\n      * Set the hyperlink on the cell with the given address.\n      * @param {string} address - The address of the hyperlinked cell.\n      * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n      * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n      * @returns {Sheet} The sheet.\n      */ /**\n         * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n         * @param {string} address - The address of the hyperlinked cell.\n         * @param {object|Cell} opts - Options.\n         * @returns {Sheet} The sheet.\n         * @ignore\n         */ /**\n            * Set the hyperlink on the cell with the given address and options.\n            * @param {string} address - The address of the hyperlinked cell.\n            * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n            * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n            * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n            * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n            * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n            * @returns {Sheet} The sheet.\n            */\n  hyperlink() {\n    return new ArgHandler('Sheet.hyperlink').case('string', address => {\n      const hyperlinkNode = this._hyperlinks[address];\n      if (!hyperlinkNode) return;\n      const relationship = this._relationships.findById(hyperlinkNode.attributes['r:id']);\n      return relationship && relationship.attributes.Target;\n    }).case(['string', 'nil'], address => {\n      // TODO: delete relationship\n      delete this._hyperlinks[address];\n      return this;\n    }).case(['string', 'string'], (address, hyperlink) => {\n      return this.hyperlink(address, hyperlink, false);\n    }).case(['string', 'string', 'boolean'], (address, hyperlink, internal) => {\n      const isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n      let nodeAttributes;\n      if (isHyperlinkInternalAddress) {\n        nodeAttributes = {\n          ref: address,\n          location: hyperlink,\n          display: hyperlink\n        };\n      } else {\n        const relationship = this._relationships.add(\"hyperlink\", hyperlink, \"External\");\n        nodeAttributes = {\n          ref: address,\n          'r:id': relationship.attributes.Id\n        };\n      }\n      this._hyperlinks[address] = {\n        name: 'hyperlink',\n        attributes: nodeAttributes,\n        children: []\n      };\n      return this;\n    }).case(['string', 'object'], (address, opts) => {\n      if (opts instanceof Cell) {\n        const cell = opts;\n        const hyperlink = cell.address({\n          includeSheetName: true\n        });\n        this.hyperlink(address, hyperlink, true);\n      } else if (opts.hyperlink) {\n        this.hyperlink(address, opts.hyperlink);\n      } else if (opts.email) {\n        const email = opts.email;\n        const subject = opts.emailSubject || '';\n        this.hyperlink(address, encodeURI(`mailto:${email}?subject=${subject}`));\n      }\n      const hyperlinkNode = this._hyperlinks[address];\n      if (hyperlinkNode) {\n        if (opts.tooltip) {\n          hyperlinkNode.attributes.tooltip = opts.tooltip;\n        }\n      }\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Increment and return the max shared formula ID.\n   * @returns {number} The new max shared formula ID.\n   * @ignore\n   */\n  incrementMaxSharedFormulaId() {\n    return ++this._maxSharedFormulaId;\n  }\n\n  /**\n   * Get a value indicating whether the cells in the given address are merged.\n   * @param {string} address - The address to check.\n   * @returns {boolean} True if merged, false if not merged.\n   * @ignore\n   */ /**\n      * Merge/unmerge cells by adding/removing a mergeCell entry.\n      * @param {string} address - The address to merge.\n      * @param {boolean} merged - True to merge, false to unmerge.\n      * @returns {Sheet} The sheet.\n      * @ignore\n      */\n  merged() {\n    return new ArgHandler('Sheet.merge').case('string', address => {\n      return this._mergeCells.hasOwnProperty(address);\n    }).case(['string', '*'], (address, merge) => {\n      if (merge) {\n        this._mergeCells[address] = {\n          name: 'mergeCell',\n          attributes: {\n            ref: address\n          },\n          children: []\n        };\n      } else {\n        delete this._mergeCells[address];\n      }\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets a Object or undefined of the cells in the given address.\n   * @param {string} address - The address to check.\n   * @returns {object|boolean} Object or false if not set\n   * @ignore\n   */ /**\n      * Removes dataValidation at the given address\n      * @param {string} address - The address to remove.\n      * @param {boolean} obj - false to delete.\n      * @returns {boolean} true if removed.\n      * @ignore\n      */ /**\n         * Add dataValidation to cells at the given address if object or string\n         * @param {string} address - The address to set.\n         * @param {object|string} obj - Object or String to set\n         * @returns {Sheet} The sheet.\n         * @ignore\n         */\n  dataValidation() {\n    return new ArgHandler('Sheet.dataValidation').case('string', address => {\n      if (this._dataValidations[address]) {\n        return {\n          type: this._dataValidations[address].attributes.type,\n          allowBlank: this._dataValidations[address].attributes.allowBlank,\n          showInputMessage: this._dataValidations[address].attributes.showInputMessage,\n          prompt: this._dataValidations[address].attributes.prompt,\n          promptTitle: this._dataValidations[address].attributes.promptTitle,\n          showErrorMessage: this._dataValidations[address].attributes.showErrorMessage,\n          error: this._dataValidations[address].attributes.error,\n          errorTitle: this._dataValidations[address].attributes.errorTitle,\n          operator: this._dataValidations[address].attributes.operator,\n          formula1: this._dataValidations[address].children[0].children[0],\n          formula2: this._dataValidations[address].children[1] ? this._dataValidations[address].children[1].children[0] : undefined\n        };\n      } else {\n        return false;\n      }\n    }).case(['string', 'boolean'], (address, obj) => {\n      if (this._dataValidations[address]) {\n        if (obj === false) return delete this._dataValidations[address];\n      } else {\n        return false;\n      }\n    }).case(['string', '*'], (address, obj) => {\n      if (typeof obj === 'string') {\n        this._dataValidations[address] = {\n          name: 'dataValidation',\n          attributes: {\n            type: 'list',\n            allowBlank: false,\n            showInputMessage: false,\n            prompt: '',\n            promptTitle: '',\n            showErrorMessage: false,\n            error: '',\n            errorTitle: '',\n            operator: '',\n            sqref: address\n          },\n          children: [{\n            name: 'formula1',\n            atrributes: {},\n            children: [obj]\n          }, {\n            name: 'formula2',\n            atrributes: {},\n            children: ['']\n          }]\n        };\n      } else if (typeof obj === 'object') {\n        this._dataValidations[address] = {\n          name: 'dataValidation',\n          attributes: {\n            type: obj.type ? obj.type : 'list',\n            allowBlank: obj.allowBlank,\n            showInputMessage: obj.showInputMessage,\n            prompt: obj.prompt,\n            promptTitle: obj.promptTitle,\n            showErrorMessage: obj.showErrorMessage,\n            error: obj.error,\n            errorTitle: obj.errorTitle,\n            operator: obj.operator,\n            sqref: address\n          },\n          children: [{\n            name: 'formula1',\n            atrributes: {},\n            children: [obj.formula1]\n          }, {\n            name: 'formula2',\n            atrributes: {},\n            children: [obj.formula2]\n          }]\n        };\n      }\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Convert the sheet to a collection of XML objects.\n   * @returns {{}} The XML forms.\n   * @ignore\n   */\n  toXmls() {\n    // Shallow clone the node so we don't have to remove these children later if they don't belong.\n    const node = _.clone(this._node);\n    node.children = node.children.slice();\n\n    // Add the columns if needed.\n    this._colsNode.children = _.filter(this._colNodes, (colNode, i) => {\n      // Columns should only be present if they have attributes other than min/max.\n      return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n    });\n    if (this._colsNode.children.length) {\n      xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n    }\n\n    // Add the hyperlinks if needed.\n    this._hyperlinksNode.children = _.values(this._hyperlinks);\n    if (this._hyperlinksNode.children.length) {\n      xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n    }\n\n    // Add the printOptions if needed.\n    if (this._printOptionsNode) {\n      if (Object.keys(this._printOptionsNode.attributes).length) {\n        xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n      }\n    }\n\n    // Add the pageMargins if needed.\n    if (this._pageMarginsNode && this._pageMarginsPresetName) {\n      // Clone to preserve the current state of this sheet.\n      const childNode = _.clone(this._pageMarginsNode);\n      if (Object.keys(this._pageMarginsNode.attributes).length) {\n        // Fill in any missing attribute values with presets.\n        childNode.attributes = _.assign(this._pageMarginsPresets[this._pageMarginsPresetName], this._pageMarginsNode.attributes);\n      } else {\n        // No need to fill in, all attributes is currently empty, simply replace.\n        childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n      }\n      xmlq.insertInOrder(node, childNode, nodeOrder);\n    }\n\n    // Add the merge cells if needed.\n    this._mergeCellsNode.children = _.values(this._mergeCells);\n    if (this._mergeCellsNode.children.length) {\n      xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n    }\n\n    // Add the DataValidation cells if needed.\n    this._dataValidationsNode.children = _.values(this._dataValidations);\n    if (this._dataValidationsNode.children.length) {\n      xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n    }\n    if (this._autoFilter) {\n      xmlq.insertInOrder(node, {\n        name: \"autoFilter\",\n        children: [],\n        attributes: {\n          ref: this._autoFilter.address()\n        }\n      }, nodeOrder);\n    }\n\n    // Add the PageBreaks nodes if needed.\n    ['colBreaks', 'rowBreaks'].forEach(name => {\n      const breaks = this[`_${name}Node`];\n      if (breaks.attributes.count) {\n        xmlq.insertInOrder(node, breaks, nodeOrder);\n      }\n    });\n    return {\n      id: this._idNode,\n      sheet: node,\n      relationships: this._relationships\n    };\n  }\n\n  /**\n   * Update the max shared formula ID to the given value if greater than current.\n   * @param {number} sharedFormulaId - The new shared formula ID.\n   * @returns {undefined}\n   * @ignore\n   */\n  updateMaxSharedFormulaId(sharedFormulaId) {\n    if (sharedFormulaId > this._maxSharedFormulaId) {\n      this._maxSharedFormulaId = sharedFormulaId;\n    }\n  }\n\n  /**\n   * Get the print option given a valid print option attribute.\n   * @param {string} attributeName - Attribute name of the printOptions.\n   *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n   *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n   *   headings - Print row and column headings.\n   *   horizontalCentered - Center on page horizontally when printing.\n   *   verticalCentered - Center on page vertically when printing.\n   * @returns {boolean}\n   */ /**\n      * Set the print option given a valid print option attribute and a value.\n      * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n      * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n      * @returns {Sheet} The sheet.\n      */\n  printOptions() {\n    const supportedAttributeNames = ['gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n    const checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n    return new ArgHandler('Sheet.printOptions').case(['string'], attributeName => {\n      checkAttributeName(attributeName);\n      return this._printOptionsNode.attributes[attributeName] === 1;\n    }).case(['string', 'nil'], attributeName => {\n      checkAttributeName(attributeName);\n      delete this._printOptionsNode.attributes[attributeName];\n      return this;\n    }).case(['string', 'boolean'], (attributeName, attributeEnabled) => {\n      checkAttributeName(attributeName);\n      if (attributeEnabled) {\n        this._printOptionsNode.attributes[attributeName] = 1;\n        return this;\n      } else {\n        return this.printOptions(attributeName, undefined);\n      }\n    }).handle(arguments);\n  }\n\n  /**\n   * Get the print option for the gridLines attribute value.\n   * @returns {boolean}\n   */ /**\n      * Set the print option for the gridLines attribute value.\n      * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n      * @returns {Sheet} The sheet.\n      */\n  printGridLines() {\n    return new ArgHandler('Sheet.gridLines').case(() => {\n      return this.printOptions('gridLines') && this.printOptions('gridLinesSet');\n    }).case(['nil'], () => {\n      this.printOptions('gridLines', undefined);\n      this.printOptions('gridLinesSet', undefined);\n      return this;\n    }).case(['boolean'], enabled => {\n      this.printOptions('gridLines', enabled);\n      this.printOptions('gridLinesSet', enabled);\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Get the page margin given a valid attribute name.\n   * If the value is not yet defined, then it will return the current preset value.\n   * @param {string} attributeName - Attribute name of the pageMargins.\n   *     left - Left Page Margin in inches.\n   *     right - Right page margin in inches.\n   *     top - Top Page Margin in inches.\n   *     buttom - Bottom Page Margin in inches.\n   *     footer - Footer Page Margin in inches.\n   *     header - Header Page Margin in inches.\n   * @returns {number} the attribute value.\n   */ /**\n      * Set the page margin (or override the preset) given an attribute name and a value.\n      * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n      * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n      * @returns {Sheet} The sheet.\n      */\n  pageMargins() {\n    if (this.pageMarginsPreset() === undefined) {\n      throw new Error('Sheet.pageMargins: preset is undefined.');\n    }\n    const supportedAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n    const checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n    const checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n    return new ArgHandler('Sheet.pageMargins').case(['string'], attributeName => {\n      checkAttributeName(attributeName);\n      const attributeValue = this._pageMarginsNode.attributes[attributeName];\n      if (attributeValue !== undefined) {\n        return parseFloat(attributeValue);\n      } else if (this._pageMarginsPresetName) {\n        return parseFloat(this._pageMarginsPresets[this._pageMarginsPresetName][attributeName]);\n      } else {\n        return undefined;\n      }\n    }).case(['string', 'nil'], attributeName => {\n      checkAttributeName(attributeName);\n      delete this._pageMarginsNode.attributes[attributeName];\n      return this;\n    }).case(['string', 'number'], (attributeName, attributeNumberValue) => {\n      checkAttributeName(attributeName);\n      checkRange(attributeNumberValue);\n      this._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n      return this;\n    }).case(['string', 'string'], (attributeName, attributeStringValue) => {\n      return this.pageMargins(attributeName, parseFloat(attributeStringValue));\n    }).handle(arguments);\n  }\n\n  /**\n   * Page margins preset is a set of page margins associated with a name.\n   * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n   * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n   * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n   * Available presets include: normal, wide, narrow, template.\n   *\n   * Get the page margins preset name. The registered name of a predefined set of attributes.\n   * @returns {string} The preset name.\n   */ /**\n      * Set the page margins preset by name, clearing any existing/temporary attribute values.\n      * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n      * @returns {Sheet} The sheet.\n      */ /**\n         * Set a new page margins preset by name and attributes object.\n         * @param {string} presetName - The preset name.\n         * @param {object} presetAttributes - The preset attributes.\n         * @returns {Sheet} The sheet.\n         */\n  pageMarginsPreset() {\n    return new ArgHandler('Sheet.pageMarginsPreset').case(() => {\n      return this._pageMarginsPresetName;\n    }).case(['nil'], () => {\n      // Remove all preset overrides and exclude from sheet\n      this._pageMarginsPresetName = undefined;\n\n      // Remove all preset overrides\n      this._pageMarginsNode.attributes = {};\n      return this;\n    }).case(['string'], presetName => {\n      const checkPresetName = this._getCheckAttributeNameHelper('pageMarginsPreset', Object.keys(this._pageMarginsPresets));\n      checkPresetName(presetName);\n\n      // Change to new preset\n      this._pageMarginsPresetName = presetName;\n\n      // Remove all preset overrides\n      this._pageMarginsNode.attributes = {};\n      return this;\n    }).case(['string', 'object'], (presetName, presetAttributes) => {\n      if (this._pageMarginsPresets.hasOwnProperty(presetName)) {\n        throw new Error(`Sheet.pageMarginsPreset: The preset ${presetName} already exists!`);\n      }\n\n      // Validate preset attribute keys.\n      const pageMarginsAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n      const isValidPresetAttributeKeys = _.isEqual(_.sortBy(pageMarginsAttributeNames), _.sortBy(Object.keys(presetAttributes)));\n      if (isValidPresetAttributeKeys === false) {\n        throw new Error(`Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \"${Object.keys(presetAttributes)}\"`);\n      }\n\n      // Validate preset attribute values.\n      _.forEach((attributeValue, attributeName) => {\n        const attributeNumberValue = parseFloat(attributeValue);\n        if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n          throw new Error(`Sheet.pageMarginsPreset: Invalid preset attribute value! - \"${attributeValue}\"`);\n        }\n      });\n\n      // Change to new preset\n      this._pageMarginsPresetName = presetName;\n\n      // Remove all preset overrides\n      this._pageMarginsNode.attributes = {};\n\n      // Register the preset\n      this._pageMarginsPresets[presetName] = presetAttributes;\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n   * @typedef {Object} PaneOptions\n   * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n   * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n   * and whether those splits are frozen.\n   * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n   * right pane (when in Left-To-Right mode).\n   * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n   * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n   * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n   * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n   */ /**\n      * Gets sheet view pane options\n      * @return {PaneOptions} sheet view pane options\n      */ /**\n         * Sets sheet view pane options\n         * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n         * @return {Sheet} The sheet\n         */\n  panes() {\n    const supportedStates = ['split', 'frozen', 'frozenSplit'];\n    const supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n    const checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n    const checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n    const sheetViewNode = this._getOrCreateSheetViewNode();\n    let paneNode = xmlq.findChild(sheetViewNode, 'pane');\n    return new ArgHandler('Sheet.pane').case(() => {\n      if (paneNode) {\n        const result = _.cloneDeep(paneNode.attributes);\n        if (!result.state) result.state = 'split';\n        return result;\n      }\n    }).case(['nil'], () => {\n      xmlq.removeChild(sheetViewNode, 'pane');\n      return this;\n    }).case(['object'], paneAttributes => {\n      const attributes = _.assign({\n        activePane: 'bottomRight'\n      }, paneAttributes);\n      checkStateName(attributes.state);\n      checkActivePane(attributes.activePane);\n      if (paneNode) {\n        paneNode.attributes = attributes;\n      } else {\n        paneNode = {\n          name: \"pane\",\n          attributes,\n          children: []\n        };\n        xmlq.appendChild(sheetViewNode, paneNode);\n      }\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Freezes Panes for this sheet.\n   * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n   * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n   * @return {Sheet} The sheet\n   */ /**\n      * freezes Panes for this sheet.\n      * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n      * right pane (when in Left-To-Right mode).\n      * @return {Sheet} The sheet\n      */\n  freezePanes() {\n    return new ArgHandler('Sheet.feezePanes').case(['integer', 'integer'], (xSplit, ySplit) => {\n      const topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n      let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n      activePane = ySplit === 0 ? 'topRight' : activePane;\n      return this.panes({\n        state: 'frozen',\n        topLeftCell,\n        xSplit,\n        ySplit,\n        activePane\n      });\n    }).case(['string'], topLeftCell => {\n      const ref = addressConverter.fromAddress(topLeftCell);\n      const xSplit = ref.columnNumber - 1,\n        ySplit = ref.rowNumber - 1;\n      let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n      activePane = ySplit === 0 ? 'topRight' : activePane;\n      return this.panes({\n        state: 'frozen',\n        topLeftCell,\n        xSplit,\n        ySplit,\n        activePane\n      });\n    }).handle(arguments);\n  }\n\n  /**\n   * Splits Panes for this sheet.\n   * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n   * in 1/20th of a point; 0 (zero) if none.\n   * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n   * in 1/20th of a point; 0 (zero) if none.\n   * @return {Sheet} The sheet\n   */\n  splitPanes(xSplit, ySplit) {\n    return this.panes({\n      state: 'split',\n      xSplit,\n      ySplit\n    });\n  }\n\n  /**\n   * resets to default sheet view panes.\n   * @return {Sheet} The sheet\n   */\n  resetPanes() {\n    return this.panes(null);\n  }\n\n  /* PRIVATE */\n\n  /**\n   * Get a helper function to check that the attribute name provided is supported.\n   * @param {string} functionName - Name of the parent function.\n   * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n   * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n   * @ignore\n   */\n  _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n    return attributeName => {\n      if (!_.includes(supportedAttributeNames, attributeName)) {\n        throw new Error(`Sheet.${functionName}: \"${attributeName}\" is not supported.`);\n      }\n    };\n  }\n\n  /**\n   * Get a helper function to check that the value is of the expected type.\n   * @param {string} functionName - Name of the parent function.\n   * @param {string} valueType - A string produced by typeof.\n   * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n   * @ignore\n   */\n  _getCheckTypeHelper(functionName, valueType) {\n    return value => {\n      if (typeof value !== valueType) {\n        throw new TypeError(`Sheet.${functionName}: invalid type - value must be of type ${valueType}.`);\n      }\n    };\n  }\n\n  /**\n   * Get a helper function to check that the value is within the expected range.\n   * @param {string} functionName - Name of the parent function.\n   * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n   * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n   * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n   * @ignore\n   */\n  _getCheckRangeHelper(functionName, valueMin, valueMax) {\n    const checkType = this._getCheckTypeHelper(functionName, 'number');\n    return value => {\n      checkType(value);\n      if (valueMin !== undefined) {\n        if (value < valueMin) {\n          throw new RangeError(`Sheet.${functionName}: value too small - value must be greater than or equal to ${valueMin}.`);\n        }\n      }\n      if (valueMax !== undefined) {\n        if (valueMax <= value) {\n          throw new RangeError(`Sheet.${functionName}: value too large - value must be less than ${valueMax}.`);\n        }\n      }\n    };\n  }\n\n  /**\n   * Get the sheet view node if it exists or create it if it doesn't.\n   * @returns {{}} The sheet view node.\n   * @private\n   */\n  _getOrCreateSheetViewNode() {\n    let sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n    if (!sheetViewsNode) {\n      sheetViewsNode = {\n        name: \"sheetViews\",\n        attributes: {},\n        children: [{\n          name: \"sheetView\",\n          attributes: {\n            workbookViewId: 0\n          },\n          children: []\n        }]\n      };\n      xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n    }\n    return xmlq.findChild(sheetViewsNode, \"sheetView\");\n  }\n\n  /**\n   * Initializes the sheet.\n   * @param {Workbook} workbook - The parent workbook.\n   * @param {{}} idNode - The sheet ID node (from the parent workbook).\n   * @param {{}} node - The sheet node.\n   * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n   * @returns {undefined}\n   * @private\n   */\n  _init(workbook, idNode, node, relationshipsNode) {\n    if (!node) {\n      node = {\n        name: \"worksheet\",\n        attributes: {\n          xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n          'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n          'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n          'mc:Ignorable': \"x14ac\",\n          'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n        },\n        children: [{\n          name: \"sheetData\",\n          attributes: {},\n          children: []\n        }]\n      };\n    }\n    this._workbook = workbook;\n    this._idNode = idNode;\n    this._node = node;\n    this._maxSharedFormulaId = -1;\n    this._mergeCells = {};\n    this._dataValidations = {};\n    this._hyperlinks = {};\n    this._autoFilter = null;\n\n    // Create the relationships.\n    this._relationships = new Relationships(relationshipsNode);\n\n    // Delete the optional dimension node\n    xmlq.removeChild(this._node, \"dimension\");\n\n    // Create the rows.\n    this._rows = [];\n    this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n    this._sheetDataNode.children.forEach(rowNode => {\n      const row = new Row(this, rowNode);\n      this._rows[row.rowNumber()] = row;\n    });\n    this._sheetDataNode.children = this._rows;\n\n    // Create the columns node.\n    this._columns = [];\n    this._colsNode = xmlq.findChild(this._node, \"cols\");\n    if (this._colsNode) {\n      xmlq.removeChild(this._node, this._colsNode);\n    } else {\n      this._colsNode = {\n        name: 'cols',\n        attributes: {},\n        children: []\n      };\n    }\n\n    // Cache the col nodes.\n    this._colNodes = [];\n    _.forEach(this._colsNode.children, colNode => {\n      const min = colNode.attributes.min;\n      const max = colNode.attributes.max;\n      for (let i = min; i <= max; i++) {\n        this._colNodes[i] = colNode;\n      }\n    });\n\n    // Create the sheet properties node.\n    this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n    if (!this._sheetPrNode) {\n      this._sheetPrNode = {\n        name: 'sheetPr',\n        attributes: {},\n        children: []\n      };\n      xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n    }\n\n    // Create the merge cells.\n    this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n    if (this._mergeCellsNode) {\n      xmlq.removeChild(this._node, this._mergeCellsNode);\n    } else {\n      this._mergeCellsNode = {\n        name: 'mergeCells',\n        attributes: {},\n        children: []\n      };\n    }\n    const mergeCellNodes = this._mergeCellsNode.children;\n    this._mergeCellsNode.children = [];\n    mergeCellNodes.forEach(mergeCellNode => {\n      this._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n    });\n\n    // Create the DataValidations.\n    this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n    if (this._dataValidationsNode) {\n      xmlq.removeChild(this._node, this._dataValidationsNode);\n    } else {\n      this._dataValidationsNode = {\n        name: 'dataValidations',\n        attributes: {},\n        children: []\n      };\n    }\n    const dataValidationNodes = this._dataValidationsNode.children;\n    this._dataValidationsNode.children = [];\n    dataValidationNodes.forEach(dataValidationNode => {\n      this._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n    });\n\n    // Create the hyperlinks.\n    this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n    if (this._hyperlinksNode) {\n      xmlq.removeChild(this._node, this._hyperlinksNode);\n    } else {\n      this._hyperlinksNode = {\n        name: 'hyperlinks',\n        attributes: {},\n        children: []\n      };\n    }\n    const hyperlinkNodes = this._hyperlinksNode.children;\n    this._hyperlinksNode.children = [];\n    hyperlinkNodes.forEach(hyperlinkNode => {\n      this._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n    });\n\n    // Create the printOptions.\n    this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n    if (this._printOptionsNode) {\n      xmlq.removeChild(this._node, this._printOptionsNode);\n    } else {\n      this._printOptionsNode = {\n        name: 'printOptions',\n        attributes: {},\n        children: []\n      };\n    }\n\n    // Create the pageMargins.\n    this._pageMarginsPresets = {\n      normal: {\n        left: 0.7,\n        right: 0.7,\n        top: 0.75,\n        bottom: 0.75,\n        header: 0.3,\n        footer: 0.3\n      },\n      wide: {\n        left: 1,\n        right: 1,\n        top: 1,\n        bottom: 1,\n        header: 0.5,\n        footer: 0.5\n      },\n      narrow: {\n        left: 0.25,\n        right: 0.25,\n        top: 0.75,\n        bottom: 0.75,\n        header: 0.3,\n        footer: 0.3\n      }\n    };\n    this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n    if (this._pageMarginsNode) {\n      // Sheet has page margins, assume preset is template.\n      this._pageMarginsPresetName = 'template';\n\n      // Search for a preset that matches existing attributes.\n      for (const presetName in this._pageMarginsPresets) {\n        if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n          this._pageMarginsPresetName = presetName;\n          break;\n        }\n      }\n\n      // If template preset, then register as template preset, and clear attributes.\n      if (this._pageMarginsPresetName === 'template') {\n        this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n        this._pageMarginsNode.attributes = {};\n      }\n      xmlq.removeChild(this._node, this._pageMarginsNode);\n    } else {\n      // Sheet has no page margins, the preset assignment is therefore undefined.\n      this._pageMarginsPresetName = undefined;\n      this._pageMarginsNode = {\n        name: 'pageMargins',\n        attributes: {},\n        children: []\n      };\n    }\n\n    // Create the pageBreaks\n    ['colBreaks', 'rowBreaks'].forEach(name => {\n      this[`_${name}Node`] = xmlq.findChild(this._node, name);\n      if (this[`_${name}Node`]) {\n        xmlq.removeChild(this._node, this[`_${name}Node`]);\n      } else {\n        this[`_${name}Node`] = {\n          name,\n          children: [],\n          attributes: {\n            count: 0,\n            manualBreakCount: 0\n          }\n        };\n      }\n    });\n    this._pageBreaks = {\n      colBreaks: new PageBreaks(this._colBreaksNode),\n      rowBreaks: new PageBreaks(this._rowBreaksNode)\n    };\n  }\n}\nmodule.exports = Sheet;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */","map":{"version":3,"names":["_","require","Cell","Row","Column","Range","Relationships","xmlq","regexify","addressConverter","ArgHandler","colorIndexes","PageBreaks","nodeOrder","Sheet","constructor","workbook","idNode","node","relationshipsNode","_init","active","case","activeSheet","Error","handle","arguments","activeCell","sheetViewNode","_getOrCreateSheetViewNode","selectionNode","findChild","cellAddress","attributes","cell","rowNumber","columnNameOrNumber","name","children","appendChild","sqref","address","ref","fromAddress","type","row","columnNumber","column","columnNameToNumber","_columns","existingColNode","_colNodes","colNode","min","beforeColNode","cloneDeep","max","i","afterColNode","definedName","scopedDefinedName","refersTo","delete","deleteSheet","find","pattern","replacement","matches","_rows","forEach","concat","gridLinesVisible","showGridLines","undefined","visible","hidden","_idNode","state","visibleSheets","filter","sheets","sheet","length","activeIndex","move","indexOrBeforeSheet","moveSheet","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","startCell","endCell","startColumnNameOrNumber","endColumnNameOrNumber","autoFilter","_autoFilter","RangeError","rowNode","r","tabColor","tabColorNode","_sheetPrNode","color","hasOwnProperty","rgb","theme","indexed","tint","removeChild","appendChildIfNotFound","setAttributes","toUpperCase","tabSelected","selected","rightToLeft","rtl","usedRange","minRowNumber","findIndex","maxRowNumber","minColumnNumber","maxColumnNumber","minUsedColumnNumber","maxUsedColumnNumber","_workbook","pageBreaks","_pageBreaks","verticalPageBreaks","colBreaks","horizontalPageBreaks","rowBreaks","clearCellsUsingSharedFormula","sharedFormulaId","existingColumnStyleId","style","forEachExistingColumnNumber","callback","forEachExistingRow","hyperlink","hyperlinkNode","_hyperlinks","relationship","_relationships","findById","Target","internal","isHyperlinkInternalAddress","nodeAttributes","location","display","add","Id","opts","includeSheetName","email","subject","emailSubject","encodeURI","tooltip","incrementMaxSharedFormulaId","_maxSharedFormulaId","merged","_mergeCells","merge","dataValidation","_dataValidations","allowBlank","showInputMessage","prompt","promptTitle","showErrorMessage","error","errorTitle","operator","formula1","formula2","obj","atrributes","toXmls","clone","_node","slice","_colsNode","Object","keys","insertInOrder","_hyperlinksNode","values","_printOptionsNode","_pageMarginsNode","_pageMarginsPresetName","childNode","assign","_pageMarginsPresets","_mergeCellsNode","_dataValidationsNode","breaks","count","id","relationships","updateMaxSharedFormulaId","printOptions","supportedAttributeNames","checkAttributeName","_getCheckAttributeNameHelper","attributeName","attributeEnabled","printGridLines","enabled","pageMargins","pageMarginsPreset","checkRange","_getCheckRangeHelper","attributeValue","parseFloat","attributeNumberValue","attributeStringValue","presetName","checkPresetName","presetAttributes","pageMarginsAttributeNames","isValidPresetAttributeKeys","isEqual","sortBy","isNaN","isNumber","panes","supportedStates","supportedActivePanes","checkStateName","checkActivePane","paneNode","result","paneAttributes","activePane","freezePanes","xSplit","ySplit","topLeftCell","columnNumberToName","splitPanes","resetPanes","functionName","includes","_getCheckTypeHelper","valueType","value","TypeError","valueMin","valueMax","checkType","sheetViewsNode","workbookViewId","xmlns","_sheetDataNode","mergeCellNodes","mergeCellNode","dataValidationNodes","dataValidationNode","hyperlinkNodes","normal","left","right","top","bottom","header","footer","wide","narrow","template","manualBreakCount","_colBreaksNode","_rowBreaksNode","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Sheet.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Cell = require(\"./Cell\");\nconst Row = require(\"./Row\");\nconst Column = require(\"./Column\");\nconst Range = require(\"./Range\");\nconst Relationships = require(\"./Relationships\");\nconst xmlq = require(\"./xmlq\");\nconst regexify = require(\"./regexify\");\nconst addressConverter = require(\"./addressConverter\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst colorIndexes = require(\"./colorIndexes\");\nconst PageBreaks = require(\"./PageBreaks\");\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\",\n    \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\",\n    \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\",\n    \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\",\n    \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\",\n    \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\",\n    \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\",\n    \"extLst\"\n];\n\n/**\n * A worksheet.\n */\nclass Sheet {\n    // /**\n    //  * Creates a new instance of Sheet.\n    //  * @param {Workbook} workbook - The parent workbook.\n    //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n    //  * @param {{}} node - The sheet node.\n    //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n    //  */\n    constructor(workbook, idNode, node, relationshipsNode) {\n        this._init(workbook, idNode, node, relationshipsNode);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Gets a value indicating whether the sheet is the active sheet in the workbook.\n     * @returns {boolean} True if active, false otherwise.\n     *//**\n     * Make the sheet the active sheet in the workkbok.\n     * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n     * @returns {Sheet} The sheet.\n     */\n    active() {\n        return new ArgHandler('Sheet.active')\n            .case(() => {\n                return this.workbook().activeSheet() === this;\n            })\n            .case('boolean', active => {\n                if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n                this.workbook().activeSheet(this);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the active cell in the sheet.\n     * @returns {Cell} The active cell.\n     *//**\n     * Set the active cell in the workbook.\n     * @param {string|Cell} cell - The cell or address of cell to activate.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the active cell in the workbook by row and column.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Sheet} The sheet.\n     */\n    activeCell() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n        return new ArgHandler('Sheet.activeCell')\n            .case(() => {\n                const cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n                return this.cell(cellAddress);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                const cell = this.cell(rowNumber, columnNameOrNumber);\n                return this.activeCell(cell);\n            })\n            .case('*', cell => {\n                if (!selectionNode) {\n                    selectionNode = {\n                        name: \"selection\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.appendChild(sheetViewNode, selectionNode);\n                }\n\n                if (!(cell instanceof Cell)) cell = this.cell(cell);\n                selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the cell with the given address.\n     * @param {string} address - The address of the cell.\n     * @returns {Cell} The cell.\n     *//**\n     * Gets the cell with the given row and column numbers.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Cell} The cell.\n     */\n    cell() {\n        return new ArgHandler('Sheet.cell')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n                return this.row(ref.rowNumber).cell(ref.columnNumber);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                return this.row(rowNumber).cell(columnNameOrNumber);\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a column in the sheet.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Column} The column.\n     */\n    column(columnNameOrNumber) {\n        const columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;\n\n        // If we're already created a column for this column number, return it.\n        if (this._columns[columnNumber]) return this._columns[columnNumber];\n\n        // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n        // First, see if there is an existing col node.\n        const existingColNode = this._colNodes[columnNumber];\n\n        let colNode;\n        if (existingColNode) {\n            // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n            if (existingColNode.attributes.min < columnNumber) {\n                // Clone the node and set the max to the column before our new col.\n                const beforeColNode = _.cloneDeep(existingColNode);\n                beforeColNode.attributes.max = columnNumber - 1;\n\n                // Update the col nodes cache.\n                for (let i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n                    this._colNodes[i] = beforeColNode;\n                }\n            }\n\n            // Make a clone for the new column. Set the min/max to the column number and cache it.\n            colNode = _.cloneDeep(existingColNode);\n            colNode.attributes.min = columnNumber;\n            colNode.attributes.max = columnNumber;\n            this._colNodes[columnNumber] = colNode;\n\n            // If the max of the existing node is greater than the nre one, create a col node for that too.\n            if (existingColNode.attributes.max > columnNumber) {\n                const afterColNode = _.cloneDeep(existingColNode);\n                afterColNode.attributes.min = columnNumber + 1;\n                for (let i = afterColNode.attributes.min; i <= afterColNode.attributes.max; i++) {\n                    this._colNodes[i] = afterColNode;\n                }\n            }\n        } else {\n            // The was no existing node so create a new one.\n            colNode = {\n                name: 'col',\n                attributes: {\n                    min: columnNumber,\n                    max: columnNumber\n                },\n                children: []\n            };\n\n            this._colNodes[columnNumber] = colNode;\n        }\n\n        // Create the new column and cache it.\n        const column = new Column(this, colNode);\n        this._columns[columnNumber] = column;\n        return column;\n    }\n\n    /**\n     * Gets a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.workbook().scopedDefinedName(this, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.workbook().scopedDefinedName(this, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Deletes the sheet and returns the parent workbook.\n     * @returns {Workbook} The workbook.\n     */\n    delete() {\n        this.workbook().deleteSheet(this);\n        return this.workbook();\n    }\n\n    /**\n     * Find the given pattern in the sheet and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {Array.<Cell>} The matching cells.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._rows.forEach(row => {\n            if (!row) return;\n            matches = matches.concat(row.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Gets a value indicating whether this sheet's grid lines are visible.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet's grid lines are visible.\n     * @param {boolean} selected - True to make visible, false to hide.\n     * @returns {Sheet} The sheet.\n     */\n    gridLinesVisible() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.gridLinesVisible')\n            .case(() => {\n                return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n            })\n            .case('boolean', visible => {\n                sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating if the sheet is hidden or not.\n     * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n     *//**\n     * Set whether the sheet is hidden or not.\n     * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n     * @returns {Sheet} The sheet.\n     */\n    hidden() {\n        return new ArgHandler('Sheet.hidden')\n            .case(() => {\n                if (this._idNode.attributes.state === 'hidden') return true;\n                if (this._idNode.attributes.state === 'veryHidden') return \"very\";\n                return false;\n            })\n            .case('*', hidden => {\n                if (hidden) {\n                    const visibleSheets = _.filter(this.workbook().sheets(), sheet => !sheet.hidden());\n                    if (visibleSheets.length === 1 && visibleSheets[0] === this) {\n                        throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n                    }\n\n                    // If activate, activate the first other visible sheet.\n                    if (this.active()) {\n                        const activeIndex = visibleSheets[0] === this ? 1 : 0;\n                        visibleSheets[activeIndex].active(true);\n                    }\n                }\n\n                if (hidden === 'very') this._idNode.attributes.state = 'veryHidden';\n                else if (hidden) this._idNode.attributes.state = 'hidden';\n                else delete this._idNode.attributes.state;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Move the sheet.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The sheet.\n     */\n    move(indexOrBeforeSheet) {\n        this.workbook().moveSheet(this, indexOrBeforeSheet);\n        return this;\n    }\n\n    /**\n     * Get the name of the sheet.\n     * @returns {string} The sheet name.\n     *//**\n     * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n     * @param {string} name - The name to set to the sheet.\n     * @returns {Sheet} The sheet.\n     */\n    name() {\n        return new ArgHandler('Sheet.name')\n            .case(() => {\n                return `${this._idNode.attributes.name}`;\n            })\n            .case('string', name => {\n                this._idNode.attributes.name = name;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a range from the given range address.\n     * @param {string} address - The range address (e.g. 'A1:B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given cells or cell addresses.\n     * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n     * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given row numbers and column names or numbers.\n     * @param {number} startRowNumber - The starting cell row number.\n     * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n     * @param {number} endRowNumber - The ending cell row number.\n     * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n     * @returns {Range} The range.\n     */\n    range() {\n        return new ArgHandler('Sheet.range')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n                return this.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n            })\n            .case(['*', '*'], (startCell, endCell) => {\n                if (typeof startCell === \"string\") startCell = this.cell(startCell);\n                if (typeof endCell === \"string\") endCell = this.cell(endCell);\n                return new Range(startCell, endCell);\n            })\n            .case(['number', '*', 'number', '*'], (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) => {\n                return this.range(this.cell(startRowNumber, startColumnNameOrNumber), this.cell(endRowNumber, endColumnNameOrNumber));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Unsets sheet autoFilter.\n     * @returns {Sheet} This sheet.\n     *//**\n     * Sets sheet autoFilter to a Range.\n     * @param {Range} range - The autoFilter range.\n     * @returns {Sheet} This sheet.\n     */\n    autoFilter(range) {\n        this._autoFilter = range;\n\n        return this;\n    }\n\n    /**\n     * Gets the row with the given number.\n     * @param {number} rowNumber - The row number.\n     * @returns {Row} The row with the given number.\n     */\n    row(rowNumber) {\n        if (rowNumber < 1) throw new RangeError(`Invalid row number ${rowNumber}. Remember that spreadsheets use 1-based indexing.`);\n\n        if (this._rows[rowNumber]) return this._rows[rowNumber];\n\n        const rowNode = {\n            name: 'row',\n            attributes: {\n                r: rowNumber\n            },\n            children: []\n        };\n\n        const row = new Row(this, rowNode);\n        this._rows[rowNumber] = row;\n        return row;\n    }\n\n    /**\n     * Get the tab color. (See style [Color](#color).)\n     * @returns {undefined|Color} The color or undefined if not set.\n     *//**\n     * Sets the tab color. (See style [Color](#color).)\n     * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n     */\n    tabColor() {\n        return new ArgHandler(\"Sheet.tabColor\")\n            .case(() => {\n                const tabColorNode = xmlq.findChild(this._sheetPrNode, \"tabColor\");\n                if (!tabColorNode) return;\n\n                const color = {};\n                if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;\n                else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;\n                else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n\n                if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n\n                return color;\n            })\n            .case(\"string\", rgb => this.tabColor({ rgb }))\n            .case(\"integer\", theme => this.tabColor({ theme }))\n            .case(\"nil\", () => {\n                xmlq.removeChild(this._sheetPrNode, \"tabColor\");\n                return this;\n            })\n            .case(\"object\", color => {\n                const tabColorNode = xmlq.appendChildIfNotFound(this._sheetPrNode, \"tabColor\");\n                xmlq.setAttributes(tabColorNode, {\n                    rgb: color.rgb && color.rgb.toUpperCase(),\n                    indexed: null,\n                    theme: color.theme,\n                    tint: color.tint\n                });\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is selected.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet is selected.\n     * @param {boolean} selected - True to select, false to deselected.\n     * @returns {Sheet} The sheet.\n     */\n    tabSelected() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.tabSelected')\n            .case(() => {\n                return sheetViewNode.attributes.tabSelected === 1;\n            })\n            .case('boolean', selected => {\n                if (selected) sheetViewNode.attributes.tabSelected = 1;\n                else delete sheetViewNode.attributes.tabSelected;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is rtl (Right To Left).\n     * @returns {boolean} True if rtl, false if ltr.\n     *//**\n     * Sets whether this sheet is rtl.\n     * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n     * @returns {Sheet} The sheet.\n     */\n    rightToLeft() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.rightToLeft')\n            .case(() => {\n                return sheetViewNode.attributes.rightToLeft;\n            })\n            .case('boolean', rtl => {\n                if (rtl) sheetViewNode.attributes.rightToLeft = true;\n                else delete sheetViewNode.attributes.rightToLeft;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n     * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n     */\n    usedRange() {\n        const minRowNumber = _.findIndex(this._rows);\n        const maxRowNumber = this._rows.length - 1;\n\n        let minColumnNumber = 0;\n        let maxColumnNumber = 0;\n        for (let i = 0; i < this._rows.length; i++) {\n            const row = this._rows[i];\n            if (!row) continue;\n\n            const minUsedColumnNumber = row.minUsedColumnNumber();\n            const maxUsedColumnNumber = row.maxUsedColumnNumber();\n            if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n            if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n        }\n\n        // Return undefined if nothing in the sheet is used.\n        if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n\n        return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this._workbook;\n    }\n\n    /**\n     * Gets all page breaks.\n     * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n     */\n    pageBreaks() {\n        return this._pageBreaks;\n    }\n\n    /**\n     * Gets the vertical page breaks.\n     * @returns {PageBreaks} vertical PageBreaks.\n     */\n    verticalPageBreaks() {\n        return this._pageBreaks.colBreaks;\n    }\n\n    /**\n     * Gets the horizontal page breaks.\n     * @returns {PageBreaks} horizontal PageBreaks.\n     */\n    horizontalPageBreaks() {\n        return this._pageBreaks.rowBreaks;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    clearCellsUsingSharedFormula(sharedFormulaId) {\n        this._rows.forEach(row => {\n            if (!row) return;\n            row.clearCellsUsingSharedFormula(sharedFormulaId);\n        });\n    }\n\n    /**\n     * Get an existing column style ID.\n     * @param {number} columnNumber - The column number.\n     * @returns {undefined|number} The style ID.\n     * @ignore\n     */\n    existingColumnStyleId(columnNumber) {\n        // This will work after setting Column.style because Column updates the attributes live.\n        const colNode = this._colNodes[columnNumber];\n        return colNode && colNode.attributes.style;\n    }\n\n    /**\n     * Call a callback for each column number that has a node defined for it.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingColumnNumber(callback) {\n        _.forEach(this._colNodes, (node, columnNumber) => {\n            if (!node) return;\n            callback(columnNumber);\n        });\n    }\n\n    /**\n     * Call a callback for each existing row.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingRow(callback) {\n        _.forEach(this._rows, (row, rowNumber) => {\n            if (row) callback(row, rowNumber);\n        });\n\n        return this;\n    }\n\n    /**\n     * Get the hyperlink attached to the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     *//**\n     * Set the hyperlink on the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n     * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {object|Cell} opts - Options.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     *//**\n     * Set the hyperlink on the cell with the given address and options.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n     * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n     * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n     * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n     * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n     * @returns {Sheet} The sheet.\n     */\n    hyperlink() {\n        return new ArgHandler('Sheet.hyperlink')\n            .case('string', address => {\n                const hyperlinkNode = this._hyperlinks[address];\n                if (!hyperlinkNode) return;\n                const relationship = this._relationships.findById(hyperlinkNode.attributes['r:id']);\n                return relationship && relationship.attributes.Target;\n            })\n            .case(['string', 'nil'], address => {\n                // TODO: delete relationship\n                delete this._hyperlinks[address];\n                return this;\n            })\n            .case(['string', 'string'], (address, hyperlink) => {\n                return this.hyperlink(address, hyperlink, false);\n            })\n            .case(['string', 'string', 'boolean'], (address, hyperlink, internal) => {\n                const isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n                let nodeAttributes;\n                if (isHyperlinkInternalAddress) {\n                    nodeAttributes = {\n                        ref: address,\n                        location: hyperlink,\n                        display: hyperlink\n                    };\n                } else {\n                    const relationship = this._relationships.add(\"hyperlink\", hyperlink, \"External\");\n                    nodeAttributes = {\n                        ref: address,\n                        'r:id': relationship.attributes.Id\n                    };\n                }\n                this._hyperlinks[address] = {\n                    name: 'hyperlink',\n                    attributes: nodeAttributes,\n                    children: []\n                };\n                return this;\n            })\n            .case(['string', 'object'], (address, opts) => {\n                if (opts instanceof Cell) {\n                    const cell = opts;\n                    const hyperlink = cell.address({ includeSheetName: true });\n                    this.hyperlink(address, hyperlink, true);\n                } else if (opts.hyperlink) {\n                    this.hyperlink(address, opts.hyperlink);\n                } else if (opts.email) {\n                    const email = opts.email;\n                    const subject = opts.emailSubject || '';\n                    this.hyperlink(address, encodeURI(`mailto:${email}?subject=${subject}`));\n                }\n                const hyperlinkNode = this._hyperlinks[address];\n                if (hyperlinkNode) {\n                    if (opts.tooltip) {\n                        hyperlinkNode.attributes.tooltip = opts.tooltip;\n                    }\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Increment and return the max shared formula ID.\n     * @returns {number} The new max shared formula ID.\n     * @ignore\n     */\n    incrementMaxSharedFormulaId() {\n        return ++this._maxSharedFormulaId;\n    }\n\n    /**\n     * Get a value indicating whether the cells in the given address are merged.\n     * @param {string} address - The address to check.\n     * @returns {boolean} True if merged, false if not merged.\n     * @ignore\n     *//**\n     * Merge/unmerge cells by adding/removing a mergeCell entry.\n     * @param {string} address - The address to merge.\n     * @param {boolean} merged - True to merge, false to unmerge.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    merged() {\n        return new ArgHandler('Sheet.merge')\n            .case('string', address => {\n                return this._mergeCells.hasOwnProperty(address);\n            })\n            .case(['string', '*'], (address, merge) => {\n                if (merge) {\n                    this._mergeCells[address] = {\n                        name: 'mergeCell',\n                        attributes: { ref: address },\n                        children: []\n                    };\n                } else {\n                    delete this._mergeCells[address];\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n\n    /**\n     * Gets a Object or undefined of the cells in the given address.\n     * @param {string} address - The address to check.\n     * @returns {object|boolean} Object or false if not set\n     * @ignore\n     *//**\n     * Removes dataValidation at the given address\n     * @param {string} address - The address to remove.\n     * @param {boolean} obj - false to delete.\n     * @returns {boolean} true if removed.\n     * @ignore\n     *//**\n     * Add dataValidation to cells at the given address if object or string\n     * @param {string} address - The address to set.\n     * @param {object|string} obj - Object or String to set\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    dataValidation() {\n        return new ArgHandler('Sheet.dataValidation')\n            .case('string', address => {\n                if (this._dataValidations[address]) {\n                    return {\n                        type: this._dataValidations[address].attributes.type,\n                        allowBlank: this._dataValidations[address].attributes.allowBlank,\n                        showInputMessage: this._dataValidations[address].attributes.showInputMessage,\n                        prompt: this._dataValidations[address].attributes.prompt,\n                        promptTitle: this._dataValidations[address].attributes.promptTitle,\n                        showErrorMessage: this._dataValidations[address].attributes.showErrorMessage,\n                        error: this._dataValidations[address].attributes.error,\n                        errorTitle: this._dataValidations[address].attributes.errorTitle,\n                        operator: this._dataValidations[address].attributes.operator,\n                        formula1: this._dataValidations[address].children[0].children[0],\n                        formula2: this._dataValidations[address].children[1] ? this._dataValidations[address].children[1].children[0] : undefined\n                    };\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', 'boolean'], (address, obj) => {\n                if (this._dataValidations[address]) {\n                    if (obj === false) return delete this._dataValidations[address];\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', '*'], (address, obj) => {\n                if (typeof obj === 'string') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: 'list',\n                            allowBlank: false,\n                            showInputMessage: false,\n                            prompt: '',\n                            promptTitle: '',\n                            showErrorMessage: false,\n                            error: '',\n                            errorTitle: '',\n                            operator: '',\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [obj]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: ['']\n                            }\n                        ]\n                    };\n                } else if (typeof obj === 'object') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: obj.type ? obj.type : 'list',\n                            allowBlank: obj.allowBlank,\n                            showInputMessage: obj.showInputMessage,\n                            prompt: obj.prompt,\n                            promptTitle: obj.promptTitle,\n                            showErrorMessage: obj.showErrorMessage,\n                            error: obj.error,\n                            errorTitle: obj.errorTitle,\n                            operator: obj.operator,\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [\n                                    obj.formula1\n                                ]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: [\n                                    obj.formula2\n                                ]\n                            }\n                        ]\n                    };\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Convert the sheet to a collection of XML objects.\n     * @returns {{}} The XML forms.\n     * @ignore\n     */\n    toXmls() {\n        // Shallow clone the node so we don't have to remove these children later if they don't belong.\n        const node = _.clone(this._node);\n        node.children = node.children.slice();\n\n        // Add the columns if needed.\n        this._colsNode.children = _.filter(this._colNodes, (colNode, i) => {\n            // Columns should only be present if they have attributes other than min/max.\n            return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n        });\n        if (this._colsNode.children.length) {\n            xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n        }\n\n        // Add the hyperlinks if needed.\n        this._hyperlinksNode.children = _.values(this._hyperlinks);\n        if (this._hyperlinksNode.children.length) {\n            xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n        }\n\n        // Add the printOptions if needed.\n        if (this._printOptionsNode) {\n            if (Object.keys(this._printOptionsNode.attributes).length) {\n                xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n            }\n        }\n\n        // Add the pageMargins if needed.\n        if (this._pageMarginsNode && this._pageMarginsPresetName) {\n            // Clone to preserve the current state of this sheet.\n            const childNode = _.clone(this._pageMarginsNode);\n            if (Object.keys(this._pageMarginsNode.attributes).length) {\n                // Fill in any missing attribute values with presets.\n                childNode.attributes = _.assign(\n                    this._pageMarginsPresets[this._pageMarginsPresetName],\n                    this._pageMarginsNode.attributes);\n            } else {\n                // No need to fill in, all attributes is currently empty, simply replace.\n                childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n            }\n            xmlq.insertInOrder(node, childNode, nodeOrder);\n        }\n\n        // Add the merge cells if needed.\n        this._mergeCellsNode.children = _.values(this._mergeCells);\n        if (this._mergeCellsNode.children.length) {\n            xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n        }\n\n        // Add the DataValidation cells if needed.\n        this._dataValidationsNode.children = _.values(this._dataValidations);\n        if (this._dataValidationsNode.children.length) {\n            xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n        }\n\n        if (this._autoFilter) {\n            xmlq.insertInOrder(node, {\n                name: \"autoFilter\",\n                children: [],\n                attributes: {\n                    ref: this._autoFilter.address()\n                }\n            }, nodeOrder);\n        }\n\n        // Add the PageBreaks nodes if needed.\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            const breaks = this[`_${name}Node`];\n            if (breaks.attributes.count) {\n                xmlq.insertInOrder(node, breaks, nodeOrder);\n            }\n        });\n\n        return {\n            id: this._idNode,\n            sheet: node,\n            relationships: this._relationships\n        };\n    }\n\n    /**\n     * Update the max shared formula ID to the given value if greater than current.\n     * @param {number} sharedFormulaId - The new shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    updateMaxSharedFormulaId(sharedFormulaId) {\n        if (sharedFormulaId > this._maxSharedFormulaId) {\n            this._maxSharedFormulaId = sharedFormulaId;\n        }\n    }\n\n    /**\n     * Get the print option given a valid print option attribute.\n     * @param {string} attributeName - Attribute name of the printOptions.\n     *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   headings - Print row and column headings.\n     *   horizontalCentered - Center on page horizontally when printing.\n     *   verticalCentered - Center on page vertically when printing.\n     * @returns {boolean}\n     *//**\n     * Set the print option given a valid print option attribute and a value.\n     * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n     * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printOptions() {\n        const supportedAttributeNames = [\n            'gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n        return new ArgHandler('Sheet.printOptions')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                return this._printOptionsNode.attributes[attributeName] === 1;\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._printOptionsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'boolean'], (attributeName, attributeEnabled) => {\n                checkAttributeName(attributeName);\n                if (attributeEnabled) {\n                    this._printOptionsNode.attributes[attributeName] = 1;\n                    return this;\n                } else {\n                    return this.printOptions(attributeName, undefined);\n                }\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the print option for the gridLines attribute value.\n     * @returns {boolean}\n     *//**\n     * Set the print option for the gridLines attribute value.\n     * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printGridLines() {\n        return new ArgHandler('Sheet.gridLines')\n            .case(() => {\n                return this.printOptions('gridLines') && this.printOptions('gridLinesSet');\n            })\n            .case(['nil'], () => {\n                this.printOptions('gridLines', undefined);\n                this.printOptions('gridLinesSet', undefined);\n                return this;\n            })\n            .case(['boolean'], enabled => {\n                this.printOptions('gridLines', enabled);\n                this.printOptions('gridLinesSet', enabled);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the page margin given a valid attribute name.\n     * If the value is not yet defined, then it will return the current preset value.\n     * @param {string} attributeName - Attribute name of the pageMargins.\n     *     left - Left Page Margin in inches.\n     *     right - Right page margin in inches.\n     *     top - Top Page Margin in inches.\n     *     buttom - Bottom Page Margin in inches.\n     *     footer - Footer Page Margin in inches.\n     *     header - Header Page Margin in inches.\n     * @returns {number} the attribute value.\n     *//**\n     * Set the page margin (or override the preset) given an attribute name and a value.\n     * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n     * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n     * @returns {Sheet} The sheet.\n     */\n    pageMargins() {\n        if (this.pageMarginsPreset() === undefined) {\n            throw new Error('Sheet.pageMargins: preset is undefined.');\n        }\n        const supportedAttributeNames = [\n            'left', 'right', 'top', 'bottom', 'header', 'footer'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n        const checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n        return new ArgHandler('Sheet.pageMargins')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                const attributeValue = this._pageMarginsNode.attributes[attributeName];\n                if (attributeValue !== undefined) {\n                    return parseFloat(attributeValue);\n                } else if (this._pageMarginsPresetName) {\n                    return parseFloat(this._pageMarginsPresets[this._pageMarginsPresetName][attributeName]);\n                } else {\n                    return undefined;\n                }\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._pageMarginsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'number'], (attributeName, attributeNumberValue) => {\n                checkAttributeName(attributeName);\n                checkRange(attributeNumberValue);\n                this._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n                return this;\n            })\n            .case(['string', 'string'], (attributeName, attributeStringValue) => {\n                return this.pageMargins(attributeName, parseFloat(attributeStringValue));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Page margins preset is a set of page margins associated with a name.\n     * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n     * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n     * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n     * Available presets include: normal, wide, narrow, template.\n     *\n     * Get the page margins preset name. The registered name of a predefined set of attributes.\n     * @returns {string} The preset name.\n     *//**\n     * Set the page margins preset by name, clearing any existing/temporary attribute values.\n     * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set a new page margins preset by name and attributes object.\n     * @param {string} presetName - The preset name.\n     * @param {object} presetAttributes - The preset attributes.\n     * @returns {Sheet} The sheet.\n     */\n    pageMarginsPreset() {\n        return new ArgHandler('Sheet.pageMarginsPreset')\n            .case(() => {\n                return this._pageMarginsPresetName;\n            })\n            .case(['nil'], () => {\n                // Remove all preset overrides and exclude from sheet\n                this._pageMarginsPresetName = undefined;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string'], presetName => {\n                const checkPresetName = this._getCheckAttributeNameHelper(\n                    'pageMarginsPreset', Object.keys(this._pageMarginsPresets));\n                checkPresetName(presetName);\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string', 'object'], (presetName, presetAttributes) => {\n                if (this._pageMarginsPresets.hasOwnProperty(presetName)) {\n                    throw new Error(`Sheet.pageMarginsPreset: The preset ${presetName} already exists!`);\n                }\n\n                // Validate preset attribute keys.\n                const pageMarginsAttributeNames = [\n                    'left', 'right', 'top', 'bottom', 'header', 'footer'];\n                const isValidPresetAttributeKeys = _.isEqual(\n                    _.sortBy(pageMarginsAttributeNames),\n                    _.sortBy(Object.keys(presetAttributes)));\n                if (isValidPresetAttributeKeys === false) {\n                    throw new Error(`Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \"${Object.keys(presetAttributes)}\"`);\n                }\n\n                // Validate preset attribute values.\n                _.forEach((attributeValue, attributeName) => {\n                    const attributeNumberValue = parseFloat(attributeValue);\n                    if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n                        throw new Error(`Sheet.pageMarginsPreset: Invalid preset attribute value! - \"${attributeValue}\"`);\n                    }\n                });\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n\n                // Register the preset\n                this._pageMarginsPresets[presetName] = presetAttributes;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n     * @typedef {Object} PaneOptions\n     * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n     * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n     * and whether those splits are frozen.\n     * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n     * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n     * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n     * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n     *//**\n     * Gets sheet view pane options\n     * @return {PaneOptions} sheet view pane options\n     *//**\n     * Sets sheet view pane options\n     * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n     * @return {Sheet} The sheet\n     */\n    panes() {\n        const supportedStates = ['split', 'frozen', 'frozenSplit'];\n        const supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n        const checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n        const checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let paneNode = xmlq.findChild(sheetViewNode, 'pane');\n        return new ArgHandler('Sheet.pane')\n            .case(() => {\n                if (paneNode) {\n                    const result = _.cloneDeep(paneNode.attributes);\n                    if (!result.state) result.state = 'split';\n                    return result;\n                }\n            })\n            .case(['nil'], () => {\n                xmlq.removeChild(sheetViewNode, 'pane');\n                return this;\n            })\n            .case(['object'], paneAttributes => {\n                const attributes = _.assign({ activePane: 'bottomRight' }, paneAttributes);\n                checkStateName(attributes.state);\n                checkActivePane(attributes.activePane);\n                if (paneNode) {\n                    paneNode.attributes = attributes;\n                } else {\n                    paneNode = {\n                        name: \"pane\",\n                        attributes,\n                        children: []\n                    };\n                    xmlq.appendChild(sheetViewNode, paneNode);\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Freezes Panes for this sheet.\n     * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n     * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n     * @return {Sheet} The sheet\n     *//**\n     * freezes Panes for this sheet.\n     * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @return {Sheet} The sheet\n     */\n    freezePanes() {\n        return new ArgHandler('Sheet.feezePanes')\n            .case(['integer', 'integer'], (xSplit, ySplit) => {\n                const topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .case(['string'], topLeftCell => {\n                const ref = addressConverter.fromAddress(topLeftCell);\n                const xSplit = ref.columnNumber - 1, ySplit = ref.rowNumber - 1;\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Splits Panes for this sheet.\n     * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n    splitPanes(xSplit, ySplit) {\n        return this.panes({ state: 'split', xSplit, ySplit });\n    }\n\n    /**\n     * resets to default sheet view panes.\n     * @return {Sheet} The sheet\n     */\n    resetPanes() {\n        return this.panes(null);\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Get a helper function to check that the attribute name provided is supported.\n     * @param {string} functionName - Name of the parent function.\n     * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n     * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n     * @ignore\n     */\n    _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n        return attributeName => {\n            if (!_.includes(supportedAttributeNames, attributeName)) {\n                throw new Error(`Sheet.${functionName}: \"${attributeName}\" is not supported.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is of the expected type.\n     * @param {string} functionName - Name of the parent function.\n     * @param {string} valueType - A string produced by typeof.\n     * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n     * @ignore\n     */\n    _getCheckTypeHelper(functionName, valueType) {\n        return value => {\n            if (typeof value !== valueType) {\n                throw new TypeError(`Sheet.${functionName}: invalid type - value must be of type ${valueType}.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is within the expected range.\n     * @param {string} functionName - Name of the parent function.\n     * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n     * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n     * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n     * @ignore\n     */\n    _getCheckRangeHelper(functionName, valueMin, valueMax) {\n        const checkType = this._getCheckTypeHelper(functionName, 'number');\n        return value => {\n            checkType(value);\n            if (valueMin !== undefined) {\n                if (value < valueMin) {\n                    throw new RangeError(`Sheet.${functionName}: value too small - value must be greater than or equal to ${valueMin}.`);\n                }\n            }\n            if (valueMax !== undefined) {\n                if (valueMax <= value) {\n                    throw new RangeError(`Sheet.${functionName}: value too large - value must be less than ${valueMax}.`);\n                }\n            }\n        };\n    }\n\n    /**\n     * Get the sheet view node if it exists or create it if it doesn't.\n     * @returns {{}} The sheet view node.\n     * @private\n     */\n    _getOrCreateSheetViewNode() {\n        let sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n        if (!sheetViewsNode) {\n            sheetViewsNode = {\n                name: \"sheetViews\",\n                attributes: {},\n                children: [{\n                    name: \"sheetView\",\n                    attributes: {\n                        workbookViewId: 0\n                    },\n                    children: []\n                }]\n            };\n\n            xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n        }\n\n        return xmlq.findChild(sheetViewsNode, \"sheetView\");\n    }\n\n    /**\n     * Initializes the sheet.\n     * @param {Workbook} workbook - The parent workbook.\n     * @param {{}} idNode - The sheet ID node (from the parent workbook).\n     * @param {{}} node - The sheet node.\n     * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n     * @returns {undefined}\n     * @private\n     */\n    _init(workbook, idNode, node, relationshipsNode) {\n        if (!node) {\n            node = {\n                name: \"worksheet\",\n                attributes: {\n                    xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n                    'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n                    'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n                    'mc:Ignorable': \"x14ac\",\n                    'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n                },\n                children: [{\n                    name: \"sheetData\",\n                    attributes: {},\n                    children: []\n                }]\n            };\n        }\n\n        this._workbook = workbook;\n        this._idNode = idNode;\n        this._node = node;\n        this._maxSharedFormulaId = -1;\n        this._mergeCells = {};\n        this._dataValidations = {};\n        this._hyperlinks = {};\n        this._autoFilter = null;\n\n        // Create the relationships.\n        this._relationships = new Relationships(relationshipsNode);\n\n        // Delete the optional dimension node\n        xmlq.removeChild(this._node, \"dimension\");\n\n        // Create the rows.\n        this._rows = [];\n        this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n        this._sheetDataNode.children.forEach(rowNode => {\n            const row = new Row(this, rowNode);\n            this._rows[row.rowNumber()] = row;\n        });\n        this._sheetDataNode.children = this._rows;\n\n        // Create the columns node.\n        this._columns = [];\n        this._colsNode = xmlq.findChild(this._node, \"cols\");\n        if (this._colsNode) {\n            xmlq.removeChild(this._node, this._colsNode);\n        } else {\n            this._colsNode = { name: 'cols', attributes: {}, children: [] };\n        }\n\n        // Cache the col nodes.\n        this._colNodes = [];\n        _.forEach(this._colsNode.children, colNode => {\n            const min = colNode.attributes.min;\n            const max = colNode.attributes.max;\n            for (let i = min; i <= max; i++) {\n                this._colNodes[i] = colNode;\n            }\n        });\n\n        // Create the sheet properties node.\n        this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n        if (!this._sheetPrNode) {\n            this._sheetPrNode = { name: 'sheetPr', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n        }\n\n        // Create the merge cells.\n        this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n        if (this._mergeCellsNode) {\n            xmlq.removeChild(this._node, this._mergeCellsNode);\n        } else {\n            this._mergeCellsNode = { name: 'mergeCells', attributes: {}, children: [] };\n        }\n\n        const mergeCellNodes = this._mergeCellsNode.children;\n        this._mergeCellsNode.children = [];\n        mergeCellNodes.forEach(mergeCellNode => {\n            this._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n        });\n\n\n        // Create the DataValidations.\n        this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n        if (this._dataValidationsNode) {\n            xmlq.removeChild(this._node, this._dataValidationsNode);\n        } else {\n            this._dataValidationsNode = { name: 'dataValidations', attributes: {}, children: [] };\n        }\n\n        const dataValidationNodes = this._dataValidationsNode.children;\n        this._dataValidationsNode.children = [];\n        dataValidationNodes.forEach(dataValidationNode => {\n            this._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n        });\n\n\n        // Create the hyperlinks.\n        this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n        if (this._hyperlinksNode) {\n            xmlq.removeChild(this._node, this._hyperlinksNode);\n        } else {\n            this._hyperlinksNode = { name: 'hyperlinks', attributes: {}, children: [] };\n        }\n\n        const hyperlinkNodes = this._hyperlinksNode.children;\n        this._hyperlinksNode.children = [];\n        hyperlinkNodes.forEach(hyperlinkNode => {\n            this._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n        });\n\n\n        // Create the printOptions.\n        this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n        if (this._printOptionsNode) {\n            xmlq.removeChild(this._node, this._printOptionsNode);\n        } else {\n            this._printOptionsNode = { name: 'printOptions', attributes: {}, children: [] };\n        }\n\n\n        // Create the pageMargins.\n        this._pageMarginsPresets = {\n            normal: {\n                left: 0.7,\n                right: 0.7,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            },\n            wide: {\n                left: 1,\n                right: 1,\n                top: 1,\n                bottom: 1,\n                header: 0.5,\n                footer: 0.5\n            },\n            narrow: {\n                left: 0.25,\n                right: 0.25,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            }\n        };\n        this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n        if (this._pageMarginsNode) {\n            // Sheet has page margins, assume preset is template.\n            this._pageMarginsPresetName = 'template';\n\n            // Search for a preset that matches existing attributes.\n            for (const presetName in this._pageMarginsPresets) {\n                if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n                    this._pageMarginsPresetName = presetName;\n                    break;\n                }\n            }\n\n            // If template preset, then register as template preset, and clear attributes.\n            if (this._pageMarginsPresetName === 'template') {\n                this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n                this._pageMarginsNode.attributes = {};\n            }\n\n            xmlq.removeChild(this._node, this._pageMarginsNode);\n        } else {\n            // Sheet has no page margins, the preset assignment is therefore undefined.\n            this._pageMarginsPresetName = undefined;\n            this._pageMarginsNode = { name: 'pageMargins', attributes: {}, children: [] };\n        }\n\n        // Create the pageBreaks\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            this[`_${name}Node`] = xmlq.findChild(this._node, name);\n            if (this[`_${name}Node`]) {\n                xmlq.removeChild(this._node, this[`_${name}Node`]);\n            } else {\n                this[`_${name}Node`] = {\n                    name,\n                    children: [],\n                    attributes: {\n                        count: 0,\n                        manualBreakCount: 0\n                    }\n                };\n            }\n        });\n        this._pageBreaks = {\n            colBreaks: new PageBreaks(this._colBreaksNode),\n            rowBreaks: new PageBreaks(this._rowBreaksNode)\n        };\n    }\n}\n\nmodule.exports = Sheet;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}