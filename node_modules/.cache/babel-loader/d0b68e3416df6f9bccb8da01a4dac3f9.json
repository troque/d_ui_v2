{"ast":null,"code":"\"use strict\";\n\n// The base date = 0.\nconst dateBase = new Date(1900, 0, 0);\n\n// The date conversion has a bug that assumes 1900 was a leap year. So we need to add one for dates after this.\nconst incorrectLeapDate = new Date(1900, 1, 28);\n\n// Number of milliseconds in a day.\nconst millisecondsInDay = 1000 * 60 * 60 * 24;\n\n/**\n * Date converter.\n * @private\n */\nmodule.exports = {\n  /**\n   * Convert a date to a number for Excel.\n   * @param {Date} date - The date.\n   * @returns {number} The number.\n   */\n  dateToNumber(date) {\n    // Clone the date and strip the time off.\n    const dateOnly = new Date(date.getTime());\n    dateOnly.setHours(0, 0, 0, 0);\n\n    // Set the number to be the number of days between the date and the base date.\n    // We need to round as daylight savings will cause fractional days, which we don't want.\n    let number = Math.round((dateOnly - dateBase) / millisecondsInDay);\n\n    // Add the true fractional days from just the milliseconds left in the current day.\n    number += (date - dateOnly) / millisecondsInDay;\n\n    // Adjust for the \"bug\" in Excel that treats 1900 as a leap year.\n    if (date > incorrectLeapDate) number += 1;\n    return number;\n  },\n  /**\n   * Convert a number to a date.\n   * @param {number} number - The number.\n   * @returns {Date} The date.\n   */\n  numberToDate(number) {\n    // If the number is greater than the incorrect leap date, we should subtract one.\n    if (number > this.dateToNumber(incorrectLeapDate)) number--;\n\n    // Break the number of full days and the remaining milliseconds in the current day.\n    const fullDays = Math.floor(number);\n    const partialMilliseconds = Math.round((number - fullDays) * millisecondsInDay);\n\n    // Create a new date from the base date plus the time in the current day.\n    const date = new Date(dateBase.getTime() + partialMilliseconds);\n\n    // Now add the number of full days. JS will properly handle the month/year changes.\n    date.setDate(date.getDate() + fullDays);\n    return date;\n  }\n};","map":{"version":3,"names":["dateBase","Date","incorrectLeapDate","millisecondsInDay","module","exports","dateToNumber","date","dateOnly","getTime","setHours","number","Math","round","numberToDate","fullDays","floor","partialMilliseconds","setDate","getDate"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/dateConverter.js"],"sourcesContent":["\"use strict\";\n\n// The base date = 0.\nconst dateBase = new Date(1900, 0, 0);\n\n// The date conversion has a bug that assumes 1900 was a leap year. So we need to add one for dates after this.\nconst incorrectLeapDate = new Date(1900, 1, 28);\n\n// Number of milliseconds in a day.\nconst millisecondsInDay = 1000 * 60 * 60 * 24;\n\n/**\n * Date converter.\n * @private\n */\nmodule.exports = {\n    /**\n     * Convert a date to a number for Excel.\n     * @param {Date} date - The date.\n     * @returns {number} The number.\n     */\n    dateToNumber(date) {\n        // Clone the date and strip the time off.\n        const dateOnly = new Date(date.getTime());\n        dateOnly.setHours(0, 0, 0, 0);\n\n        // Set the number to be the number of days between the date and the base date.\n        // We need to round as daylight savings will cause fractional days, which we don't want.\n        let number = Math.round((dateOnly - dateBase) / millisecondsInDay);\n        \n        // Add the true fractional days from just the milliseconds left in the current day.\n        number += (date - dateOnly) / millisecondsInDay;\n\n        // Adjust for the \"bug\" in Excel that treats 1900 as a leap year.\n        if (date > incorrectLeapDate) number += 1;\n\n        return number;\n    },\n\n    /**\n     * Convert a number to a date.\n     * @param {number} number - The number.\n     * @returns {Date} The date.\n     */\n    numberToDate(number) {\n        // If the number is greater than the incorrect leap date, we should subtract one.\n        if (number > this.dateToNumber(incorrectLeapDate)) number--;\n        \n        // Break the number of full days and the remaining milliseconds in the current day.\n        const fullDays = Math.floor(number);\n        const partialMilliseconds = Math.round((number - fullDays) * millisecondsInDay);\n\n        // Create a new date from the base date plus the time in the current day.\n        const date = new Date(dateBase.getTime() + partialMilliseconds);\n\n        // Now add the number of full days. JS will properly handle the month/year changes.\n        date.setDate(date.getDate() + fullDays);\n\n        return date;\n    }\n};\n"],"mappings":"AAAA,YAAY;;AAEZ;AACA,MAAMA,QAAQ,GAAG,IAAIC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC;;AAErC;AACA,MAAMC,iBAAiB,GAAG,IAAID,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;;AAE/C;AACA,MAAME,iBAAiB,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;;AAE7C;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG;EACb;AACJ;AACA;AACA;AACA;EACIC,YAAY,CAACC,IAAI,EAAE;IACf;IACA,MAAMC,QAAQ,GAAG,IAAIP,IAAI,CAACM,IAAI,CAACE,OAAO,EAAE,CAAC;IACzCD,QAAQ,CAACE,QAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;IAE7B;IACA;IACA,IAAIC,MAAM,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACL,QAAQ,GAAGR,QAAQ,IAAIG,iBAAiB,CAAC;;IAElE;IACAQ,MAAM,IAAI,CAACJ,IAAI,GAAGC,QAAQ,IAAIL,iBAAiB;;IAE/C;IACA,IAAII,IAAI,GAAGL,iBAAiB,EAAES,MAAM,IAAI,CAAC;IAEzC,OAAOA,MAAM;EACjB,CAAC;EAED;AACJ;AACA;AACA;AACA;EACIG,YAAY,CAACH,MAAM,EAAE;IACjB;IACA,IAAIA,MAAM,GAAG,IAAI,CAACL,YAAY,CAACJ,iBAAiB,CAAC,EAAES,MAAM,EAAE;;IAE3D;IACA,MAAMI,QAAQ,GAAGH,IAAI,CAACI,KAAK,CAACL,MAAM,CAAC;IACnC,MAAMM,mBAAmB,GAAGL,IAAI,CAACC,KAAK,CAAC,CAACF,MAAM,GAAGI,QAAQ,IAAIZ,iBAAiB,CAAC;;IAE/E;IACA,MAAMI,IAAI,GAAG,IAAIN,IAAI,CAACD,QAAQ,CAACS,OAAO,EAAE,GAAGQ,mBAAmB,CAAC;;IAE/D;IACAV,IAAI,CAACW,OAAO,CAACX,IAAI,CAACY,OAAO,EAAE,GAAGJ,QAAQ,CAAC;IAEvC,OAAOR,IAAI;EACf;AACJ,CAAC"},"metadata":{},"sourceType":"script"}