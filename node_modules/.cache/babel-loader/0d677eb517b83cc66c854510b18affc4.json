{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _ = require(\"lodash\");\nvar XML_DECLARATION = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"yes\\\"?>\";\n\n/**\n * XML document builder.\n * @private\n */\nvar XmlBuilder = /*#__PURE__*/function () {\n  function XmlBuilder() {\n    _classCallCheck(this, XmlBuilder);\n  }\n  _createClass(XmlBuilder, [{\n    key: \"build\",\n    value:\n    /**\n     * Build an XML string from the JSON object.\n     * @param {{}} node - The node.\n     * @returns {string} The XML text.\n     */\n    function build(node) {\n      this._i = 0;\n      var xml = this._build(node, '');\n      if (xml === '') return;\n      return XML_DECLARATION + xml;\n    }\n\n    /**\n     * Build the XML string. (This is the internal recursive method.)\n     * @param {{}} node - The node.\n     * @param {string} xml - The initial XML doc string.\n     * @returns {string} The generated XML element.\n     * @private\n     */\n  }, {\n    key: \"_build\",\n    value: function _build(node, xml) {\n      var _this = this;\n      // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n      // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n      // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n      // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n      // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n      if (this._i++ % 1000000 === 0) {\n        this._c = xml[0];\n      }\n\n      // If the node has a toXml method, call it.\n      if (node && _.isFunction(node.toXml)) node = node.toXml();\n      if (_.isObject(node)) {\n        // If the node is an object, then it maps to an element. Check if it has a name.\n        if (!node.name) throw new Error(\"XML node does not have name: \".concat(JSON.stringify(node)));\n\n        // Add the opening tag.\n        xml += \"<\".concat(node.name);\n\n        // Add any node attributes\n        _.forOwn(node.attributes, function (value, name) {\n          xml += \" \".concat(name, \"=\\\"\").concat(_this._escapeString(value, true), \"\\\"\");\n        });\n        if (_.isEmpty(node.children)) {\n          // Self-close the tag if no children.\n          xml += \"/>\";\n        } else {\n          xml += \">\";\n\n          // Recursively add any children.\n          _.forEach(node.children, function (child) {\n            // Add the children to the XML.\n            xml = _this._build(child, xml);\n          });\n\n          // Close the tag.\n          xml += \"</\".concat(node.name, \">\");\n        }\n      } else if (!_.isNil(node)) {\n        // It not an object, this should be a text node. Just add it.\n        xml += this._escapeString(node);\n      }\n\n      // Return the updated XML element.\n      return xml;\n    }\n\n    /**\n     * Escape a string for use in XML by replacing &, \", ', <, and >.\n     * @param {*} value - The value to escape.\n     * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n     * @returns {string} The escaped string.\n     * @private\n     */\n  }, {\n    key: \"_escapeString\",\n    value: function _escapeString(value, isAttribute) {\n      if (_.isNil(value)) return value;\n      value = value.toString().replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n      .replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n      if (isAttribute) {\n        value = value.replace(/\"/g, \"&quot;\");\n      }\n      return value;\n    }\n  }]);\n  return XmlBuilder;\n}();\nmodule.exports = XmlBuilder;","map":{"version":3,"names":["_","require","XML_DECLARATION","XmlBuilder","node","_i","xml","_build","_c","isFunction","toXml","isObject","name","Error","JSON","stringify","forOwn","attributes","value","_escapeString","isEmpty","children","forEach","child","isNil","isAttribute","toString","replace","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/XmlBuilder.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst XML_DECLARATION = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>`;\n\n/**\n * XML document builder.\n * @private\n */\nclass XmlBuilder {\n    /**\n     * Build an XML string from the JSON object.\n     * @param {{}} node - The node.\n     * @returns {string} The XML text.\n     */\n    build(node) {\n        this._i = 0;\n        const xml = this._build(node, '');\n        if (xml === '') return;\n        return XML_DECLARATION + xml;\n    }\n\n    /**\n     * Build the XML string. (This is the internal recursive method.)\n     * @param {{}} node - The node.\n     * @param {string} xml - The initial XML doc string.\n     * @returns {string} The generated XML element.\n     * @private\n     */\n    _build(node, xml) {\n        // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n        // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n        // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n        // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n        // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n        if (this._i++ % 1000000 === 0) {\n            this._c = xml[0];\n        }\n\n        // If the node has a toXml method, call it.\n        if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n        if (_.isObject(node)) {\n            // If the node is an object, then it maps to an element. Check if it has a name.\n            if (!node.name) throw new Error(`XML node does not have name: ${JSON.stringify(node)}`);\n\n            // Add the opening tag.\n            xml += `<${node.name}`;\n\n            // Add any node attributes\n            _.forOwn(node.attributes, (value, name) => {\n                xml += ` ${name}=\"${this._escapeString(value, true)}\"`;\n            });\n\n            if (_.isEmpty(node.children)) {\n                // Self-close the tag if no children.\n                xml += \"/>\";\n            } else {\n                xml += \">\";\n                \n                // Recursively add any children.\n                _.forEach(node.children, child => {\n                    // Add the children to the XML.\n                    xml = this._build(child, xml);\n                });\n\n                // Close the tag.\n                xml += `</${node.name}>`;\n            }\n        } else if (!_.isNil(node)) {\n            // It not an object, this should be a text node. Just add it.\n            xml += this._escapeString(node);\n        }\n\n        // Return the updated XML element.\n        return xml;\n    }\n\n    /**\n     * Escape a string for use in XML by replacing &, \", ', <, and >.\n     * @param {*} value - The value to escape.\n     * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n     * @returns {string} The escaped string.\n     * @private\n     */\n    _escapeString(value, isAttribute) {\n        if (_.isNil(value)) return value;\n        value = value.toString()\n            .replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\");\n\n        if (isAttribute) {\n            value = value.replace(/\"/g, \"&quot;\");\n        }\n\n        return value;\n    }\n}\n\nmodule.exports = XmlBuilder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}