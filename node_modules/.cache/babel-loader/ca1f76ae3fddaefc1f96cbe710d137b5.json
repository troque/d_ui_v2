{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _ = require(\"lodash\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar addressConverter = require(\"./addressConverter\");\nvar dateConverter = require(\"./dateConverter\");\nvar regexify = require(\"./regexify\");\nvar xmlq = require(\"./xmlq\");\nvar FormulaError = require(\"./FormulaError\");\nvar Style = require(\"./Style\");\nvar RichText = require(\"./RichText\");\n\n/**\n * A cell\n */\nvar Cell = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of cell.\n  //  * @param {Row} row - The parent row.\n  //  * @param {{}} node - The cell node.\n  //  */\n  function Cell(row, node, styleId) {\n    _classCallCheck(this, Cell);\n    this._row = row;\n    this._init(node, styleId);\n  }\n\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the cell is the active cell in the sheet.\n   * @returns {boolean} True if active, false otherwise.\n   */ /**\n      * Make the cell the active cell in the sheet.\n      * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.\n      * @returns {Cell} The cell.\n      */\n  _createClass(Cell, [{\n    key: \"active\",\n    value: function active() {\n      var _this = this;\n      return new ArgHandler('Cell.active').case(function () {\n        return _this.sheet().activeCell() === _this;\n      }).case('boolean', function (active) {\n        if (!active) throw new Error(\"Deactivating cell directly not supported. Activate a different cell instead.\");\n        _this.sheet().activeCell(_this);\n        return _this;\n      }).handle(arguments);\n    }\n\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.rowAnchored] - Anchor the row.\n     * @param {boolean} [opts.columnAnchored] - Anchor the column.\n     * @param {boolean} [opts.anchored] - Anchor both the row and the column.\n     * @returns {string} The address\n     */\n  }, {\n    key: \"address\",\n    value: function address(opts) {\n      return addressConverter.toAddress({\n        type: 'cell',\n        rowNumber: this.rowNumber(),\n        columnNumber: this.columnNumber(),\n        sheetName: opts && opts.includeSheetName && this.sheet().name(),\n        rowAnchored: opts && (opts.rowAnchored || opts.anchored),\n        columnAnchored: opts && (opts.columnAnchored || opts.anchored)\n      });\n    }\n\n    /**\n     * Gets the parent column of the cell.\n     * @returns {Column} The parent column.\n     */\n  }, {\n    key: \"column\",\n    value: function column() {\n      return this.sheet().column(this.columnNumber());\n    }\n\n    /**\n     * Clears the contents from the cell.\n     * @returns {Cell} The cell.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;\n      delete this._value;\n      delete this._formulaType;\n      delete this._formula;\n      delete this._sharedFormulaId;\n      delete this._formulaRef;\n\n      // TODO in future version: Move shared formula to some other cell. This would require parsing the formula...\n      if (!_.isNil(hostSharedFormulaId)) this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);\n      return this;\n    }\n\n    /**\n     * Gets the column name of the cell.\n     * @returns {string} The column name.\n     */\n  }, {\n    key: \"columnName\",\n    value: function columnName() {\n      return addressConverter.columnNumberToName(this.columnNumber());\n    }\n\n    /**\n     * Gets the column number of the cell (1-based).\n     * @returns {number} The column number.\n     */\n  }, {\n    key: \"columnNumber\",\n    value: function columnNumber() {\n      return this._columnNumber;\n    }\n\n    /**\n     * Find the given pattern in the cell and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var value = this.value();\n      if (typeof value !== 'string') return false;\n      if (_.isNil(replacement)) {\n        return pattern.test(value);\n      } else {\n        var replaced = value.replace(pattern, replacement);\n        if (replaced === value) return false;\n        this.value(replaced);\n        return true;\n      }\n    }\n\n    /**\n     * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.\n     * @returns {string} The formula in the cell.\n     */ /**\n        * Sets the formula in the cell.\n        * @param {string} formula - The formula to set.\n        * @returns {Cell} The cell.\n        */\n  }, {\n    key: \"formula\",\n    value: function formula() {\n      var _this2 = this;\n      return new ArgHandler('Cell.formula').case(function () {\n        // TODO in future: Return translated formula.\n        if (_this2._formulaType === \"shared\" && !_this2._formulaRef) return \"SHARED\";\n        return _this2._formula;\n      }).case('nil', function () {\n        _this2.clear();\n        return _this2;\n      }).case('string', function (formula) {\n        _this2.clear();\n        _this2._formulaType = \"normal\";\n        _this2._formula = formula;\n        return _this2;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets the hyperlink attached to the cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     */ /**\n        * Set or clear the hyperlink on the cell.\n        * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.\n        * @returns {Cell} The cell.\n        */ /**\n           * Set the hyperlink options on the cell.\n           * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n           * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n           * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n           * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n           * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n           * @returns {Cell} The cell.\n           */\n  }, {\n    key: \"hyperlink\",\n    value: function hyperlink() {\n      var _this3 = this;\n      return new ArgHandler('Cell.hyperlink').case(function () {\n        return _this3.sheet().hyperlink(_this3.address());\n      }).case('string', function (hyperlink) {\n        _this3.sheet().hyperlink(_this3.address(), hyperlink);\n        return _this3;\n      }).case(['object'], function (opts) {\n        _this3.sheet().hyperlink(_this3.address(), opts);\n        return _this3;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets the data validation object attached to the cell.\n     * @returns {object|undefined} The data validation or undefined if not set.\n     */ /**\n        * Set or clear the data validation object of the cell.\n        * @param {object|undefined} dataValidation - Object or null to clear.\n        * @returns {Cell} The cell.\n        */\n  }, {\n    key: \"dataValidation\",\n    value: function dataValidation() {\n      var _this4 = this;\n      return new ArgHandler('Cell.dataValidation').case(function () {\n        return _this4.sheet().dataValidation(_this4.address());\n      }).case('boolean', function (obj) {\n        return _this4.sheet().dataValidation(_this4.address(), obj);\n      }).case('*', function (obj) {\n        _this4.sheet().dataValidation(_this4.address(), obj);\n        return _this4;\n      }).handle(arguments);\n    }\n\n    /**\n     * Callback used by tap.\n     * @callback Cell~tapCallback\n     * @param {Cell} cell - The cell\n     * @returns {undefined}\n     */ /**\n        * Invoke a callback on the cell and return the cell. Useful for method chaining.\n        * @param {Cell~tapCallback} callback - The callback function.\n        * @returns {Cell} The cell.\n        */\n  }, {\n    key: \"tap\",\n    value: function tap(callback) {\n      callback(this);\n      return this;\n    }\n\n    /**\n     * Callback used by thru.\n     * @callback Cell~thruCallback\n     * @param {Cell} cell - The cell\n     * @returns {*} The value to return from thru.\n     */ /**\n        * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.\n        * @param {Cell~thruCallback} callback - The callback function.\n        * @returns {*} The return value of the callback.\n        */\n  }, {\n    key: \"thru\",\n    value: function thru(callback) {\n      return callback(this);\n    }\n\n    /**\n     * Create a range from this cell and another.\n     * @param {Cell|string} cell - The other cell or cell address to range to.\n     * @returns {Range} The range.\n     */\n  }, {\n    key: \"rangeTo\",\n    value: function rangeTo(cell) {\n      return this.sheet().range(this, cell);\n    }\n\n    /**\n     * Returns a cell with a relative position given the offsets provided.\n     * @param {number} rowOffset - The row offset (0 for the current row).\n     * @param {number} columnOffset - The column offset (0 for the current column).\n     * @returns {Cell} The relative cell.\n     */\n  }, {\n    key: \"relativeCell\",\n    value: function relativeCell(rowOffset, columnOffset) {\n      var row = rowOffset + this.rowNumber();\n      var column = columnOffset + this.columnNumber();\n      return this.sheet().cell(row, column);\n    }\n\n    /**\n     * Gets the parent row of the cell.\n     * @returns {Row} The parent row.\n     */\n  }, {\n    key: \"row\",\n    value: function row() {\n      return this._row;\n    }\n\n    /**\n     * Gets the row number of the cell (1-based).\n     * @returns {number} The row number.\n     */\n  }, {\n    key: \"rowNumber\",\n    value: function rowNumber() {\n      return this.row().rowNumber();\n    }\n\n    /**\n     * Gets the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n  }, {\n    key: \"sheet\",\n    value: function sheet() {\n      return this.row().sheet();\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     */ /**\n        * Gets multiple styles.\n        * @param {Array.<string>} names - The names of the style.\n        * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n        */ /**\n           * Sets an individual style.\n           * @param {string} name - The name of the style.\n           * @param {*} value - The value to set.\n           * @returns {Cell} The cell.\n           */ /**\n              * Sets the styles in the range starting with the cell.\n              * @param {string} name - The name of the style.\n              * @param {Array.<Array.<*>>} - 2D array of values to set.\n              * @returns {Range} The range that was set.\n              */ /**\n                 * Sets multiple styles.\n                 * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n                 * @returns {Cell} The cell.\n                 */ /**\n                    * Sets to a specific style\n                    * @param {Style} style - Style object given from stylesheet.createStyle\n                    * @returns {Cell} The cell.\n                    */\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this5 = this;\n      if (!this._style && !(arguments[0] instanceof Style)) {\n        this._style = this.workbook().styleSheet().createStyle(this._styleId);\n      }\n      return new ArgHandler(\"Cell.style\").case('string', function (name) {\n        // Get single value\n        return _this5._style.style(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this5.style(name);\n        });\n        return values;\n      }).case([\"string\", \"array\"], function (name, values) {\n        var numRows = values.length;\n        var numCols = values[0].length;\n        var range = _this5.rangeTo(_this5.relativeCell(numRows - 1, numCols - 1));\n        return range.style(name, values);\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value for all cells to a single value\n        _this5._style.style(name, value);\n        return _this5;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n          _this5.style(name, value);\n        }\n        return _this5;\n      }).case('Style', function (style) {\n        _this5._style = style;\n        _this5._styleId = style.id();\n        return _this5;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets the value of the cell.\n     * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.\n     */ /**\n        * Sets the value of the cell.\n        * @param {string|boolean|number|null|undefined|RichText} value - The value to set.\n        * @returns {Cell} The cell.\n        */ /**\n           * Sets the values in the range starting with the cell.\n           * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.\n           * @returns {Range} The range that was set.\n           */\n  }, {\n    key: \"value\",\n    value: function value() {\n      var _this6 = this;\n      return new ArgHandler('Cell.value').case(function () {\n        if (_this6._value instanceof RichText) {\n          return _this6._value.getInstanceWithCellRef(_this6);\n        }\n        return _this6._value;\n      }).case(\"array\", function (values) {\n        var numRows = values.length;\n        var numCols = values[0].length;\n        var range = _this6.rangeTo(_this6.relativeCell(numRows - 1, numCols - 1));\n        return range.value(values);\n      }).case('*', function (value) {\n        _this6.clear();\n        if (value instanceof RichText) {\n          _this6._value = value.copy(_this6);\n        } else {\n          _this6._value = value;\n        }\n        return _this6;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this.row().workbook();\n    }\n\n    /**\n     * Append horizontal page break after the cell.\n     * @returns {Cell} the cell.\n     */\n  }, {\n    key: \"addHorizontalPageBreak\",\n    value: function addHorizontalPageBreak() {\n      this.row().addPageBreak();\n      return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Gets the formula if a shared formula ref cell.\n     * @returns {string|undefined} The formula.\n     * @ignore\n     */\n  }, {\n    key: \"getSharedRefFormula\",\n    value: function getSharedRefFormula() {\n      return this._formulaType === \"shared\" ? this._formulaRef && this._formula : undefined;\n    }\n\n    /**\n     * Check if this cell uses a given shared a formula ID.\n     * @param {number} id - The shared formula ID.\n     * @returns {boolean} A flag indicating if shared.\n     * @ignore\n     */\n  }, {\n    key: \"sharesFormula\",\n    value: function sharesFormula(id) {\n      return this._formulaType === \"shared\" && this._sharedFormulaId === id;\n    }\n\n    /**\n     * Set a shared formula on the cell.\n     * @param {number} id - The shared formula index.\n     * @param {string} [formula] - The formula (if the reference cell).\n     * @param {string} [sharedRef] - The address of the shared range (if the reference cell).\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"setSharedFormula\",\n    value: function setSharedFormula(id, formula, sharedRef) {\n      this.clear();\n      this._formulaType = \"shared\";\n      this._sharedFormulaId = id;\n      this._formula = formula;\n      this._formulaRef = sharedRef;\n    }\n\n    /**\n     * Convert the cell to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      // Create a node.\n      var node = {\n        name: 'c',\n        attributes: this._remainingAttributes || {},\n        // Start with any remaining attributes we don't current handle.\n        children: []\n      };\n\n      // Set the address.\n      node.attributes.r = this.address();\n      if (!_.isNil(this._formulaType)) {\n        // Add the formula.\n        var fNode = {\n          name: 'f',\n          attributes: this._remainingFormulaAttributes || {}\n        };\n        if (this._formulaType !== \"normal\") fNode.attributes.t = this._formulaType;\n        if (!_.isNil(this._formulaRef)) fNode.attributes.ref = this._formulaRef;\n        if (!_.isNil(this._sharedFormulaId)) fNode.attributes.si = this._sharedFormulaId;\n        if (!_.isNil(this._formula)) fNode.children = [this._formula];\n        node.children.push(fNode);\n      } else if (!_.isNil(this._value)) {\n        // Add the value. Don't emit value if a formula is set as Excel will show this stale value.\n        var type, text;\n        if (typeof this._value === \"string\") {\n          type = \"s\";\n          text = this.workbook().sharedStrings().getIndexForString(this._value);\n        } else if (typeof this._value === \"boolean\") {\n          type = \"b\";\n          text = this._value ? 1 : 0;\n        } else if (typeof this._value === \"number\") {\n          text = this._value;\n        } else if (this._value instanceof Date) {\n          text = dateConverter.dateToNumber(this._value);\n        } else if (this._value instanceof RichText || typeof this._value === \"object\" && this._value.constructor.name === \"RichText\") {\n          // Hack to make Jasmine test work\n          type = \"s\";\n          text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());\n        }\n        if (type) node.attributes.t = type;\n        var vNode = {\n          name: 'v',\n          children: [text]\n        };\n        node.children.push(vNode);\n      }\n\n      // If the style is set, set the style ID.\n      if (!_.isNil(this._style)) {\n        node.attributes.s = this._style.id();\n      } else if (!_.isNil(this._styleId)) {\n        node.attributes.s = this._styleId;\n      }\n\n      // Add any remaining children that we don't currently handle.\n      if (this._remainingChildren) {\n        node.children = node.children.concat(this._remainingChildren);\n      }\n      return node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Initialize the cell node.\n     * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.\n     * @param {number} [styleId] - The style ID for the new cell.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_init\",\n    value: function _init(nodeOrColumnNumber, styleId) {\n      if (_.isObject(nodeOrColumnNumber)) {\n        // Parse the existing node.\n        this._parseNode(nodeOrColumnNumber);\n      } else {\n        // This is a new cell.\n        this._columnNumber = nodeOrColumnNumber;\n        if (!_.isNil(styleId)) this._styleId = styleId;\n      }\n    }\n\n    /**\n     * Parse the existing node.\n     * @param {{}} node - The existing node.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_parseNode\",\n    value: function _parseNode(node) {\n      // Parse the column numbr out of the address.\n      var ref = addressConverter.fromAddress(node.attributes.r);\n      this._columnNumber = ref.columnNumber;\n\n      // Store the style ID if present.\n      if (!_.isNil(node.attributes.s)) this._styleId = node.attributes.s;\n\n      // Parse the formula if present..\n      var fNode = xmlq.findChild(node, 'f');\n      if (fNode) {\n        this._formulaType = fNode.attributes.t || \"normal\";\n        this._formulaRef = fNode.attributes.ref;\n        this._formula = fNode.children[0];\n        this._sharedFormulaId = fNode.attributes.si;\n        if (!_.isNil(this._sharedFormulaId)) {\n          // Update the sheet's max shared formula ID so we can set future IDs an index beyond this.\n          this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);\n        }\n\n        // Delete the known attributes.\n        delete fNode.attributes.t;\n        delete fNode.attributes.ref;\n        delete fNode.attributes.si;\n\n        // If any unknown attributes are still present, store them for later output.\n        if (!_.isEmpty(fNode.attributes)) this._remainingFormulaAttributes = fNode.attributes;\n      }\n\n      // Parse the value.\n      var type = node.attributes.t;\n      if (type === \"s\") {\n        // String value.\n        var vNode = xmlq.findChild(node, 'v');\n        if (vNode) {\n          var sharedIndex = vNode.children[0];\n          this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex);\n\n          // rich text\n          if (_.isArray(this._value)) {\n            this._value = new RichText(this._value);\n          }\n        } else {\n          this._value = '';\n        }\n      } else if (type === \"str\") {\n        // Simple string value.\n        var _vNode = xmlq.findChild(node, 'v');\n        this._value = _vNode && _vNode.children[0];\n      } else if (type === \"inlineStr\") {\n        // Inline string value: can be simple text or rich text.\n        var isNode = xmlq.findChild(node, 'is');\n        if (isNode.children[0].name === \"t\") {\n          var tNode = isNode.children[0];\n          this._value = tNode.children[0];\n        } else {\n          this._value = isNode.children;\n        }\n      } else if (type === \"b\") {\n        // Boolean value.\n        this._value = xmlq.findChild(node, 'v').children[0] === 1;\n      } else if (type === \"e\") {\n        // Error value.\n        var error = xmlq.findChild(node, 'v').children[0];\n        this._value = FormulaError.getError(error);\n      } else {\n        // Number value.\n        var _vNode2 = xmlq.findChild(node, 'v');\n        this._value = _vNode2 && Number(_vNode2.children[0]);\n      }\n\n      // Delete known attributes.\n      delete node.attributes.r;\n      delete node.attributes.s;\n      delete node.attributes.t;\n\n      // If any unknown attributes are still present, store them for later output.\n      if (!_.isEmpty(node.attributes)) this._remainingAttributes = node.attributes;\n\n      // Delete known children.\n      xmlq.removeChild(node, 'f');\n      xmlq.removeChild(node, 'v');\n      xmlq.removeChild(node, 'is');\n\n      // If any unknown children are still present, store them for later output.\n      if (!_.isEmpty(node.children)) this._remainingChildren = node.children;\n    }\n  }]);\n  return Cell;\n}();\nmodule.exports = Cell;\n\n/*\n<c r=\"A6\" s=\"1\" t=\"s\">\n    <v>2</v>\n</c>\n*/","map":{"version":3,"names":["_","require","ArgHandler","addressConverter","dateConverter","regexify","xmlq","FormulaError","Style","RichText","Cell","row","node","styleId","_row","_init","case","sheet","activeCell","active","Error","handle","arguments","opts","toAddress","type","rowNumber","columnNumber","sheetName","includeSheetName","name","rowAnchored","anchored","columnAnchored","column","hostSharedFormulaId","_formulaRef","_sharedFormulaId","_value","_formulaType","_formula","isNil","clearCellsUsingSharedFormula","columnNumberToName","_columnNumber","pattern","replacement","value","test","replaced","replace","clear","formula","hyperlink","address","dataValidation","obj","callback","cell","range","rowOffset","columnOffset","_style","workbook","styleSheet","createStyle","_styleId","style","names","values","forEach","numRows","length","numCols","rangeTo","relativeCell","nameValues","hasOwnProperty","id","getInstanceWithCellRef","copy","addPageBreak","undefined","sharedRef","attributes","_remainingAttributes","children","r","fNode","_remainingFormulaAttributes","t","ref","si","push","text","sharedStrings","getIndexForString","Date","dateToNumber","constructor","toXml","vNode","s","_remainingChildren","concat","nodeOrColumnNumber","isObject","_parseNode","fromAddress","findChild","updateMaxSharedFormulaId","isEmpty","sharedIndex","getStringByIndex","isArray","isNode","tNode","error","getError","Number","removeChild","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Cell.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\nconst dateConverter = require(\"./dateConverter\");\nconst regexify = require(\"./regexify\");\nconst xmlq = require(\"./xmlq\");\nconst FormulaError = require(\"./FormulaError\");\nconst Style = require(\"./Style\");\nconst RichText = require(\"./RichText\");\n\n/**\n * A cell\n */\nclass Cell {\n    // /**\n    //  * Creates a new instance of cell.\n    //  * @param {Row} row - The parent row.\n    //  * @param {{}} node - The cell node.\n    //  */\n    constructor(row, node, styleId) {\n        this._row = row;\n        this._init(node, styleId);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Gets a value indicating whether the cell is the active cell in the sheet.\n     * @returns {boolean} True if active, false otherwise.\n     *//**\n     * Make the cell the active cell in the sheet.\n     * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different cell instead.\n     * @returns {Cell} The cell.\n     */\n    active() {\n        return new ArgHandler('Cell.active')\n            .case(() => {\n                return this.sheet().activeCell() === this;\n            })\n            .case('boolean', active => {\n                if (!active) throw new Error(\"Deactivating cell directly not supported. Activate a different cell instead.\");\n                this.sheet().activeCell(this);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the address of the column.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.rowAnchored] - Anchor the row.\n     * @param {boolean} [opts.columnAnchored] - Anchor the column.\n     * @param {boolean} [opts.anchored] - Anchor both the row and the column.\n     * @returns {string} The address\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'cell',\n            rowNumber: this.rowNumber(),\n            columnNumber: this.columnNumber(),\n            sheetName: opts && opts.includeSheetName && this.sheet().name(),\n            rowAnchored: opts && (opts.rowAnchored || opts.anchored),\n            columnAnchored: opts && (opts.columnAnchored || opts.anchored)\n        });\n    }\n\n    /**\n     * Gets the parent column of the cell.\n     * @returns {Column} The parent column.\n     */\n    column() {\n        return this.sheet().column(this.columnNumber());\n    }\n\n    /**\n     * Clears the contents from the cell.\n     * @returns {Cell} The cell.\n     */\n    clear() {\n        const hostSharedFormulaId = this._formulaRef && this._sharedFormulaId;\n\n        delete this._value;\n        delete this._formulaType;\n        delete this._formula;\n        delete this._sharedFormulaId;\n        delete this._formulaRef;\n\n        // TODO in future version: Move shared formula to some other cell. This would require parsing the formula...\n        if (!_.isNil(hostSharedFormulaId)) this.sheet().clearCellsUsingSharedFormula(hostSharedFormulaId);\n\n        return this;\n    }\n\n    /**\n     * Gets the column name of the cell.\n     * @returns {string} The column name.\n     */\n    columnName() {\n        return addressConverter.columnNumberToName(this.columnNumber());\n    }\n\n    /**\n     * Gets the column number of the cell (1-based).\n     * @returns {number} The column number.\n     */\n    columnNumber() {\n        return this._columnNumber;\n    }\n\n    /**\n     * Find the given pattern in the cell and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in the cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        const value = this.value();\n        if (typeof value !== 'string') return false;\n\n        if (_.isNil(replacement)) {\n            return pattern.test(value);\n        } else {\n            const replaced = value.replace(pattern, replacement);\n            if (replaced === value) return false;\n            this.value(replaced);\n            return true;\n        }\n    }\n\n    /**\n     * Gets the formula in the cell. Note that if a formula was set as part of a range, the getter will return 'SHARED'. This is a limitation that may be addressed in a future release.\n     * @returns {string} The formula in the cell.\n     *//**\n     * Sets the formula in the cell.\n     * @param {string} formula - The formula to set.\n     * @returns {Cell} The cell.\n     */\n    formula() {\n        return new ArgHandler('Cell.formula')\n            .case(() => {\n                // TODO in future: Return translated formula.\n                if (this._formulaType === \"shared\" && !this._formulaRef) return \"SHARED\";\n                return this._formula;\n            })\n            .case('nil', () => {\n                this.clear();\n                return this;\n            })\n            .case('string', formula => {\n                this.clear();\n                this._formulaType = \"normal\";\n                this._formula = formula;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the hyperlink attached to the cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     *//**\n     * Set or clear the hyperlink on the cell.\n     * @param {string|Cell|undefined} hyperlink - The hyperlink to set or undefined to clear.\n     * @returns {Cell} The cell.\n     *//**\n     * Set the hyperlink options on the cell.\n     * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n     * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n     * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n     * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n     * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n     * @returns {Cell} The cell.\n     */\n    hyperlink() {\n        return new ArgHandler('Cell.hyperlink')\n            .case(() => {\n                return this.sheet().hyperlink(this.address());\n            })\n            .case('string', hyperlink => {\n                this.sheet().hyperlink(this.address(), hyperlink);\n                return this;\n            })\n            .case(['object'], opts => {\n                this.sheet().hyperlink(this.address(), opts);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n\n    /**\n     * Gets the data validation object attached to the cell.\n     * @returns {object|undefined} The data validation or undefined if not set.\n     *//**\n     * Set or clear the data validation object of the cell.\n     * @param {object|undefined} dataValidation - Object or null to clear.\n     * @returns {Cell} The cell.\n     */\n    dataValidation() {\n        return new ArgHandler('Cell.dataValidation')\n            .case(() => {\n                return this.sheet().dataValidation(this.address());\n            })\n            .case('boolean', obj => {\n                return this.sheet().dataValidation(this.address(), obj);\n            })\n            .case('*', obj => {\n                this.sheet().dataValidation(this.address(), obj);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by tap.\n     * @callback Cell~tapCallback\n     * @param {Cell} cell - The cell\n     * @returns {undefined}\n     *//**\n     * Invoke a callback on the cell and return the cell. Useful for method chaining.\n     * @param {Cell~tapCallback} callback - The callback function.\n     * @returns {Cell} The cell.\n     */\n    tap(callback) {\n        callback(this);\n        return this;\n    }\n\n    /**\n     * Callback used by thru.\n     * @callback Cell~thruCallback\n     * @param {Cell} cell - The cell\n     * @returns {*} The value to return from thru.\n     *//**\n     * Invoke a callback on the cell and return the value provided by the callback. Useful for method chaining.\n     * @param {Cell~thruCallback} callback - The callback function.\n     * @returns {*} The return value of the callback.\n     */\n    thru(callback) {\n        return callback(this);\n    }\n\n    /**\n     * Create a range from this cell and another.\n     * @param {Cell|string} cell - The other cell or cell address to range to.\n     * @returns {Range} The range.\n     */\n    rangeTo(cell) {\n        return this.sheet().range(this, cell);\n    }\n\n    /**\n     * Returns a cell with a relative position given the offsets provided.\n     * @param {number} rowOffset - The row offset (0 for the current row).\n     * @param {number} columnOffset - The column offset (0 for the current column).\n     * @returns {Cell} The relative cell.\n     */\n    relativeCell(rowOffset, columnOffset) {\n        const row = rowOffset + this.rowNumber();\n        const column = columnOffset + this.columnNumber();\n        return this.sheet().cell(row, column);\n    }\n\n    /**\n     * Gets the parent row of the cell.\n     * @returns {Row} The parent row.\n     */\n    row() {\n        return this._row;\n    }\n\n    /**\n     * Gets the row number of the cell (1-based).\n     * @returns {number} The row number.\n     */\n    rowNumber() {\n        return this.row().rowNumber();\n    }\n\n    /**\n     * Gets the parent sheet.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this.row().sheet();\n    }\n\n    /**\n     * Gets an individual style.\n     * @param {string} name - The name of the style.\n     * @returns {*} The style.\n     *//**\n     * Gets multiple styles.\n     * @param {Array.<string>} names - The names of the style.\n     * @returns {object.<string, *>} Object whose keys are the style names and values are the styles.\n     *//**\n     * Sets an individual style.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets the styles in the range starting with the cell.\n     * @param {string} name - The name of the style.\n     * @param {Array.<Array.<*>>} - 2D array of values to set.\n     * @returns {Range} The range that was set.\n     *//**\n     * Sets multiple styles.\n     * @param {object.<string, *>} styles - Object whose keys are the style names and values are the styles to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets to a specific style\n     * @param {Style} style - Style object given from stylesheet.createStyle\n     * @returns {Cell} The cell.\n     */\n    style() {\n        if (!this._style && !(arguments[0] instanceof Style)) {\n            this._style = this.workbook().styleSheet().createStyle(this._styleId);\n        }\n\n        return new ArgHandler(\"Cell.style\")\n            .case('string', name => {\n                // Get single value\n                return this._style.style(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case([\"string\", \"array\"], (name, values) => {\n                const numRows = values.length;\n                const numCols = values[0].length;\n                const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n                return range.style(name, values);\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                this._style.style(name, value);\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                this._style = style;\n                this._styleId = style.id();\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the value of the cell.\n     * @returns {string|boolean|number|Date|RichText|undefined} The value of the cell.\n     *//**\n     * Sets the value of the cell.\n     * @param {string|boolean|number|null|undefined|RichText} value - The value to set.\n     * @returns {Cell} The cell.\n     *//**\n     * Sets the values in the range starting with the cell.\n     * @param {Array.<Array.<string|boolean|number|null|undefined>>} - 2D array of values to set.\n     * @returns {Range} The range that was set.\n     */\n    value() {\n        return new ArgHandler('Cell.value')\n            .case(() => {\n                if (this._value instanceof RichText) {\n                    return this._value.getInstanceWithCellRef(this);\n                }\n                return this._value;\n            })\n            .case(\"array\", values => {\n                const numRows = values.length;\n                const numCols = values[0].length;\n                const range = this.rangeTo(this.relativeCell(numRows - 1, numCols - 1));\n                return range.value(values);\n            })\n            .case('*', value => {\n                this.clear();\n                if (value instanceof RichText) {\n                    this._value = value.copy(this);\n                } else {\n                    this._value = value;\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.row().workbook();\n    }\n\n    /**\n     * Append horizontal page break after the cell.\n     * @returns {Cell} the cell.\n     */\n    addHorizontalPageBreak() {\n        this.row().addPageBreak();\n        return this;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Gets the formula if a shared formula ref cell.\n     * @returns {string|undefined} The formula.\n     * @ignore\n     */\n    getSharedRefFormula() {\n        return this._formulaType === \"shared\" ? this._formulaRef && this._formula : undefined;\n    }\n\n    /**\n     * Check if this cell uses a given shared a formula ID.\n     * @param {number} id - The shared formula ID.\n     * @returns {boolean} A flag indicating if shared.\n     * @ignore\n     */\n    sharesFormula(id) {\n        return this._formulaType === \"shared\" && this._sharedFormulaId === id;\n    }\n\n    /**\n     * Set a shared formula on the cell.\n     * @param {number} id - The shared formula index.\n     * @param {string} [formula] - The formula (if the reference cell).\n     * @param {string} [sharedRef] - The address of the shared range (if the reference cell).\n     * @returns {undefined}\n     * @ignore\n     */\n    setSharedFormula(id, formula, sharedRef) {\n        this.clear();\n\n        this._formulaType = \"shared\";\n        this._sharedFormulaId = id;\n        this._formula = formula;\n        this._formulaRef = sharedRef;\n    }\n\n    /**\n     * Convert the cell to an XML object.\n     * @returns {{}} The XML form.\n     * @ignore\n     */\n    toXml() {\n        // Create a node.\n        const node = {\n            name: 'c',\n            attributes: this._remainingAttributes || {}, // Start with any remaining attributes we don't current handle.\n            children: []\n        };\n\n        // Set the address.\n        node.attributes.r = this.address();\n\n        if (!_.isNil(this._formulaType)) {\n            // Add the formula.\n            const fNode = {\n                name: 'f',\n                attributes: this._remainingFormulaAttributes || {}\n            };\n\n            if (this._formulaType !== \"normal\") fNode.attributes.t = this._formulaType;\n            if (!_.isNil(this._formulaRef)) fNode.attributes.ref = this._formulaRef;\n            if (!_.isNil(this._sharedFormulaId)) fNode.attributes.si = this._sharedFormulaId;\n            if (!_.isNil(this._formula)) fNode.children = [this._formula];\n\n            node.children.push(fNode);\n        } else if (!_.isNil(this._value)) {\n            // Add the value. Don't emit value if a formula is set as Excel will show this stale value.\n            let type, text;\n            if (typeof this._value === \"string\") {\n                type = \"s\";\n                text = this.workbook().sharedStrings().getIndexForString(this._value);\n            } else if (typeof this._value === \"boolean\") {\n                type = \"b\";\n                text = this._value ? 1 : 0;\n            } else if (typeof this._value === \"number\") {\n                text = this._value;\n            } else if (this._value instanceof Date) {\n                text = dateConverter.dateToNumber(this._value);\n            } else if (this._value instanceof RichText || typeof this._value === \"object\" && this._value.constructor.name === \"RichText\") { // Hack to make Jasmine test work\n                type = \"s\";\n                text = this.workbook().sharedStrings().getIndexForString(this._value.toXml());\n            }\n\n            if (type) node.attributes.t = type;\n            const vNode = { name: 'v', children: [text] };\n            node.children.push(vNode);\n        }\n\n        // If the style is set, set the style ID.\n        if (!_.isNil(this._style)) {\n            node.attributes.s = this._style.id();\n        } else if (!_.isNil(this._styleId)) {\n            node.attributes.s = this._styleId;\n        }\n\n        // Add any remaining children that we don't currently handle.\n        if (this._remainingChildren) {\n            node.children = node.children.concat(this._remainingChildren);\n        }\n\n        return node;\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Initialize the cell node.\n     * @param {{}|number} nodeOrColumnNumber - The existing node or the column number of a new cell.\n     * @param {number} [styleId] - The style ID for the new cell.\n     * @returns {undefined}\n     * @private\n     */\n    _init(nodeOrColumnNumber, styleId) {\n        if (_.isObject(nodeOrColumnNumber)) {\n            // Parse the existing node.\n            this._parseNode(nodeOrColumnNumber);\n        } else {\n            // This is a new cell.\n            this._columnNumber = nodeOrColumnNumber;\n            if (!_.isNil(styleId)) this._styleId = styleId;\n        }\n    }\n\n    /**\n     * Parse the existing node.\n     * @param {{}} node - The existing node.\n     * @returns {undefined}\n     * @private\n     */\n    _parseNode(node) {\n        // Parse the column numbr out of the address.\n        const ref = addressConverter.fromAddress(node.attributes.r);\n        this._columnNumber = ref.columnNumber;\n\n        // Store the style ID if present.\n        if (!_.isNil(node.attributes.s)) this._styleId = node.attributes.s;\n\n        // Parse the formula if present..\n        const fNode = xmlq.findChild(node, 'f');\n        if (fNode) {\n            this._formulaType = fNode.attributes.t || \"normal\";\n            this._formulaRef = fNode.attributes.ref;\n            this._formula = fNode.children[0];\n\n            this._sharedFormulaId = fNode.attributes.si;\n            if (!_.isNil(this._sharedFormulaId)) {\n                // Update the sheet's max shared formula ID so we can set future IDs an index beyond this.\n                this.sheet().updateMaxSharedFormulaId(this._sharedFormulaId);\n            }\n\n            // Delete the known attributes.\n            delete fNode.attributes.t;\n            delete fNode.attributes.ref;\n            delete fNode.attributes.si;\n\n            // If any unknown attributes are still present, store them for later output.\n            if (!_.isEmpty(fNode.attributes)) this._remainingFormulaAttributes = fNode.attributes;\n        }\n\n        // Parse the value.\n        const type = node.attributes.t;\n        if (type === \"s\") {\n            // String value.\n            const vNode = xmlq.findChild(node, 'v');\n            if (vNode) {\n                const sharedIndex = vNode.children[0];\n                this._value = this.workbook().sharedStrings().getStringByIndex(sharedIndex);\n\n                // rich text\n                if (_.isArray(this._value)) {\n                    this._value = new RichText(this._value);\n                }\n            } else {\n                this._value = '';\n            }\n        } else if (type === \"str\") {\n            // Simple string value.\n            const vNode = xmlq.findChild(node, 'v');\n            this._value = vNode && vNode.children[0];\n        } else if (type === \"inlineStr\") {\n            // Inline string value: can be simple text or rich text.\n            const isNode = xmlq.findChild(node, 'is');\n            if (isNode.children[0].name === \"t\") {\n                const tNode = isNode.children[0];\n                this._value = tNode.children[0];\n            } else {\n                this._value = isNode.children;\n            }\n        } else if (type === \"b\") {\n            // Boolean value.\n            this._value = xmlq.findChild(node, 'v').children[0] === 1;\n        } else if (type === \"e\") {\n            // Error value.\n            const error = xmlq.findChild(node, 'v').children[0];\n            this._value = FormulaError.getError(error);\n        } else {\n            // Number value.\n            const vNode = xmlq.findChild(node, 'v');\n            this._value = vNode && Number(vNode.children[0]);\n        }\n\n        // Delete known attributes.\n        delete node.attributes.r;\n        delete node.attributes.s;\n        delete node.attributes.t;\n\n        // If any unknown attributes are still present, store them for later output.\n        if (!_.isEmpty(node.attributes)) this._remainingAttributes = node.attributes;\n\n        // Delete known children.\n        xmlq.removeChild(node, 'f');\n        xmlq.removeChild(node, 'v');\n        xmlq.removeChild(node, 'is');\n\n        // If any unknown children are still present, store them for later output.\n        if (!_.isEmpty(node.children)) this._remainingChildren = node.children;\n    }\n}\n\nmodule.exports = Cell;\n\n/*\n<c r=\"A6\" s=\"1\" t=\"s\">\n    <v>2</v>\n</c>\n*/\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}