{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _ = require(\"lodash\");\nvar Cell = require(\"./Cell\");\nvar Row = require(\"./Row\");\nvar Column = require(\"./Column\");\nvar Range = require(\"./Range\");\nvar Relationships = require(\"./Relationships\");\nvar xmlq = require(\"./xmlq\");\nvar regexify = require(\"./regexify\");\nvar addressConverter = require(\"./addressConverter\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar colorIndexes = require(\"./colorIndexes\");\nvar PageBreaks = require(\"./PageBreaks\");\n\n// Order of the nodes as defined by the spec.\nvar nodeOrder = [\"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\", \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\", \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\", \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\", \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\", \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\", \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\", \"extLst\"];\n\n/**\n * A worksheet.\n */\nvar Sheet = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of Sheet.\n  //  * @param {Workbook} workbook - The parent workbook.\n  //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n  //  * @param {{}} node - The sheet node.\n  //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n  //  */\n  function Sheet(workbook, idNode, node, relationshipsNode) {\n    _classCallCheck(this, Sheet);\n    this._init(workbook, idNode, node, relationshipsNode);\n  }\n\n  /* PUBLIC */\n\n  /**\n   * Gets a value indicating whether the sheet is the active sheet in the workbook.\n   * @returns {boolean} True if active, false otherwise.\n   */ /**\n      * Make the sheet the active sheet in the workkbok.\n      * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n      * @returns {Sheet} The sheet.\n      */\n  _createClass(Sheet, [{\n    key: \"active\",\n    value: function active() {\n      var _this = this;\n      return new ArgHandler('Sheet.active').case(function () {\n        return _this.workbook().activeSheet() === _this;\n      }).case('boolean', function (active) {\n        if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n        _this.workbook().activeSheet(_this);\n        return _this;\n      }).handle(arguments);\n    }\n\n    /**\n     * Get the active cell in the sheet.\n     * @returns {Cell} The active cell.\n     */ /**\n        * Set the active cell in the workbook.\n        * @param {string|Cell} cell - The cell or address of cell to activate.\n        * @returns {Sheet} The sheet.\n        */ /**\n           * Set the active cell in the workbook by row and column.\n           * @param {number} rowNumber - The row number of the cell.\n           * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n           * @returns {Sheet} The sheet.\n           */\n  }, {\n    key: \"activeCell\",\n    value: function activeCell() {\n      var _this2 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      var selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n      return new ArgHandler('Sheet.activeCell').case(function () {\n        var cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n        return _this2.cell(cellAddress);\n      }).case(['number', '*'], function (rowNumber, columnNameOrNumber) {\n        var cell = _this2.cell(rowNumber, columnNameOrNumber);\n        return _this2.activeCell(cell);\n      }).case('*', function (cell) {\n        if (!selectionNode) {\n          selectionNode = {\n            name: \"selection\",\n            attributes: {},\n            children: []\n          };\n          xmlq.appendChild(sheetViewNode, selectionNode);\n        }\n        if (!(cell instanceof Cell)) cell = _this2.cell(cell);\n        selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n        return _this2;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets the cell with the given address.\n     * @param {string} address - The address of the cell.\n     * @returns {Cell} The cell.\n     */ /**\n        * Gets the cell with the given row and column numbers.\n        * @param {number} rowNumber - The row number of the cell.\n        * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n        * @returns {Cell} The cell.\n        */\n  }, {\n    key: \"cell\",\n    value: function cell() {\n      var _this3 = this;\n      return new ArgHandler('Sheet.cell').case('string', function (address) {\n        var ref = addressConverter.fromAddress(address);\n        if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n        return _this3.row(ref.rowNumber).cell(ref.columnNumber);\n      }).case(['number', '*'], function (rowNumber, columnNameOrNumber) {\n        return _this3.row(rowNumber).cell(columnNameOrNumber);\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets a column in the sheet.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Column} The column.\n     */\n  }, {\n    key: \"column\",\n    value: function column(columnNameOrNumber) {\n      var columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;\n\n      // If we're already created a column for this column number, return it.\n      if (this._columns[columnNumber]) return this._columns[columnNumber];\n\n      // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n      // First, see if there is an existing col node.\n      var existingColNode = this._colNodes[columnNumber];\n      var colNode;\n      if (existingColNode) {\n        // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n        if (existingColNode.attributes.min < columnNumber) {\n          // Clone the node and set the max to the column before our new col.\n          var beforeColNode = _.cloneDeep(existingColNode);\n          beforeColNode.attributes.max = columnNumber - 1;\n\n          // Update the col nodes cache.\n          for (var i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n            this._colNodes[i] = beforeColNode;\n          }\n        }\n\n        // Make a clone for the new column. Set the min/max to the column number and cache it.\n        colNode = _.cloneDeep(existingColNode);\n        colNode.attributes.min = columnNumber;\n        colNode.attributes.max = columnNumber;\n        this._colNodes[columnNumber] = colNode;\n\n        // If the max of the existing node is greater than the nre one, create a col node for that too.\n        if (existingColNode.attributes.max > columnNumber) {\n          var afterColNode = _.cloneDeep(existingColNode);\n          afterColNode.attributes.min = columnNumber + 1;\n          for (var _i = afterColNode.attributes.min; _i <= afterColNode.attributes.max; _i++) {\n            this._colNodes[_i] = afterColNode;\n          }\n        }\n      } else {\n        // The was no existing node so create a new one.\n        colNode = {\n          name: 'col',\n          attributes: {\n            min: columnNumber,\n            max: columnNumber\n          },\n          children: []\n        };\n        this._colNodes[columnNumber] = colNode;\n      }\n\n      // Create the new column and cache it.\n      var column = new Column(this, colNode);\n      this._columns[columnNumber] = column;\n      return column;\n    }\n\n    /**\n     * Gets a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     */ /**\n        * Set a defined name scoped to the sheet.\n        * @param {string} name - The defined name.\n        * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n        * @returns {Workbook} The workbook.\n        */\n  }, {\n    key: \"definedName\",\n    value: function definedName() {\n      var _this4 = this;\n      return new ArgHandler(\"Workbook.definedName\").case('string', function (name) {\n        return _this4.workbook().scopedDefinedName(_this4, name);\n      }).case(['string', '*'], function (name, refersTo) {\n        _this4.workbook().scopedDefinedName(_this4, name, refersTo);\n        return _this4;\n      }).handle(arguments);\n    }\n\n    /**\n     * Deletes the sheet and returns the parent workbook.\n     * @returns {Workbook} The workbook.\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      this.workbook().deleteSheet(this);\n      return this.workbook();\n    }\n\n    /**\n     * Find the given pattern in the sheet and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {Array.<Cell>} The matching cells.\n     */\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n      this._rows.forEach(function (row) {\n        if (!row) return;\n        matches = matches.concat(row.find(pattern, replacement));\n      });\n      return matches;\n    }\n\n    /**\n     * Gets a value indicating whether this sheet's grid lines are visible.\n     * @returns {boolean} True if selected, false if not.\n     */ /**\n        * Sets whether this sheet's grid lines are visible.\n        * @param {boolean} selected - True to make visible, false to hide.\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"gridLinesVisible\",\n    value: function gridLinesVisible() {\n      var _this5 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      return new ArgHandler('Sheet.gridLinesVisible').case(function () {\n        return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n      }).case('boolean', function (visible) {\n        sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n        return _this5;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating if the sheet is hidden or not.\n     * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n     */ /**\n        * Set whether the sheet is hidden or not.\n        * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"hidden\",\n    value: function hidden() {\n      var _this6 = this;\n      return new ArgHandler('Sheet.hidden').case(function () {\n        if (_this6._idNode.attributes.state === 'hidden') return true;\n        if (_this6._idNode.attributes.state === 'veryHidden') return \"very\";\n        return false;\n      }).case('*', function (hidden) {\n        if (hidden) {\n          var visibleSheets = _.filter(_this6.workbook().sheets(), function (sheet) {\n            return !sheet.hidden();\n          });\n          if (visibleSheets.length === 1 && visibleSheets[0] === _this6) {\n            throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n          }\n\n          // If activate, activate the first other visible sheet.\n          if (_this6.active()) {\n            var activeIndex = visibleSheets[0] === _this6 ? 1 : 0;\n            visibleSheets[activeIndex].active(true);\n          }\n        }\n        if (hidden === 'very') _this6._idNode.attributes.state = 'veryHidden';else if (hidden) _this6._idNode.attributes.state = 'hidden';else delete _this6._idNode.attributes.state;\n        return _this6;\n      }).handle(arguments);\n    }\n\n    /**\n     * Move the sheet.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The sheet.\n     */\n  }, {\n    key: \"move\",\n    value: function move(indexOrBeforeSheet) {\n      this.workbook().moveSheet(this, indexOrBeforeSheet);\n      return this;\n    }\n\n    /**\n     * Get the name of the sheet.\n     * @returns {string} The sheet name.\n     */ /**\n        * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n        * @param {string} name - The name to set to the sheet.\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"name\",\n    value: function name() {\n      var _this7 = this;\n      return new ArgHandler('Sheet.name').case(function () {\n        return \"\".concat(_this7._idNode.attributes.name);\n      }).case('string', function (name) {\n        _this7._idNode.attributes.name = name;\n        return _this7;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets a range from the given range address.\n     * @param {string} address - The range address (e.g. 'A1:B3').\n     * @returns {Range} The range.\n     */ /**\n        * Gets a range from the given cells or cell addresses.\n        * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n        * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n        * @returns {Range} The range.\n        */ /**\n           * Gets a range from the given row numbers and column names or numbers.\n           * @param {number} startRowNumber - The starting cell row number.\n           * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n           * @param {number} endRowNumber - The ending cell row number.\n           * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n           * @returns {Range} The range.\n           */\n  }, {\n    key: \"range\",\n    value: function range() {\n      var _this8 = this;\n      return new ArgHandler('Sheet.range').case('string', function (address) {\n        var ref = addressConverter.fromAddress(address);\n        if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n        return _this8.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n      }).case(['*', '*'], function (startCell, endCell) {\n        if (typeof startCell === \"string\") startCell = _this8.cell(startCell);\n        if (typeof endCell === \"string\") endCell = _this8.cell(endCell);\n        return new Range(startCell, endCell);\n      }).case(['number', '*', 'number', '*'], function (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) {\n        return _this8.range(_this8.cell(startRowNumber, startColumnNameOrNumber), _this8.cell(endRowNumber, endColumnNameOrNumber));\n      }).handle(arguments);\n    }\n\n    /**\n     * Unsets sheet autoFilter.\n     * @returns {Sheet} This sheet.\n     */ /**\n        * Sets sheet autoFilter to a Range.\n        * @param {Range} range - The autoFilter range.\n        * @returns {Sheet} This sheet.\n        */\n  }, {\n    key: \"autoFilter\",\n    value: function autoFilter(range) {\n      this._autoFilter = range;\n      return this;\n    }\n\n    /**\n     * Gets the row with the given number.\n     * @param {number} rowNumber - The row number.\n     * @returns {Row} The row with the given number.\n     */\n  }, {\n    key: \"row\",\n    value: function row(rowNumber) {\n      if (rowNumber < 1) throw new RangeError(\"Invalid row number \".concat(rowNumber, \". Remember that spreadsheets use 1-based indexing.\"));\n      if (this._rows[rowNumber]) return this._rows[rowNumber];\n      var rowNode = {\n        name: 'row',\n        attributes: {\n          r: rowNumber\n        },\n        children: []\n      };\n      var row = new Row(this, rowNode);\n      this._rows[rowNumber] = row;\n      return row;\n    }\n\n    /**\n     * Get the tab color. (See style [Color](#color).)\n     * @returns {undefined|Color} The color or undefined if not set.\n     */ /**\n        * Sets the tab color. (See style [Color](#color).)\n        * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n        */\n  }, {\n    key: \"tabColor\",\n    value: function tabColor() {\n      var _this9 = this;\n      return new ArgHandler(\"Sheet.tabColor\").case(function () {\n        var tabColorNode = xmlq.findChild(_this9._sheetPrNode, \"tabColor\");\n        if (!tabColorNode) return;\n        var color = {};\n        if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n        if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n        return color;\n      }).case(\"string\", function (rgb) {\n        return _this9.tabColor({\n          rgb: rgb\n        });\n      }).case(\"integer\", function (theme) {\n        return _this9.tabColor({\n          theme: theme\n        });\n      }).case(\"nil\", function () {\n        xmlq.removeChild(_this9._sheetPrNode, \"tabColor\");\n        return _this9;\n      }).case(\"object\", function (color) {\n        var tabColorNode = xmlq.appendChildIfNotFound(_this9._sheetPrNode, \"tabColor\");\n        xmlq.setAttributes(tabColorNode, {\n          rgb: color.rgb && color.rgb.toUpperCase(),\n          indexed: null,\n          theme: color.theme,\n          tint: color.tint\n        });\n        return _this9;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is selected.\n     * @returns {boolean} True if selected, false if not.\n     */ /**\n        * Sets whether this sheet is selected.\n        * @param {boolean} selected - True to select, false to deselected.\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"tabSelected\",\n    value: function tabSelected() {\n      var _this10 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      return new ArgHandler('Sheet.tabSelected').case(function () {\n        return sheetViewNode.attributes.tabSelected === 1;\n      }).case('boolean', function (selected) {\n        if (selected) sheetViewNode.attributes.tabSelected = 1;else delete sheetViewNode.attributes.tabSelected;\n        return _this10;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is rtl (Right To Left).\n     * @returns {boolean} True if rtl, false if ltr.\n     */ /**\n        * Sets whether this sheet is rtl.\n        * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"rightToLeft\",\n    value: function rightToLeft() {\n      var _this11 = this;\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      return new ArgHandler('Sheet.rightToLeft').case(function () {\n        return sheetViewNode.attributes.rightToLeft;\n      }).case('boolean', function (rtl) {\n        if (rtl) sheetViewNode.attributes.rightToLeft = true;else delete sheetViewNode.attributes.rightToLeft;\n        return _this11;\n      }).handle(arguments);\n    }\n\n    /**\n     * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n     * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n     */\n  }, {\n    key: \"usedRange\",\n    value: function usedRange() {\n      var minRowNumber = _.findIndex(this._rows);\n      var maxRowNumber = this._rows.length - 1;\n      var minColumnNumber = 0;\n      var maxColumnNumber = 0;\n      for (var i = 0; i < this._rows.length; i++) {\n        var row = this._rows[i];\n        if (!row) continue;\n        var minUsedColumnNumber = row.minUsedColumnNumber();\n        var maxUsedColumnNumber = row.maxUsedColumnNumber();\n        if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n        if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n      }\n\n      // Return undefined if nothing in the sheet is used.\n      if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n      return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this._workbook;\n    }\n\n    /**\n     * Gets all page breaks.\n     * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n     */\n  }, {\n    key: \"pageBreaks\",\n    value: function pageBreaks() {\n      return this._pageBreaks;\n    }\n\n    /**\n     * Gets the vertical page breaks.\n     * @returns {PageBreaks} vertical PageBreaks.\n     */\n  }, {\n    key: \"verticalPageBreaks\",\n    value: function verticalPageBreaks() {\n      return this._pageBreaks.colBreaks;\n    }\n\n    /**\n     * Gets the horizontal page breaks.\n     * @returns {PageBreaks} horizontal PageBreaks.\n     */\n  }, {\n    key: \"horizontalPageBreaks\",\n    value: function horizontalPageBreaks() {\n      return this._pageBreaks.rowBreaks;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"clearCellsUsingSharedFormula\",\n    value: function clearCellsUsingSharedFormula(sharedFormulaId) {\n      this._rows.forEach(function (row) {\n        if (!row) return;\n        row.clearCellsUsingSharedFormula(sharedFormulaId);\n      });\n    }\n\n    /**\n     * Get an existing column style ID.\n     * @param {number} columnNumber - The column number.\n     * @returns {undefined|number} The style ID.\n     * @ignore\n     */\n  }, {\n    key: \"existingColumnStyleId\",\n    value: function existingColumnStyleId(columnNumber) {\n      // This will work after setting Column.style because Column updates the attributes live.\n      var colNode = this._colNodes[columnNumber];\n      return colNode && colNode.attributes.style;\n    }\n\n    /**\n     * Call a callback for each column number that has a node defined for it.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"forEachExistingColumnNumber\",\n    value: function forEachExistingColumnNumber(callback) {\n      _.forEach(this._colNodes, function (node, columnNumber) {\n        if (!node) return;\n        callback(columnNumber);\n      });\n    }\n\n    /**\n     * Call a callback for each existing row.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"forEachExistingRow\",\n    value: function forEachExistingRow(callback) {\n      _.forEach(this._rows, function (row, rowNumber) {\n        if (row) callback(row, rowNumber);\n      });\n      return this;\n    }\n\n    /**\n     * Get the hyperlink attached to the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     */ /**\n        * Set the hyperlink on the cell with the given address.\n        * @param {string} address - The address of the hyperlinked cell.\n        * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n        * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n        * @returns {Sheet} The sheet.\n        */ /**\n           * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n           * @param {string} address - The address of the hyperlinked cell.\n           * @param {object|Cell} opts - Options.\n           * @returns {Sheet} The sheet.\n           * @ignore\n           */ /**\n              * Set the hyperlink on the cell with the given address and options.\n              * @param {string} address - The address of the hyperlinked cell.\n              * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n              * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n              * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n              * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n              * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n              * @returns {Sheet} The sheet.\n              */\n  }, {\n    key: \"hyperlink\",\n    value: function hyperlink() {\n      var _this12 = this;\n      return new ArgHandler('Sheet.hyperlink').case('string', function (address) {\n        var hyperlinkNode = _this12._hyperlinks[address];\n        if (!hyperlinkNode) return;\n        var relationship = _this12._relationships.findById(hyperlinkNode.attributes['r:id']);\n        return relationship && relationship.attributes.Target;\n      }).case(['string', 'nil'], function (address) {\n        // TODO: delete relationship\n        delete _this12._hyperlinks[address];\n        return _this12;\n      }).case(['string', 'string'], function (address, hyperlink) {\n        return _this12.hyperlink(address, hyperlink, false);\n      }).case(['string', 'string', 'boolean'], function (address, hyperlink, internal) {\n        var isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n        var nodeAttributes;\n        if (isHyperlinkInternalAddress) {\n          nodeAttributes = {\n            ref: address,\n            location: hyperlink,\n            display: hyperlink\n          };\n        } else {\n          var relationship = _this12._relationships.add(\"hyperlink\", hyperlink, \"External\");\n          nodeAttributes = {\n            ref: address,\n            'r:id': relationship.attributes.Id\n          };\n        }\n        _this12._hyperlinks[address] = {\n          name: 'hyperlink',\n          attributes: nodeAttributes,\n          children: []\n        };\n        return _this12;\n      }).case(['string', 'object'], function (address, opts) {\n        if (opts instanceof Cell) {\n          var cell = opts;\n          var hyperlink = cell.address({\n            includeSheetName: true\n          });\n          _this12.hyperlink(address, hyperlink, true);\n        } else if (opts.hyperlink) {\n          _this12.hyperlink(address, opts.hyperlink);\n        } else if (opts.email) {\n          var email = opts.email;\n          var subject = opts.emailSubject || '';\n          _this12.hyperlink(address, encodeURI(\"mailto:\".concat(email, \"?subject=\").concat(subject)));\n        }\n        var hyperlinkNode = _this12._hyperlinks[address];\n        if (hyperlinkNode) {\n          if (opts.tooltip) {\n            hyperlinkNode.attributes.tooltip = opts.tooltip;\n          }\n        }\n        return _this12;\n      }).handle(arguments);\n    }\n\n    /**\n     * Increment and return the max shared formula ID.\n     * @returns {number} The new max shared formula ID.\n     * @ignore\n     */\n  }, {\n    key: \"incrementMaxSharedFormulaId\",\n    value: function incrementMaxSharedFormulaId() {\n      return ++this._maxSharedFormulaId;\n    }\n\n    /**\n     * Get a value indicating whether the cells in the given address are merged.\n     * @param {string} address - The address to check.\n     * @returns {boolean} True if merged, false if not merged.\n     * @ignore\n     */ /**\n        * Merge/unmerge cells by adding/removing a mergeCell entry.\n        * @param {string} address - The address to merge.\n        * @param {boolean} merged - True to merge, false to unmerge.\n        * @returns {Sheet} The sheet.\n        * @ignore\n        */\n  }, {\n    key: \"merged\",\n    value: function merged() {\n      var _this13 = this;\n      return new ArgHandler('Sheet.merge').case('string', function (address) {\n        return _this13._mergeCells.hasOwnProperty(address);\n      }).case(['string', '*'], function (address, merge) {\n        if (merge) {\n          _this13._mergeCells[address] = {\n            name: 'mergeCell',\n            attributes: {\n              ref: address\n            },\n            children: []\n          };\n        } else {\n          delete _this13._mergeCells[address];\n        }\n        return _this13;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets a Object or undefined of the cells in the given address.\n     * @param {string} address - The address to check.\n     * @returns {object|boolean} Object or false if not set\n     * @ignore\n     */ /**\n        * Removes dataValidation at the given address\n        * @param {string} address - The address to remove.\n        * @param {boolean} obj - false to delete.\n        * @returns {boolean} true if removed.\n        * @ignore\n        */ /**\n           * Add dataValidation to cells at the given address if object or string\n           * @param {string} address - The address to set.\n           * @param {object|string} obj - Object or String to set\n           * @returns {Sheet} The sheet.\n           * @ignore\n           */\n  }, {\n    key: \"dataValidation\",\n    value: function dataValidation() {\n      var _this14 = this;\n      return new ArgHandler('Sheet.dataValidation').case('string', function (address) {\n        if (_this14._dataValidations[address]) {\n          return {\n            type: _this14._dataValidations[address].attributes.type,\n            allowBlank: _this14._dataValidations[address].attributes.allowBlank,\n            showInputMessage: _this14._dataValidations[address].attributes.showInputMessage,\n            prompt: _this14._dataValidations[address].attributes.prompt,\n            promptTitle: _this14._dataValidations[address].attributes.promptTitle,\n            showErrorMessage: _this14._dataValidations[address].attributes.showErrorMessage,\n            error: _this14._dataValidations[address].attributes.error,\n            errorTitle: _this14._dataValidations[address].attributes.errorTitle,\n            operator: _this14._dataValidations[address].attributes.operator,\n            formula1: _this14._dataValidations[address].children[0].children[0],\n            formula2: _this14._dataValidations[address].children[1] ? _this14._dataValidations[address].children[1].children[0] : undefined\n          };\n        } else {\n          return false;\n        }\n      }).case(['string', 'boolean'], function (address, obj) {\n        if (_this14._dataValidations[address]) {\n          if (obj === false) return delete _this14._dataValidations[address];\n        } else {\n          return false;\n        }\n      }).case(['string', '*'], function (address, obj) {\n        if (typeof obj === 'string') {\n          _this14._dataValidations[address] = {\n            name: 'dataValidation',\n            attributes: {\n              type: 'list',\n              allowBlank: false,\n              showInputMessage: false,\n              prompt: '',\n              promptTitle: '',\n              showErrorMessage: false,\n              error: '',\n              errorTitle: '',\n              operator: '',\n              sqref: address\n            },\n            children: [{\n              name: 'formula1',\n              atrributes: {},\n              children: [obj]\n            }, {\n              name: 'formula2',\n              atrributes: {},\n              children: ['']\n            }]\n          };\n        } else if (typeof obj === 'object') {\n          _this14._dataValidations[address] = {\n            name: 'dataValidation',\n            attributes: {\n              type: obj.type ? obj.type : 'list',\n              allowBlank: obj.allowBlank,\n              showInputMessage: obj.showInputMessage,\n              prompt: obj.prompt,\n              promptTitle: obj.promptTitle,\n              showErrorMessage: obj.showErrorMessage,\n              error: obj.error,\n              errorTitle: obj.errorTitle,\n              operator: obj.operator,\n              sqref: address\n            },\n            children: [{\n              name: 'formula1',\n              atrributes: {},\n              children: [obj.formula1]\n            }, {\n              name: 'formula2',\n              atrributes: {},\n              children: [obj.formula2]\n            }]\n          };\n        }\n        return _this14;\n      }).handle(arguments);\n    }\n\n    /**\n     * Convert the sheet to a collection of XML objects.\n     * @returns {{}} The XML forms.\n     * @ignore\n     */\n  }, {\n    key: \"toXmls\",\n    value: function toXmls() {\n      var _this15 = this;\n      // Shallow clone the node so we don't have to remove these children later if they don't belong.\n      var node = _.clone(this._node);\n      node.children = node.children.slice();\n\n      // Add the columns if needed.\n      this._colsNode.children = _.filter(this._colNodes, function (colNode, i) {\n        // Columns should only be present if they have attributes other than min/max.\n        return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n      });\n      if (this._colsNode.children.length) {\n        xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n      }\n\n      // Add the hyperlinks if needed.\n      this._hyperlinksNode.children = _.values(this._hyperlinks);\n      if (this._hyperlinksNode.children.length) {\n        xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n      }\n\n      // Add the printOptions if needed.\n      if (this._printOptionsNode) {\n        if (Object.keys(this._printOptionsNode.attributes).length) {\n          xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n        }\n      }\n\n      // Add the pageMargins if needed.\n      if (this._pageMarginsNode && this._pageMarginsPresetName) {\n        // Clone to preserve the current state of this sheet.\n        var childNode = _.clone(this._pageMarginsNode);\n        if (Object.keys(this._pageMarginsNode.attributes).length) {\n          // Fill in any missing attribute values with presets.\n          childNode.attributes = _.assign(this._pageMarginsPresets[this._pageMarginsPresetName], this._pageMarginsNode.attributes);\n        } else {\n          // No need to fill in, all attributes is currently empty, simply replace.\n          childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n        }\n        xmlq.insertInOrder(node, childNode, nodeOrder);\n      }\n\n      // Add the merge cells if needed.\n      this._mergeCellsNode.children = _.values(this._mergeCells);\n      if (this._mergeCellsNode.children.length) {\n        xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n      }\n\n      // Add the DataValidation cells if needed.\n      this._dataValidationsNode.children = _.values(this._dataValidations);\n      if (this._dataValidationsNode.children.length) {\n        xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n      }\n      if (this._autoFilter) {\n        xmlq.insertInOrder(node, {\n          name: \"autoFilter\",\n          children: [],\n          attributes: {\n            ref: this._autoFilter.address()\n          }\n        }, nodeOrder);\n      }\n\n      // Add the PageBreaks nodes if needed.\n      ['colBreaks', 'rowBreaks'].forEach(function (name) {\n        var breaks = _this15[\"_\".concat(name, \"Node\")];\n        if (breaks.attributes.count) {\n          xmlq.insertInOrder(node, breaks, nodeOrder);\n        }\n      });\n      return {\n        id: this._idNode,\n        sheet: node,\n        relationships: this._relationships\n      };\n    }\n\n    /**\n     * Update the max shared formula ID to the given value if greater than current.\n     * @param {number} sharedFormulaId - The new shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n  }, {\n    key: \"updateMaxSharedFormulaId\",\n    value: function updateMaxSharedFormulaId(sharedFormulaId) {\n      if (sharedFormulaId > this._maxSharedFormulaId) {\n        this._maxSharedFormulaId = sharedFormulaId;\n      }\n    }\n\n    /**\n     * Get the print option given a valid print option attribute.\n     * @param {string} attributeName - Attribute name of the printOptions.\n     *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   headings - Print row and column headings.\n     *   horizontalCentered - Center on page horizontally when printing.\n     *   verticalCentered - Center on page vertically when printing.\n     * @returns {boolean}\n     */ /**\n        * Set the print option given a valid print option attribute and a value.\n        * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n        * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"printOptions\",\n    value: function printOptions() {\n      var _this16 = this;\n      var supportedAttributeNames = ['gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n      var checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n      return new ArgHandler('Sheet.printOptions').case(['string'], function (attributeName) {\n        checkAttributeName(attributeName);\n        return _this16._printOptionsNode.attributes[attributeName] === 1;\n      }).case(['string', 'nil'], function (attributeName) {\n        checkAttributeName(attributeName);\n        delete _this16._printOptionsNode.attributes[attributeName];\n        return _this16;\n      }).case(['string', 'boolean'], function (attributeName, attributeEnabled) {\n        checkAttributeName(attributeName);\n        if (attributeEnabled) {\n          _this16._printOptionsNode.attributes[attributeName] = 1;\n          return _this16;\n        } else {\n          return _this16.printOptions(attributeName, undefined);\n        }\n      }).handle(arguments);\n    }\n\n    /**\n     * Get the print option for the gridLines attribute value.\n     * @returns {boolean}\n     */ /**\n        * Set the print option for the gridLines attribute value.\n        * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"printGridLines\",\n    value: function printGridLines() {\n      var _this17 = this;\n      return new ArgHandler('Sheet.gridLines').case(function () {\n        return _this17.printOptions('gridLines') && _this17.printOptions('gridLinesSet');\n      }).case(['nil'], function () {\n        _this17.printOptions('gridLines', undefined);\n        _this17.printOptions('gridLinesSet', undefined);\n        return _this17;\n      }).case(['boolean'], function (enabled) {\n        _this17.printOptions('gridLines', enabled);\n        _this17.printOptions('gridLinesSet', enabled);\n        return _this17;\n      }).handle(arguments);\n    }\n\n    /**\n     * Get the page margin given a valid attribute name.\n     * If the value is not yet defined, then it will return the current preset value.\n     * @param {string} attributeName - Attribute name of the pageMargins.\n     *     left - Left Page Margin in inches.\n     *     right - Right page margin in inches.\n     *     top - Top Page Margin in inches.\n     *     buttom - Bottom Page Margin in inches.\n     *     footer - Footer Page Margin in inches.\n     *     header - Header Page Margin in inches.\n     * @returns {number} the attribute value.\n     */ /**\n        * Set the page margin (or override the preset) given an attribute name and a value.\n        * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n        * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n        * @returns {Sheet} The sheet.\n        */\n  }, {\n    key: \"pageMargins\",\n    value: function pageMargins() {\n      var _this18 = this;\n      if (this.pageMarginsPreset() === undefined) {\n        throw new Error('Sheet.pageMargins: preset is undefined.');\n      }\n      var supportedAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n      var checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n      var checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n      return new ArgHandler('Sheet.pageMargins').case(['string'], function (attributeName) {\n        checkAttributeName(attributeName);\n        var attributeValue = _this18._pageMarginsNode.attributes[attributeName];\n        if (attributeValue !== undefined) {\n          return parseFloat(attributeValue);\n        } else if (_this18._pageMarginsPresetName) {\n          return parseFloat(_this18._pageMarginsPresets[_this18._pageMarginsPresetName][attributeName]);\n        } else {\n          return undefined;\n        }\n      }).case(['string', 'nil'], function (attributeName) {\n        checkAttributeName(attributeName);\n        delete _this18._pageMarginsNode.attributes[attributeName];\n        return _this18;\n      }).case(['string', 'number'], function (attributeName, attributeNumberValue) {\n        checkAttributeName(attributeName);\n        checkRange(attributeNumberValue);\n        _this18._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n        return _this18;\n      }).case(['string', 'string'], function (attributeName, attributeStringValue) {\n        return _this18.pageMargins(attributeName, parseFloat(attributeStringValue));\n      }).handle(arguments);\n    }\n\n    /**\n     * Page margins preset is a set of page margins associated with a name.\n     * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n     * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n     * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n     * Available presets include: normal, wide, narrow, template.\n     *\n     * Get the page margins preset name. The registered name of a predefined set of attributes.\n     * @returns {string} The preset name.\n     */ /**\n        * Set the page margins preset by name, clearing any existing/temporary attribute values.\n        * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n        * @returns {Sheet} The sheet.\n        */ /**\n           * Set a new page margins preset by name and attributes object.\n           * @param {string} presetName - The preset name.\n           * @param {object} presetAttributes - The preset attributes.\n           * @returns {Sheet} The sheet.\n           */\n  }, {\n    key: \"pageMarginsPreset\",\n    value: function pageMarginsPreset() {\n      var _this19 = this;\n      return new ArgHandler('Sheet.pageMarginsPreset').case(function () {\n        return _this19._pageMarginsPresetName;\n      }).case(['nil'], function () {\n        // Remove all preset overrides and exclude from sheet\n        _this19._pageMarginsPresetName = undefined;\n\n        // Remove all preset overrides\n        _this19._pageMarginsNode.attributes = {};\n        return _this19;\n      }).case(['string'], function (presetName) {\n        var checkPresetName = _this19._getCheckAttributeNameHelper('pageMarginsPreset', Object.keys(_this19._pageMarginsPresets));\n        checkPresetName(presetName);\n\n        // Change to new preset\n        _this19._pageMarginsPresetName = presetName;\n\n        // Remove all preset overrides\n        _this19._pageMarginsNode.attributes = {};\n        return _this19;\n      }).case(['string', 'object'], function (presetName, presetAttributes) {\n        if (_this19._pageMarginsPresets.hasOwnProperty(presetName)) {\n          throw new Error(\"Sheet.pageMarginsPreset: The preset \".concat(presetName, \" already exists!\"));\n        }\n\n        // Validate preset attribute keys.\n        var pageMarginsAttributeNames = ['left', 'right', 'top', 'bottom', 'header', 'footer'];\n        var isValidPresetAttributeKeys = _.isEqual(_.sortBy(pageMarginsAttributeNames), _.sortBy(Object.keys(presetAttributes)));\n        if (isValidPresetAttributeKeys === false) {\n          throw new Error(\"Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \\\"\".concat(Object.keys(presetAttributes), \"\\\"\"));\n        }\n\n        // Validate preset attribute values.\n        _.forEach(function (attributeValue, attributeName) {\n          var attributeNumberValue = parseFloat(attributeValue);\n          if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n            throw new Error(\"Sheet.pageMarginsPreset: Invalid preset attribute value! - \\\"\".concat(attributeValue, \"\\\"\"));\n          }\n        });\n\n        // Change to new preset\n        _this19._pageMarginsPresetName = presetName;\n\n        // Remove all preset overrides\n        _this19._pageMarginsNode.attributes = {};\n\n        // Register the preset\n        _this19._pageMarginsPresets[presetName] = presetAttributes;\n        return _this19;\n      }).handle(arguments);\n    }\n\n    /**\n     * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n     * @typedef {Object} PaneOptions\n     * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n     * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n     * and whether those splits are frozen.\n     * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n     * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n     * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n     * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n     */ /**\n        * Gets sheet view pane options\n        * @return {PaneOptions} sheet view pane options\n        */ /**\n           * Sets sheet view pane options\n           * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n           * @return {Sheet} The sheet\n           */\n  }, {\n    key: \"panes\",\n    value: function panes() {\n      var _this20 = this;\n      var supportedStates = ['split', 'frozen', 'frozenSplit'];\n      var supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n      var checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n      var checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n      var sheetViewNode = this._getOrCreateSheetViewNode();\n      var paneNode = xmlq.findChild(sheetViewNode, 'pane');\n      return new ArgHandler('Sheet.pane').case(function () {\n        if (paneNode) {\n          var result = _.cloneDeep(paneNode.attributes);\n          if (!result.state) result.state = 'split';\n          return result;\n        }\n      }).case(['nil'], function () {\n        xmlq.removeChild(sheetViewNode, 'pane');\n        return _this20;\n      }).case(['object'], function (paneAttributes) {\n        var attributes = _.assign({\n          activePane: 'bottomRight'\n        }, paneAttributes);\n        checkStateName(attributes.state);\n        checkActivePane(attributes.activePane);\n        if (paneNode) {\n          paneNode.attributes = attributes;\n        } else {\n          paneNode = {\n            name: \"pane\",\n            attributes: attributes,\n            children: []\n          };\n          xmlq.appendChild(sheetViewNode, paneNode);\n        }\n        return _this20;\n      }).handle(arguments);\n    }\n\n    /**\n     * Freezes Panes for this sheet.\n     * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n     * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */ /**\n        * freezes Panes for this sheet.\n        * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n        * right pane (when in Left-To-Right mode).\n        * @return {Sheet} The sheet\n        */\n  }, {\n    key: \"freezePanes\",\n    value: function freezePanes() {\n      var _this21 = this;\n      return new ArgHandler('Sheet.feezePanes').case(['integer', 'integer'], function (xSplit, ySplit) {\n        var topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n        var activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n        activePane = ySplit === 0 ? 'topRight' : activePane;\n        return _this21.panes({\n          state: 'frozen',\n          topLeftCell: topLeftCell,\n          xSplit: xSplit,\n          ySplit: ySplit,\n          activePane: activePane\n        });\n      }).case(['string'], function (topLeftCell) {\n        var ref = addressConverter.fromAddress(topLeftCell);\n        var xSplit = ref.columnNumber - 1,\n          ySplit = ref.rowNumber - 1;\n        var activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n        activePane = ySplit === 0 ? 'topRight' : activePane;\n        return _this21.panes({\n          state: 'frozen',\n          topLeftCell: topLeftCell,\n          xSplit: xSplit,\n          ySplit: ySplit,\n          activePane: activePane\n        });\n      }).handle(arguments);\n    }\n\n    /**\n     * Splits Panes for this sheet.\n     * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n  }, {\n    key: \"splitPanes\",\n    value: function splitPanes(xSplit, ySplit) {\n      return this.panes({\n        state: 'split',\n        xSplit: xSplit,\n        ySplit: ySplit\n      });\n    }\n\n    /**\n     * resets to default sheet view panes.\n     * @return {Sheet} The sheet\n     */\n  }, {\n    key: \"resetPanes\",\n    value: function resetPanes() {\n      return this.panes(null);\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Get a helper function to check that the attribute name provided is supported.\n     * @param {string} functionName - Name of the parent function.\n     * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n     * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n     * @ignore\n     */\n  }, {\n    key: \"_getCheckAttributeNameHelper\",\n    value: function _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n      return function (attributeName) {\n        if (!_.includes(supportedAttributeNames, attributeName)) {\n          throw new Error(\"Sheet.\".concat(functionName, \": \\\"\").concat(attributeName, \"\\\" is not supported.\"));\n        }\n      };\n    }\n\n    /**\n     * Get a helper function to check that the value is of the expected type.\n     * @param {string} functionName - Name of the parent function.\n     * @param {string} valueType - A string produced by typeof.\n     * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n     * @ignore\n     */\n  }, {\n    key: \"_getCheckTypeHelper\",\n    value: function _getCheckTypeHelper(functionName, valueType) {\n      return function (value) {\n        if (typeof value !== valueType) {\n          throw new TypeError(\"Sheet.\".concat(functionName, \": invalid type - value must be of type \").concat(valueType, \".\"));\n        }\n      };\n    }\n\n    /**\n     * Get a helper function to check that the value is within the expected range.\n     * @param {string} functionName - Name of the parent function.\n     * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n     * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n     * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n     * @ignore\n     */\n  }, {\n    key: \"_getCheckRangeHelper\",\n    value: function _getCheckRangeHelper(functionName, valueMin, valueMax) {\n      var checkType = this._getCheckTypeHelper(functionName, 'number');\n      return function (value) {\n        checkType(value);\n        if (valueMin !== undefined) {\n          if (value < valueMin) {\n            throw new RangeError(\"Sheet.\".concat(functionName, \": value too small - value must be greater than or equal to \").concat(valueMin, \".\"));\n          }\n        }\n        if (valueMax !== undefined) {\n          if (valueMax <= value) {\n            throw new RangeError(\"Sheet.\".concat(functionName, \": value too large - value must be less than \").concat(valueMax, \".\"));\n          }\n        }\n      };\n    }\n\n    /**\n     * Get the sheet view node if it exists or create it if it doesn't.\n     * @returns {{}} The sheet view node.\n     * @private\n     */\n  }, {\n    key: \"_getOrCreateSheetViewNode\",\n    value: function _getOrCreateSheetViewNode() {\n      var sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n      if (!sheetViewsNode) {\n        sheetViewsNode = {\n          name: \"sheetViews\",\n          attributes: {},\n          children: [{\n            name: \"sheetView\",\n            attributes: {\n              workbookViewId: 0\n            },\n            children: []\n          }]\n        };\n        xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n      }\n      return xmlq.findChild(sheetViewsNode, \"sheetView\");\n    }\n\n    /**\n     * Initializes the sheet.\n     * @param {Workbook} workbook - The parent workbook.\n     * @param {{}} idNode - The sheet ID node (from the parent workbook).\n     * @param {{}} node - The sheet node.\n     * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_init\",\n    value: function _init(workbook, idNode, node, relationshipsNode) {\n      var _this22 = this;\n      if (!node) {\n        node = {\n          name: \"worksheet\",\n          attributes: {\n            xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n            'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n            'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n            'mc:Ignorable': \"x14ac\",\n            'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n          },\n          children: [{\n            name: \"sheetData\",\n            attributes: {},\n            children: []\n          }]\n        };\n      }\n      this._workbook = workbook;\n      this._idNode = idNode;\n      this._node = node;\n      this._maxSharedFormulaId = -1;\n      this._mergeCells = {};\n      this._dataValidations = {};\n      this._hyperlinks = {};\n      this._autoFilter = null;\n\n      // Create the relationships.\n      this._relationships = new Relationships(relationshipsNode);\n\n      // Delete the optional dimension node\n      xmlq.removeChild(this._node, \"dimension\");\n\n      // Create the rows.\n      this._rows = [];\n      this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n      this._sheetDataNode.children.forEach(function (rowNode) {\n        var row = new Row(_this22, rowNode);\n        _this22._rows[row.rowNumber()] = row;\n      });\n      this._sheetDataNode.children = this._rows;\n\n      // Create the columns node.\n      this._columns = [];\n      this._colsNode = xmlq.findChild(this._node, \"cols\");\n      if (this._colsNode) {\n        xmlq.removeChild(this._node, this._colsNode);\n      } else {\n        this._colsNode = {\n          name: 'cols',\n          attributes: {},\n          children: []\n        };\n      }\n\n      // Cache the col nodes.\n      this._colNodes = [];\n      _.forEach(this._colsNode.children, function (colNode) {\n        var min = colNode.attributes.min;\n        var max = colNode.attributes.max;\n        for (var i = min; i <= max; i++) {\n          _this22._colNodes[i] = colNode;\n        }\n      });\n\n      // Create the sheet properties node.\n      this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n      if (!this._sheetPrNode) {\n        this._sheetPrNode = {\n          name: 'sheetPr',\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n      }\n\n      // Create the merge cells.\n      this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n      if (this._mergeCellsNode) {\n        xmlq.removeChild(this._node, this._mergeCellsNode);\n      } else {\n        this._mergeCellsNode = {\n          name: 'mergeCells',\n          attributes: {},\n          children: []\n        };\n      }\n      var mergeCellNodes = this._mergeCellsNode.children;\n      this._mergeCellsNode.children = [];\n      mergeCellNodes.forEach(function (mergeCellNode) {\n        _this22._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n      });\n\n      // Create the DataValidations.\n      this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n      if (this._dataValidationsNode) {\n        xmlq.removeChild(this._node, this._dataValidationsNode);\n      } else {\n        this._dataValidationsNode = {\n          name: 'dataValidations',\n          attributes: {},\n          children: []\n        };\n      }\n      var dataValidationNodes = this._dataValidationsNode.children;\n      this._dataValidationsNode.children = [];\n      dataValidationNodes.forEach(function (dataValidationNode) {\n        _this22._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n      });\n\n      // Create the hyperlinks.\n      this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n      if (this._hyperlinksNode) {\n        xmlq.removeChild(this._node, this._hyperlinksNode);\n      } else {\n        this._hyperlinksNode = {\n          name: 'hyperlinks',\n          attributes: {},\n          children: []\n        };\n      }\n      var hyperlinkNodes = this._hyperlinksNode.children;\n      this._hyperlinksNode.children = [];\n      hyperlinkNodes.forEach(function (hyperlinkNode) {\n        _this22._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n      });\n\n      // Create the printOptions.\n      this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n      if (this._printOptionsNode) {\n        xmlq.removeChild(this._node, this._printOptionsNode);\n      } else {\n        this._printOptionsNode = {\n          name: 'printOptions',\n          attributes: {},\n          children: []\n        };\n      }\n\n      // Create the pageMargins.\n      this._pageMarginsPresets = {\n        normal: {\n          left: 0.7,\n          right: 0.7,\n          top: 0.75,\n          bottom: 0.75,\n          header: 0.3,\n          footer: 0.3\n        },\n        wide: {\n          left: 1,\n          right: 1,\n          top: 1,\n          bottom: 1,\n          header: 0.5,\n          footer: 0.5\n        },\n        narrow: {\n          left: 0.25,\n          right: 0.25,\n          top: 0.75,\n          bottom: 0.75,\n          header: 0.3,\n          footer: 0.3\n        }\n      };\n      this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n      if (this._pageMarginsNode) {\n        // Sheet has page margins, assume preset is template.\n        this._pageMarginsPresetName = 'template';\n\n        // Search for a preset that matches existing attributes.\n        for (var presetName in this._pageMarginsPresets) {\n          if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n            this._pageMarginsPresetName = presetName;\n            break;\n          }\n        }\n\n        // If template preset, then register as template preset, and clear attributes.\n        if (this._pageMarginsPresetName === 'template') {\n          this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n          this._pageMarginsNode.attributes = {};\n        }\n        xmlq.removeChild(this._node, this._pageMarginsNode);\n      } else {\n        // Sheet has no page margins, the preset assignment is therefore undefined.\n        this._pageMarginsPresetName = undefined;\n        this._pageMarginsNode = {\n          name: 'pageMargins',\n          attributes: {},\n          children: []\n        };\n      }\n\n      // Create the pageBreaks\n      ['colBreaks', 'rowBreaks'].forEach(function (name) {\n        _this22[\"_\".concat(name, \"Node\")] = xmlq.findChild(_this22._node, name);\n        if (_this22[\"_\".concat(name, \"Node\")]) {\n          xmlq.removeChild(_this22._node, _this22[\"_\".concat(name, \"Node\")]);\n        } else {\n          _this22[\"_\".concat(name, \"Node\")] = {\n            name: name,\n            children: [],\n            attributes: {\n              count: 0,\n              manualBreakCount: 0\n            }\n          };\n        }\n      });\n      this._pageBreaks = {\n        colBreaks: new PageBreaks(this._colBreaksNode),\n        rowBreaks: new PageBreaks(this._rowBreaksNode)\n      };\n    }\n  }]);\n  return Sheet;\n}();\nmodule.exports = Sheet;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */","map":{"version":3,"names":["_","require","Cell","Row","Column","Range","Relationships","xmlq","regexify","addressConverter","ArgHandler","colorIndexes","PageBreaks","nodeOrder","Sheet","workbook","idNode","node","relationshipsNode","_init","case","activeSheet","active","Error","handle","arguments","sheetViewNode","_getOrCreateSheetViewNode","selectionNode","findChild","cellAddress","attributes","activeCell","cell","rowNumber","columnNameOrNumber","name","children","appendChild","sqref","address","ref","fromAddress","type","row","columnNumber","columnNameToNumber","_columns","existingColNode","_colNodes","colNode","min","beforeColNode","cloneDeep","max","i","afterColNode","column","scopedDefinedName","refersTo","deleteSheet","pattern","replacement","matches","_rows","forEach","concat","find","showGridLines","undefined","visible","_idNode","state","hidden","visibleSheets","filter","sheets","sheet","length","activeIndex","indexOrBeforeSheet","moveSheet","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","startCell","endCell","startColumnNameOrNumber","endColumnNameOrNumber","_autoFilter","RangeError","rowNode","r","tabColorNode","_sheetPrNode","color","hasOwnProperty","rgb","theme","indexed","tint","tabColor","removeChild","appendChildIfNotFound","setAttributes","toUpperCase","tabSelected","selected","rightToLeft","rtl","minRowNumber","findIndex","maxRowNumber","minColumnNumber","maxColumnNumber","minUsedColumnNumber","maxUsedColumnNumber","_workbook","_pageBreaks","colBreaks","rowBreaks","sharedFormulaId","clearCellsUsingSharedFormula","style","callback","hyperlinkNode","_hyperlinks","relationship","_relationships","findById","Target","hyperlink","internal","isHyperlinkInternalAddress","nodeAttributes","location","display","add","Id","opts","includeSheetName","email","subject","emailSubject","encodeURI","tooltip","_maxSharedFormulaId","_mergeCells","merge","_dataValidations","allowBlank","showInputMessage","prompt","promptTitle","showErrorMessage","error","errorTitle","operator","formula1","formula2","obj","atrributes","clone","_node","slice","_colsNode","Object","keys","insertInOrder","_hyperlinksNode","values","_printOptionsNode","_pageMarginsNode","_pageMarginsPresetName","childNode","assign","_pageMarginsPresets","_mergeCellsNode","_dataValidationsNode","breaks","count","id","relationships","supportedAttributeNames","checkAttributeName","_getCheckAttributeNameHelper","attributeName","attributeEnabled","printOptions","enabled","pageMarginsPreset","checkRange","_getCheckRangeHelper","attributeValue","parseFloat","attributeNumberValue","attributeStringValue","pageMargins","presetName","checkPresetName","presetAttributes","pageMarginsAttributeNames","isValidPresetAttributeKeys","isEqual","sortBy","isNaN","isNumber","supportedStates","supportedActivePanes","checkStateName","checkActivePane","paneNode","result","paneAttributes","activePane","xSplit","ySplit","topLeftCell","columnNumberToName","panes","functionName","includes","valueType","value","TypeError","valueMin","valueMax","checkType","_getCheckTypeHelper","sheetViewsNode","workbookViewId","xmlns","_sheetDataNode","mergeCellNodes","mergeCellNode","dataValidationNodes","dataValidationNode","hyperlinkNodes","normal","left","right","top","bottom","header","footer","wide","narrow","template","manualBreakCount","_colBreaksNode","_rowBreaksNode","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Sheet.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Cell = require(\"./Cell\");\nconst Row = require(\"./Row\");\nconst Column = require(\"./Column\");\nconst Range = require(\"./Range\");\nconst Relationships = require(\"./Relationships\");\nconst xmlq = require(\"./xmlq\");\nconst regexify = require(\"./regexify\");\nconst addressConverter = require(\"./addressConverter\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst colorIndexes = require(\"./colorIndexes\");\nconst PageBreaks = require(\"./PageBreaks\");\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"sheetPr\", \"dimension\", \"sheetViews\", \"sheetFormatPr\", \"cols\", \"sheetData\",\n    \"sheetCalcPr\", \"sheetProtection\", \"autoFilter\", \"protectedRanges\", \"scenarios\", \"autoFilter\",\n    \"sortState\", \"dataConsolidate\", \"customSheetViews\", \"mergeCells\", \"phoneticPr\",\n    \"conditionalFormatting\", \"dataValidations\", \"hyperlinks\", \"printOptions\",\n    \"pageMargins\", \"pageSetup\", \"headerFooter\", \"rowBreaks\", \"colBreaks\",\n    \"customProperties\", \"cellWatches\", \"ignoredErrors\", \"smartTags\", \"drawing\",\n    \"drawingHF\", \"legacyDrawing\", \"legacyDrawingHF\", \"picture\", \"oleObjects\", \"controls\", \"webPublishItems\", \"tableParts\",\n    \"extLst\"\n];\n\n/**\n * A worksheet.\n */\nclass Sheet {\n    // /**\n    //  * Creates a new instance of Sheet.\n    //  * @param {Workbook} workbook - The parent workbook.\n    //  * @param {{}} idNode - The sheet ID node (from the parent workbook).\n    //  * @param {{}} node - The sheet node.\n    //  * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n    //  */\n    constructor(workbook, idNode, node, relationshipsNode) {\n        this._init(workbook, idNode, node, relationshipsNode);\n    }\n\n    /* PUBLIC */\n\n    /**\n     * Gets a value indicating whether the sheet is the active sheet in the workbook.\n     * @returns {boolean} True if active, false otherwise.\n     *//**\n     * Make the sheet the active sheet in the workkbok.\n     * @param {boolean} active - Must be set to `true`. Deactivating directly is not supported. To deactivate, you should activate a different sheet instead.\n     * @returns {Sheet} The sheet.\n     */\n    active() {\n        return new ArgHandler('Sheet.active')\n            .case(() => {\n                return this.workbook().activeSheet() === this;\n            })\n            .case('boolean', active => {\n                if (!active) throw new Error(\"Deactivating sheet directly not supported. Activate a different sheet instead.\");\n                this.workbook().activeSheet(this);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the active cell in the sheet.\n     * @returns {Cell} The active cell.\n     *//**\n     * Set the active cell in the workbook.\n     * @param {string|Cell} cell - The cell or address of cell to activate.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the active cell in the workbook by row and column.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Sheet} The sheet.\n     */\n    activeCell() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let selectionNode = xmlq.findChild(sheetViewNode, \"selection\");\n        return new ArgHandler('Sheet.activeCell')\n            .case(() => {\n                const cellAddress = selectionNode ? selectionNode.attributes.activeCell : \"A1\";\n                return this.cell(cellAddress);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                const cell = this.cell(rowNumber, columnNameOrNumber);\n                return this.activeCell(cell);\n            })\n            .case('*', cell => {\n                if (!selectionNode) {\n                    selectionNode = {\n                        name: \"selection\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.appendChild(sheetViewNode, selectionNode);\n                }\n\n                if (!(cell instanceof Cell)) cell = this.cell(cell);\n                selectionNode.attributes.activeCell = selectionNode.attributes.sqref = cell.address();\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the cell with the given address.\n     * @param {string} address - The address of the cell.\n     * @returns {Cell} The cell.\n     *//**\n     * Gets the cell with the given row and column numbers.\n     * @param {number} rowNumber - The row number of the cell.\n     * @param {string|number} columnNameOrNumber - The column name or number of the cell.\n     * @returns {Cell} The cell.\n     */\n    cell() {\n        return new ArgHandler('Sheet.cell')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'cell') throw new Error('Sheet.cell: Invalid address.');\n                return this.row(ref.rowNumber).cell(ref.columnNumber);\n            })\n            .case(['number', '*'], (rowNumber, columnNameOrNumber) => {\n                return this.row(rowNumber).cell(columnNameOrNumber);\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a column in the sheet.\n     * @param {string|number} columnNameOrNumber - The name or number of the column.\n     * @returns {Column} The column.\n     */\n    column(columnNameOrNumber) {\n        const columnNumber = typeof columnNameOrNumber === \"string\" ? addressConverter.columnNameToNumber(columnNameOrNumber) : columnNameOrNumber;\n\n        // If we're already created a column for this column number, return it.\n        if (this._columns[columnNumber]) return this._columns[columnNumber];\n\n        // We need to create a new column, which requires a backing col node. There may already exist a node whose min/max cover our column.\n        // First, see if there is an existing col node.\n        const existingColNode = this._colNodes[columnNumber];\n\n        let colNode;\n        if (existingColNode) {\n            // If the existing node covered earlier columns than the new one, we need to have a col node to cover the min up to our new node.\n            if (existingColNode.attributes.min < columnNumber) {\n                // Clone the node and set the max to the column before our new col.\n                const beforeColNode = _.cloneDeep(existingColNode);\n                beforeColNode.attributes.max = columnNumber - 1;\n\n                // Update the col nodes cache.\n                for (let i = beforeColNode.attributes.min; i <= beforeColNode.attributes.max; i++) {\n                    this._colNodes[i] = beforeColNode;\n                }\n            }\n\n            // Make a clone for the new column. Set the min/max to the column number and cache it.\n            colNode = _.cloneDeep(existingColNode);\n            colNode.attributes.min = columnNumber;\n            colNode.attributes.max = columnNumber;\n            this._colNodes[columnNumber] = colNode;\n\n            // If the max of the existing node is greater than the nre one, create a col node for that too.\n            if (existingColNode.attributes.max > columnNumber) {\n                const afterColNode = _.cloneDeep(existingColNode);\n                afterColNode.attributes.min = columnNumber + 1;\n                for (let i = afterColNode.attributes.min; i <= afterColNode.attributes.max; i++) {\n                    this._colNodes[i] = afterColNode;\n                }\n            }\n        } else {\n            // The was no existing node so create a new one.\n            colNode = {\n                name: 'col',\n                attributes: {\n                    min: columnNumber,\n                    max: columnNumber\n                },\n                children: []\n            };\n\n            this._colNodes[columnNumber] = colNode;\n        }\n\n        // Create the new column and cache it.\n        const column = new Column(this, colNode);\n        this._columns[columnNumber] = column;\n        return column;\n    }\n\n    /**\n     * Gets a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the sheet.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.workbook().scopedDefinedName(this, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.workbook().scopedDefinedName(this, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Deletes the sheet and returns the parent workbook.\n     * @returns {Workbook} The workbook.\n     */\n    delete() {\n        this.workbook().deleteSheet(this);\n        return this.workbook();\n    }\n\n    /**\n     * Find the given pattern in the sheet and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {Array.<Cell>} The matching cells.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._rows.forEach(row => {\n            if (!row) return;\n            matches = matches.concat(row.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Gets a value indicating whether this sheet's grid lines are visible.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet's grid lines are visible.\n     * @param {boolean} selected - True to make visible, false to hide.\n     * @returns {Sheet} The sheet.\n     */\n    gridLinesVisible() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.gridLinesVisible')\n            .case(() => {\n                return sheetViewNode.attributes.showGridLines === 1 || sheetViewNode.attributes.showGridLines === undefined;\n            })\n            .case('boolean', visible => {\n                sheetViewNode.attributes.showGridLines = visible ? 1 : 0;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating if the sheet is hidden or not.\n     * @returns {boolean|string} True if hidden, false if visible, and 'very' if very hidden.\n     *//**\n     * Set whether the sheet is hidden or not.\n     * @param {boolean|string} hidden - True to hide, false to show, and 'very' to make very hidden.\n     * @returns {Sheet} The sheet.\n     */\n    hidden() {\n        return new ArgHandler('Sheet.hidden')\n            .case(() => {\n                if (this._idNode.attributes.state === 'hidden') return true;\n                if (this._idNode.attributes.state === 'veryHidden') return \"very\";\n                return false;\n            })\n            .case('*', hidden => {\n                if (hidden) {\n                    const visibleSheets = _.filter(this.workbook().sheets(), sheet => !sheet.hidden());\n                    if (visibleSheets.length === 1 && visibleSheets[0] === this) {\n                        throw new Error(\"This sheet may not be hidden as a workbook must contain at least one visible sheet.\");\n                    }\n\n                    // If activate, activate the first other visible sheet.\n                    if (this.active()) {\n                        const activeIndex = visibleSheets[0] === this ? 1 : 0;\n                        visibleSheets[activeIndex].active(true);\n                    }\n                }\n\n                if (hidden === 'very') this._idNode.attributes.state = 'veryHidden';\n                else if (hidden) this._idNode.attributes.state = 'hidden';\n                else delete this._idNode.attributes.state;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Move the sheet.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The sheet.\n     */\n    move(indexOrBeforeSheet) {\n        this.workbook().moveSheet(this, indexOrBeforeSheet);\n        return this;\n    }\n\n    /**\n     * Get the name of the sheet.\n     * @returns {string} The sheet name.\n     *//**\n     * Set the name of the sheet. *Note: this method does not rename references to the sheet so formulas, etc. can be broken. Use with caution!*\n     * @param {string} name - The name to set to the sheet.\n     * @returns {Sheet} The sheet.\n     */\n    name() {\n        return new ArgHandler('Sheet.name')\n            .case(() => {\n                return `${this._idNode.attributes.name}`;\n            })\n            .case('string', name => {\n                this._idNode.attributes.name = name;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a range from the given range address.\n     * @param {string} address - The range address (e.g. 'A1:B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given cells or cell addresses.\n     * @param {string|Cell} startCell - The starting cell or cell address (e.g. 'A1').\n     * @param {string|Cell} endCell - The ending cell or cell address (e.g. 'B3').\n     * @returns {Range} The range.\n     *//**\n     * Gets a range from the given row numbers and column names or numbers.\n     * @param {number} startRowNumber - The starting cell row number.\n     * @param {string|number} startColumnNameOrNumber - The starting cell column name or number.\n     * @param {number} endRowNumber - The ending cell row number.\n     * @param {string|number} endColumnNameOrNumber - The ending cell column name or number.\n     * @returns {Range} The range.\n     */\n    range() {\n        return new ArgHandler('Sheet.range')\n            .case('string', address => {\n                const ref = addressConverter.fromAddress(address);\n                if (ref.type !== 'range') throw new Error('Sheet.range: Invalid address');\n                return this.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n            })\n            .case(['*', '*'], (startCell, endCell) => {\n                if (typeof startCell === \"string\") startCell = this.cell(startCell);\n                if (typeof endCell === \"string\") endCell = this.cell(endCell);\n                return new Range(startCell, endCell);\n            })\n            .case(['number', '*', 'number', '*'], (startRowNumber, startColumnNameOrNumber, endRowNumber, endColumnNameOrNumber) => {\n                return this.range(this.cell(startRowNumber, startColumnNameOrNumber), this.cell(endRowNumber, endColumnNameOrNumber));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Unsets sheet autoFilter.\n     * @returns {Sheet} This sheet.\n     *//**\n     * Sets sheet autoFilter to a Range.\n     * @param {Range} range - The autoFilter range.\n     * @returns {Sheet} This sheet.\n     */\n    autoFilter(range) {\n        this._autoFilter = range;\n\n        return this;\n    }\n\n    /**\n     * Gets the row with the given number.\n     * @param {number} rowNumber - The row number.\n     * @returns {Row} The row with the given number.\n     */\n    row(rowNumber) {\n        if (rowNumber < 1) throw new RangeError(`Invalid row number ${rowNumber}. Remember that spreadsheets use 1-based indexing.`);\n\n        if (this._rows[rowNumber]) return this._rows[rowNumber];\n\n        const rowNode = {\n            name: 'row',\n            attributes: {\n                r: rowNumber\n            },\n            children: []\n        };\n\n        const row = new Row(this, rowNode);\n        this._rows[rowNumber] = row;\n        return row;\n    }\n\n    /**\n     * Get the tab color. (See style [Color](#color).)\n     * @returns {undefined|Color} The color or undefined if not set.\n     *//**\n     * Sets the tab color. (See style [Color](#color).)\n     * @returns {Color|string|number} color - Color of the tab. If string, will set an RGB color. If number, will set a theme color.\n     */\n    tabColor() {\n        return new ArgHandler(\"Sheet.tabColor\")\n            .case(() => {\n                const tabColorNode = xmlq.findChild(this._sheetPrNode, \"tabColor\");\n                if (!tabColorNode) return;\n\n                const color = {};\n                if (tabColorNode.attributes.hasOwnProperty('rgb')) color.rgb = tabColorNode.attributes.rgb;\n                else if (tabColorNode.attributes.hasOwnProperty('theme')) color.theme = tabColorNode.attributes.theme;\n                else if (tabColorNode.attributes.hasOwnProperty('indexed')) color.rgb = colorIndexes[tabColorNode.attributes.indexed];\n\n                if (tabColorNode.attributes.hasOwnProperty('tint')) color.tint = tabColorNode.attributes.tint;\n\n                return color;\n            })\n            .case(\"string\", rgb => this.tabColor({ rgb }))\n            .case(\"integer\", theme => this.tabColor({ theme }))\n            .case(\"nil\", () => {\n                xmlq.removeChild(this._sheetPrNode, \"tabColor\");\n                return this;\n            })\n            .case(\"object\", color => {\n                const tabColorNode = xmlq.appendChildIfNotFound(this._sheetPrNode, \"tabColor\");\n                xmlq.setAttributes(tabColorNode, {\n                    rgb: color.rgb && color.rgb.toUpperCase(),\n                    indexed: null,\n                    theme: color.theme,\n                    tint: color.tint\n                });\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is selected.\n     * @returns {boolean} True if selected, false if not.\n     *//**\n     * Sets whether this sheet is selected.\n     * @param {boolean} selected - True to select, false to deselected.\n     * @returns {Sheet} The sheet.\n     */\n    tabSelected() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.tabSelected')\n            .case(() => {\n                return sheetViewNode.attributes.tabSelected === 1;\n            })\n            .case('boolean', selected => {\n                if (selected) sheetViewNode.attributes.tabSelected = 1;\n                else delete sheetViewNode.attributes.tabSelected;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets a value indicating whether this sheet is rtl (Right To Left).\n     * @returns {boolean} True if rtl, false if ltr.\n     *//**\n     * Sets whether this sheet is rtl.\n     * @param {boolean} rtl - True to rtl, false to ltr (Left To Right).\n     * @returns {Sheet} The sheet.\n     */\n    rightToLeft() {\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        return new ArgHandler('Sheet.rightToLeft')\n            .case(() => {\n                return sheetViewNode.attributes.rightToLeft;\n            })\n            .case('boolean', rtl => {\n                if (rtl) sheetViewNode.attributes.rightToLeft = true;\n                else delete sheetViewNode.attributes.rightToLeft;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the range of cells in the sheet that have contained a value or style at any point. Useful for extracting the entire sheet contents.\n     * @returns {Range|undefined} The used range or undefined if no cells in the sheet are used.\n     */\n    usedRange() {\n        const minRowNumber = _.findIndex(this._rows);\n        const maxRowNumber = this._rows.length - 1;\n\n        let minColumnNumber = 0;\n        let maxColumnNumber = 0;\n        for (let i = 0; i < this._rows.length; i++) {\n            const row = this._rows[i];\n            if (!row) continue;\n\n            const minUsedColumnNumber = row.minUsedColumnNumber();\n            const maxUsedColumnNumber = row.maxUsedColumnNumber();\n            if (minUsedColumnNumber > 0 && (!minColumnNumber || minUsedColumnNumber < minColumnNumber)) minColumnNumber = minUsedColumnNumber;\n            if (maxUsedColumnNumber > 0 && (!maxColumnNumber || maxUsedColumnNumber > maxColumnNumber)) maxColumnNumber = maxUsedColumnNumber;\n        }\n\n        // Return undefined if nothing in the sheet is used.\n        if (minRowNumber <= 0 || minColumnNumber <= 0 || maxRowNumber <= 0 || maxColumnNumber <= 0) return;\n\n        return this.range(minRowNumber, minColumnNumber, maxRowNumber, maxColumnNumber);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this._workbook;\n    }\n\n    /**\n     * Gets all page breaks.\n     * @returns {{}} the object holds both vertical and horizontal PageBreaks.\n     */\n    pageBreaks() {\n        return this._pageBreaks;\n    }\n\n    /**\n     * Gets the vertical page breaks.\n     * @returns {PageBreaks} vertical PageBreaks.\n     */\n    verticalPageBreaks() {\n        return this._pageBreaks.colBreaks;\n    }\n\n    /**\n     * Gets the horizontal page breaks.\n     * @returns {PageBreaks} horizontal PageBreaks.\n     */\n    horizontalPageBreaks() {\n        return this._pageBreaks.rowBreaks;\n    }\n\n    /* INTERNAL */\n\n    /**\n     * Clear cells that are using a given shared formula ID.\n     * @param {number} sharedFormulaId - The shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    clearCellsUsingSharedFormula(sharedFormulaId) {\n        this._rows.forEach(row => {\n            if (!row) return;\n            row.clearCellsUsingSharedFormula(sharedFormulaId);\n        });\n    }\n\n    /**\n     * Get an existing column style ID.\n     * @param {number} columnNumber - The column number.\n     * @returns {undefined|number} The style ID.\n     * @ignore\n     */\n    existingColumnStyleId(columnNumber) {\n        // This will work after setting Column.style because Column updates the attributes live.\n        const colNode = this._colNodes[columnNumber];\n        return colNode && colNode.attributes.style;\n    }\n\n    /**\n     * Call a callback for each column number that has a node defined for it.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingColumnNumber(callback) {\n        _.forEach(this._colNodes, (node, columnNumber) => {\n            if (!node) return;\n            callback(columnNumber);\n        });\n    }\n\n    /**\n     * Call a callback for each existing row.\n     * @param {Function} callback - The callback.\n     * @returns {undefined}\n     * @ignore\n     */\n    forEachExistingRow(callback) {\n        _.forEach(this._rows, (row, rowNumber) => {\n            if (row) callback(row, rowNumber);\n        });\n\n        return this;\n    }\n\n    /**\n     * Get the hyperlink attached to the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @returns {string|undefined} The hyperlink or undefined if not set.\n     *//**\n     * Set the hyperlink on the cell with the given address.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {string} hyperlink - The hyperlink to set or undefined to clear.\n     * @param {boolean} [internal] - The flag to force hyperlink to be internal. If true, then autodetect is skipped.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set the hyperlink on the cell with the given address. If opts is a Cell an internal hyperlink is added.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {object|Cell} opts - Options.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     *//**\n     * Set the hyperlink on the cell with the given address and options.\n     * @param {string} address - The address of the hyperlinked cell.\n     * @param {{}|Cell} opts - Options or Cell. If opts is a Cell then an internal hyperlink is added.\n     * @param {string|Cell} [opts.hyperlink] - The hyperlink to set, can be a Cell or an internal/external string.\n     * @param {string} [opts.tooltip] - Additional text to help the user understand more about the hyperlink.\n     * @param {string} [opts.email] - Email address, ignored if opts.hyperlink is set.\n     * @param {string} [opts.emailSubject] - Email subject, ignored if opts.hyperlink is set.\n     * @returns {Sheet} The sheet.\n     */\n    hyperlink() {\n        return new ArgHandler('Sheet.hyperlink')\n            .case('string', address => {\n                const hyperlinkNode = this._hyperlinks[address];\n                if (!hyperlinkNode) return;\n                const relationship = this._relationships.findById(hyperlinkNode.attributes['r:id']);\n                return relationship && relationship.attributes.Target;\n            })\n            .case(['string', 'nil'], address => {\n                // TODO: delete relationship\n                delete this._hyperlinks[address];\n                return this;\n            })\n            .case(['string', 'string'], (address, hyperlink) => {\n                return this.hyperlink(address, hyperlink, false);\n            })\n            .case(['string', 'string', 'boolean'], (address, hyperlink, internal) => {\n                const isHyperlinkInternalAddress = internal || addressConverter.fromAddress(hyperlink);\n                let nodeAttributes;\n                if (isHyperlinkInternalAddress) {\n                    nodeAttributes = {\n                        ref: address,\n                        location: hyperlink,\n                        display: hyperlink\n                    };\n                } else {\n                    const relationship = this._relationships.add(\"hyperlink\", hyperlink, \"External\");\n                    nodeAttributes = {\n                        ref: address,\n                        'r:id': relationship.attributes.Id\n                    };\n                }\n                this._hyperlinks[address] = {\n                    name: 'hyperlink',\n                    attributes: nodeAttributes,\n                    children: []\n                };\n                return this;\n            })\n            .case(['string', 'object'], (address, opts) => {\n                if (opts instanceof Cell) {\n                    const cell = opts;\n                    const hyperlink = cell.address({ includeSheetName: true });\n                    this.hyperlink(address, hyperlink, true);\n                } else if (opts.hyperlink) {\n                    this.hyperlink(address, opts.hyperlink);\n                } else if (opts.email) {\n                    const email = opts.email;\n                    const subject = opts.emailSubject || '';\n                    this.hyperlink(address, encodeURI(`mailto:${email}?subject=${subject}`));\n                }\n                const hyperlinkNode = this._hyperlinks[address];\n                if (hyperlinkNode) {\n                    if (opts.tooltip) {\n                        hyperlinkNode.attributes.tooltip = opts.tooltip;\n                    }\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Increment and return the max shared formula ID.\n     * @returns {number} The new max shared formula ID.\n     * @ignore\n     */\n    incrementMaxSharedFormulaId() {\n        return ++this._maxSharedFormulaId;\n    }\n\n    /**\n     * Get a value indicating whether the cells in the given address are merged.\n     * @param {string} address - The address to check.\n     * @returns {boolean} True if merged, false if not merged.\n     * @ignore\n     *//**\n     * Merge/unmerge cells by adding/removing a mergeCell entry.\n     * @param {string} address - The address to merge.\n     * @param {boolean} merged - True to merge, false to unmerge.\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    merged() {\n        return new ArgHandler('Sheet.merge')\n            .case('string', address => {\n                return this._mergeCells.hasOwnProperty(address);\n            })\n            .case(['string', '*'], (address, merge) => {\n                if (merge) {\n                    this._mergeCells[address] = {\n                        name: 'mergeCell',\n                        attributes: { ref: address },\n                        children: []\n                    };\n                } else {\n                    delete this._mergeCells[address];\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n\n    /**\n     * Gets a Object or undefined of the cells in the given address.\n     * @param {string} address - The address to check.\n     * @returns {object|boolean} Object or false if not set\n     * @ignore\n     *//**\n     * Removes dataValidation at the given address\n     * @param {string} address - The address to remove.\n     * @param {boolean} obj - false to delete.\n     * @returns {boolean} true if removed.\n     * @ignore\n     *//**\n     * Add dataValidation to cells at the given address if object or string\n     * @param {string} address - The address to set.\n     * @param {object|string} obj - Object or String to set\n     * @returns {Sheet} The sheet.\n     * @ignore\n     */\n    dataValidation() {\n        return new ArgHandler('Sheet.dataValidation')\n            .case('string', address => {\n                if (this._dataValidations[address]) {\n                    return {\n                        type: this._dataValidations[address].attributes.type,\n                        allowBlank: this._dataValidations[address].attributes.allowBlank,\n                        showInputMessage: this._dataValidations[address].attributes.showInputMessage,\n                        prompt: this._dataValidations[address].attributes.prompt,\n                        promptTitle: this._dataValidations[address].attributes.promptTitle,\n                        showErrorMessage: this._dataValidations[address].attributes.showErrorMessage,\n                        error: this._dataValidations[address].attributes.error,\n                        errorTitle: this._dataValidations[address].attributes.errorTitle,\n                        operator: this._dataValidations[address].attributes.operator,\n                        formula1: this._dataValidations[address].children[0].children[0],\n                        formula2: this._dataValidations[address].children[1] ? this._dataValidations[address].children[1].children[0] : undefined\n                    };\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', 'boolean'], (address, obj) => {\n                if (this._dataValidations[address]) {\n                    if (obj === false) return delete this._dataValidations[address];\n                } else {\n                    return false;\n                }\n            })\n            .case(['string', '*'], (address, obj) => {\n                if (typeof obj === 'string') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: 'list',\n                            allowBlank: false,\n                            showInputMessage: false,\n                            prompt: '',\n                            promptTitle: '',\n                            showErrorMessage: false,\n                            error: '',\n                            errorTitle: '',\n                            operator: '',\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [obj]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: ['']\n                            }\n                        ]\n                    };\n                } else if (typeof obj === 'object') {\n                    this._dataValidations[address] = {\n                        name: 'dataValidation',\n                        attributes: {\n                            type: obj.type ? obj.type : 'list',\n                            allowBlank: obj.allowBlank,\n                            showInputMessage: obj.showInputMessage,\n                            prompt: obj.prompt,\n                            promptTitle: obj.promptTitle,\n                            showErrorMessage: obj.showErrorMessage,\n                            error: obj.error,\n                            errorTitle: obj.errorTitle,\n                            operator: obj.operator,\n                            sqref: address\n                        },\n                        children: [\n                            {\n                                name: 'formula1',\n                                atrributes: {},\n                                children: [\n                                    obj.formula1\n                                ]\n                            },\n                            {\n                                name: 'formula2',\n                                atrributes: {},\n                                children: [\n                                    obj.formula2\n                                ]\n                            }\n                        ]\n                    };\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Convert the sheet to a collection of XML objects.\n     * @returns {{}} The XML forms.\n     * @ignore\n     */\n    toXmls() {\n        // Shallow clone the node so we don't have to remove these children later if they don't belong.\n        const node = _.clone(this._node);\n        node.children = node.children.slice();\n\n        // Add the columns if needed.\n        this._colsNode.children = _.filter(this._colNodes, (colNode, i) => {\n            // Columns should only be present if they have attributes other than min/max.\n            return colNode && i === colNode.attributes.min && Object.keys(colNode.attributes).length > 2;\n        });\n        if (this._colsNode.children.length) {\n            xmlq.insertInOrder(node, this._colsNode, nodeOrder);\n        }\n\n        // Add the hyperlinks if needed.\n        this._hyperlinksNode.children = _.values(this._hyperlinks);\n        if (this._hyperlinksNode.children.length) {\n            xmlq.insertInOrder(node, this._hyperlinksNode, nodeOrder);\n        }\n\n        // Add the printOptions if needed.\n        if (this._printOptionsNode) {\n            if (Object.keys(this._printOptionsNode.attributes).length) {\n                xmlq.insertInOrder(node, this._printOptionsNode, nodeOrder);\n            }\n        }\n\n        // Add the pageMargins if needed.\n        if (this._pageMarginsNode && this._pageMarginsPresetName) {\n            // Clone to preserve the current state of this sheet.\n            const childNode = _.clone(this._pageMarginsNode);\n            if (Object.keys(this._pageMarginsNode.attributes).length) {\n                // Fill in any missing attribute values with presets.\n                childNode.attributes = _.assign(\n                    this._pageMarginsPresets[this._pageMarginsPresetName],\n                    this._pageMarginsNode.attributes);\n            } else {\n                // No need to fill in, all attributes is currently empty, simply replace.\n                childNode.attributes = this._pageMarginsPresets[this._pageMarginsPresetName];\n            }\n            xmlq.insertInOrder(node, childNode, nodeOrder);\n        }\n\n        // Add the merge cells if needed.\n        this._mergeCellsNode.children = _.values(this._mergeCells);\n        if (this._mergeCellsNode.children.length) {\n            xmlq.insertInOrder(node, this._mergeCellsNode, nodeOrder);\n        }\n\n        // Add the DataValidation cells if needed.\n        this._dataValidationsNode.children = _.values(this._dataValidations);\n        if (this._dataValidationsNode.children.length) {\n            xmlq.insertInOrder(node, this._dataValidationsNode, nodeOrder);\n        }\n\n        if (this._autoFilter) {\n            xmlq.insertInOrder(node, {\n                name: \"autoFilter\",\n                children: [],\n                attributes: {\n                    ref: this._autoFilter.address()\n                }\n            }, nodeOrder);\n        }\n\n        // Add the PageBreaks nodes if needed.\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            const breaks = this[`_${name}Node`];\n            if (breaks.attributes.count) {\n                xmlq.insertInOrder(node, breaks, nodeOrder);\n            }\n        });\n\n        return {\n            id: this._idNode,\n            sheet: node,\n            relationships: this._relationships\n        };\n    }\n\n    /**\n     * Update the max shared formula ID to the given value if greater than current.\n     * @param {number} sharedFormulaId - The new shared formula ID.\n     * @returns {undefined}\n     * @ignore\n     */\n    updateMaxSharedFormulaId(sharedFormulaId) {\n        if (sharedFormulaId > this._maxSharedFormulaId) {\n            this._maxSharedFormulaId = sharedFormulaId;\n        }\n    }\n\n    /**\n     * Get the print option given a valid print option attribute.\n     * @param {string} attributeName - Attribute name of the printOptions.\n     *   gridLines - Used in conjunction with gridLinesSet. If both gridLines and gridlinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   gridLinesSet - Used in conjunction with gridLines. If both gridLines and gridLinesSet are true, then grid lines shall print. Otherwise, they shall not (i.e., one or both have false values).\n     *   headings - Print row and column headings.\n     *   horizontalCentered - Center on page horizontally when printing.\n     *   verticalCentered - Center on page vertically when printing.\n     * @returns {boolean}\n     *//**\n     * Set the print option given a valid print option attribute and a value.\n     * @param {string} attributeName - Attribute name of the printOptions. See get print option for list of valid attributes.\n     * @param {undefined|boolean} attributeEnabled - If `undefined` or `false` then the attribute is removed, otherwise the print option is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printOptions() {\n        const supportedAttributeNames = [\n            'gridLines', 'gridLinesSet', 'headings', 'horizontalCentered', 'verticalCentered'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('printOptions', supportedAttributeNames);\n        return new ArgHandler('Sheet.printOptions')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                return this._printOptionsNode.attributes[attributeName] === 1;\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._printOptionsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'boolean'], (attributeName, attributeEnabled) => {\n                checkAttributeName(attributeName);\n                if (attributeEnabled) {\n                    this._printOptionsNode.attributes[attributeName] = 1;\n                    return this;\n                } else {\n                    return this.printOptions(attributeName, undefined);\n                }\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the print option for the gridLines attribute value.\n     * @returns {boolean}\n     *//**\n     * Set the print option for the gridLines attribute value.\n     * @param {undefined|boolean} enabled - If `undefined` or `false` then attribute is removed, otherwise gridLines is enabled.\n     * @returns {Sheet} The sheet.\n     */\n    printGridLines() {\n        return new ArgHandler('Sheet.gridLines')\n            .case(() => {\n                return this.printOptions('gridLines') && this.printOptions('gridLinesSet');\n            })\n            .case(['nil'], () => {\n                this.printOptions('gridLines', undefined);\n                this.printOptions('gridLinesSet', undefined);\n                return this;\n            })\n            .case(['boolean'], enabled => {\n                this.printOptions('gridLines', enabled);\n                this.printOptions('gridLinesSet', enabled);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the page margin given a valid attribute name.\n     * If the value is not yet defined, then it will return the current preset value.\n     * @param {string} attributeName - Attribute name of the pageMargins.\n     *     left - Left Page Margin in inches.\n     *     right - Right page margin in inches.\n     *     top - Top Page Margin in inches.\n     *     buttom - Bottom Page Margin in inches.\n     *     footer - Footer Page Margin in inches.\n     *     header - Header Page Margin in inches.\n     * @returns {number} the attribute value.\n     *//**\n     * Set the page margin (or override the preset) given an attribute name and a value.\n     * @param {string} attributeName - Attribute name of the pageMargins. See get page margin for list of valid attributes.\n     * @param {undefined|number|string} attributeStringValue - If `undefined` then set back to preset value, otherwise, set the given attribute value.\n     * @returns {Sheet} The sheet.\n     */\n    pageMargins() {\n        if (this.pageMarginsPreset() === undefined) {\n            throw new Error('Sheet.pageMargins: preset is undefined.');\n        }\n        const supportedAttributeNames = [\n            'left', 'right', 'top', 'bottom', 'header', 'footer'];\n        const checkAttributeName = this._getCheckAttributeNameHelper('pageMargins', supportedAttributeNames);\n        const checkRange = this._getCheckRangeHelper('pageMargins', 0, undefined);\n        return new ArgHandler('Sheet.pageMargins')\n            .case(['string'], attributeName => {\n                checkAttributeName(attributeName);\n                const attributeValue = this._pageMarginsNode.attributes[attributeName];\n                if (attributeValue !== undefined) {\n                    return parseFloat(attributeValue);\n                } else if (this._pageMarginsPresetName) {\n                    return parseFloat(this._pageMarginsPresets[this._pageMarginsPresetName][attributeName]);\n                } else {\n                    return undefined;\n                }\n            })\n            .case(['string', 'nil'], attributeName => {\n                checkAttributeName(attributeName);\n                delete this._pageMarginsNode.attributes[attributeName];\n                return this;\n            })\n            .case(['string', 'number'], (attributeName, attributeNumberValue) => {\n                checkAttributeName(attributeName);\n                checkRange(attributeNumberValue);\n                this._pageMarginsNode.attributes[attributeName] = attributeNumberValue;\n                return this;\n            })\n            .case(['string', 'string'], (attributeName, attributeStringValue) => {\n                return this.pageMargins(attributeName, parseFloat(attributeStringValue));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Page margins preset is a set of page margins associated with a name.\n     * The page margin preset acts as a fallback when not explicitly defined by `Sheet.pageMargins`.\n     * If a sheet already contains page margins, it attempts to auto-detect, otherwise they are defined as the template preset.\n     * If no page margins exist, then the preset is undefined and will not be included in the output of `Sheet.toXmls`.\n     * Available presets include: normal, wide, narrow, template.\n     *\n     * Get the page margins preset name. The registered name of a predefined set of attributes.\n     * @returns {string} The preset name.\n     *//**\n     * Set the page margins preset by name, clearing any existing/temporary attribute values.\n     * @param {undefined|string} presetName - The preset name. If `undefined`, page margins will not be included in the output of `Sheet.toXmls`.\n     * @returns {Sheet} The sheet.\n     *//**\n     * Set a new page margins preset by name and attributes object.\n     * @param {string} presetName - The preset name.\n     * @param {object} presetAttributes - The preset attributes.\n     * @returns {Sheet} The sheet.\n     */\n    pageMarginsPreset() {\n        return new ArgHandler('Sheet.pageMarginsPreset')\n            .case(() => {\n                return this._pageMarginsPresetName;\n            })\n            .case(['nil'], () => {\n                // Remove all preset overrides and exclude from sheet\n                this._pageMarginsPresetName = undefined;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string'], presetName => {\n                const checkPresetName = this._getCheckAttributeNameHelper(\n                    'pageMarginsPreset', Object.keys(this._pageMarginsPresets));\n                checkPresetName(presetName);\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n                return this;\n            })\n            .case(['string', 'object'], (presetName, presetAttributes) => {\n                if (this._pageMarginsPresets.hasOwnProperty(presetName)) {\n                    throw new Error(`Sheet.pageMarginsPreset: The preset ${presetName} already exists!`);\n                }\n\n                // Validate preset attribute keys.\n                const pageMarginsAttributeNames = [\n                    'left', 'right', 'top', 'bottom', 'header', 'footer'];\n                const isValidPresetAttributeKeys = _.isEqual(\n                    _.sortBy(pageMarginsAttributeNames),\n                    _.sortBy(Object.keys(presetAttributes)));\n                if (isValidPresetAttributeKeys === false) {\n                    throw new Error(`Sheet.pageMarginsPreset: Invalid preset attributes for one or key(s)! - \"${Object.keys(presetAttributes)}\"`);\n                }\n\n                // Validate preset attribute values.\n                _.forEach((attributeValue, attributeName) => {\n                    const attributeNumberValue = parseFloat(attributeValue);\n                    if (_.isNaN(attributeNumberValue) || _.isNumber(attributeNumberValue) === false) {\n                        throw new Error(`Sheet.pageMarginsPreset: Invalid preset attribute value! - \"${attributeValue}\"`);\n                    }\n                });\n\n                // Change to new preset\n                this._pageMarginsPresetName = presetName;\n\n                // Remove all preset overrides\n                this._pageMarginsNode.attributes = {};\n\n                // Register the preset\n                this._pageMarginsPresets[presetName] = presetAttributes;\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * https://docs.microsoft.com/en-us/dotnet/api/documentformat.openxml.spreadsheet.pane?view=openxml-2.8.1\n     * @typedef {Object} PaneOptions\n     * @property {string} activePane=bottomRight Active Pane. The pane that is active.\n     * @property {string} state Split State. Indicates whether the pane has horizontal / vertical splits,\n     * and whether those splits are frozen.\n     * @property {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @property {number} xSplit (Horizontal Split Position) Horizontal position of the split, in 1/20th of a point;\n     * 0 (zero) if none. If the pane is frozen, this value indicates the number of columns visible in the top pane.\n     * @property {number} ySplit (Vertical Split Position) Vertical position of the split, in 1/20th of a point; 0\n     * (zero) if none. If the pane is frozen, this value indicates the number of rows visible in the left pane.\n     *//**\n     * Gets sheet view pane options\n     * @return {PaneOptions} sheet view pane options\n     *//**\n     * Sets sheet view pane options\n     * @param {PaneOptions|null|undefined} paneOptions sheet view pane options\n     * @return {Sheet} The sheet\n     */\n    panes() {\n        const supportedStates = ['split', 'frozen', 'frozenSplit'];\n        const supportedActivePanes = ['bottomLeft', 'bottomRight', 'topLeft', 'topRight'];\n        const checkStateName = this._getCheckAttributeNameHelper('pane.state', supportedStates);\n        const checkActivePane = this._getCheckAttributeNameHelper('pane.activePane', supportedActivePanes);\n        const sheetViewNode = this._getOrCreateSheetViewNode();\n        let paneNode = xmlq.findChild(sheetViewNode, 'pane');\n        return new ArgHandler('Sheet.pane')\n            .case(() => {\n                if (paneNode) {\n                    const result = _.cloneDeep(paneNode.attributes);\n                    if (!result.state) result.state = 'split';\n                    return result;\n                }\n            })\n            .case(['nil'], () => {\n                xmlq.removeChild(sheetViewNode, 'pane');\n                return this;\n            })\n            .case(['object'], paneAttributes => {\n                const attributes = _.assign({ activePane: 'bottomRight' }, paneAttributes);\n                checkStateName(attributes.state);\n                checkActivePane(attributes.activePane);\n                if (paneNode) {\n                    paneNode.attributes = attributes;\n                } else {\n                    paneNode = {\n                        name: \"pane\",\n                        attributes,\n                        children: []\n                    };\n                    xmlq.appendChild(sheetViewNode, paneNode);\n                }\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Freezes Panes for this sheet.\n     * @param {number} xSplit the number of columns visible in the top pane. 0 (zero) if none.\n     * @param {number} ySplit the number of rows visible in the left pane. 0 (zero) if none.\n     * @return {Sheet} The sheet\n     *//**\n     * freezes Panes for this sheet.\n     * @param {string} topLeftCell Top Left Visible Cell. Location of the top left visible cell in the bottom\n     * right pane (when in Left-To-Right mode).\n     * @return {Sheet} The sheet\n     */\n    freezePanes() {\n        return new ArgHandler('Sheet.feezePanes')\n            .case(['integer', 'integer'], (xSplit, ySplit) => {\n                const topLeftCell = addressConverter.columnNumberToName(xSplit + 1) + (ySplit + 1);\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .case(['string'], topLeftCell => {\n                const ref = addressConverter.fromAddress(topLeftCell);\n                const xSplit = ref.columnNumber - 1, ySplit = ref.rowNumber - 1;\n                let activePane = xSplit === 0 ? 'bottomLeft' : 'bottomRight';\n                activePane = ySplit === 0 ? 'topRight' : activePane;\n                return this.panes({ state: 'frozen', topLeftCell, xSplit, ySplit, activePane });\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Splits Panes for this sheet.\n     * @param {number} xSplit (Horizontal Split Position) Horizontal position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @param {number} ySplit (Vertical Split Position) VVertical position of the split,\n     * in 1/20th of a point; 0 (zero) if none.\n     * @return {Sheet} The sheet\n     */\n    splitPanes(xSplit, ySplit) {\n        return this.panes({ state: 'split', xSplit, ySplit });\n    }\n\n    /**\n     * resets to default sheet view panes.\n     * @return {Sheet} The sheet\n     */\n    resetPanes() {\n        return this.panes(null);\n    }\n\n    /* PRIVATE */\n\n    /**\n     * Get a helper function to check that the attribute name provided is supported.\n     * @param {string} functionName - Name of the parent function.\n     * @param {array} supportedAttributeNames - Array of supported attribute name strings.\n     * @returns {function} The helper function, which takes an attribute name. If the array of supported attribute names does not contain the given attribute name, then an Error is thrown.\n     * @ignore\n     */\n    _getCheckAttributeNameHelper(functionName, supportedAttributeNames) {\n        return attributeName => {\n            if (!_.includes(supportedAttributeNames, attributeName)) {\n                throw new Error(`Sheet.${functionName}: \"${attributeName}\" is not supported.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is of the expected type.\n     * @param {string} functionName - Name of the parent function.\n     * @param {string} valueType - A string produced by typeof.\n     * @returns {function} The helper function, which takes a value. If the value type is not expected, a TypeError is thrown.\n     * @ignore\n     */\n    _getCheckTypeHelper(functionName, valueType) {\n        return value => {\n            if (typeof value !== valueType) {\n                throw new TypeError(`Sheet.${functionName}: invalid type - value must be of type ${valueType}.`);\n            }\n        };\n    }\n\n    /**\n     * Get a helper function to check that the value is within the expected range.\n     * @param {string} functionName - Name of the parent function.\n     * @param {undefined|number} valueMin - The minimum value of the range. This value is range-inclusive.\n     * @param {undefined|number} valueMax - The maximum value of the range. This value is range-exclusive.\n     * @returns {function} The helper function, which takes a value. If the value type is not 'number', a TypeError is thrown. If the value is not within the range, a RangeError is thrown.\n     * @ignore\n     */\n    _getCheckRangeHelper(functionName, valueMin, valueMax) {\n        const checkType = this._getCheckTypeHelper(functionName, 'number');\n        return value => {\n            checkType(value);\n            if (valueMin !== undefined) {\n                if (value < valueMin) {\n                    throw new RangeError(`Sheet.${functionName}: value too small - value must be greater than or equal to ${valueMin}.`);\n                }\n            }\n            if (valueMax !== undefined) {\n                if (valueMax <= value) {\n                    throw new RangeError(`Sheet.${functionName}: value too large - value must be less than ${valueMax}.`);\n                }\n            }\n        };\n    }\n\n    /**\n     * Get the sheet view node if it exists or create it if it doesn't.\n     * @returns {{}} The sheet view node.\n     * @private\n     */\n    _getOrCreateSheetViewNode() {\n        let sheetViewsNode = xmlq.findChild(this._node, \"sheetViews\");\n        if (!sheetViewsNode) {\n            sheetViewsNode = {\n                name: \"sheetViews\",\n                attributes: {},\n                children: [{\n                    name: \"sheetView\",\n                    attributes: {\n                        workbookViewId: 0\n                    },\n                    children: []\n                }]\n            };\n\n            xmlq.insertInOrder(this._node, sheetViewsNode, nodeOrder);\n        }\n\n        return xmlq.findChild(sheetViewsNode, \"sheetView\");\n    }\n\n    /**\n     * Initializes the sheet.\n     * @param {Workbook} workbook - The parent workbook.\n     * @param {{}} idNode - The sheet ID node (from the parent workbook).\n     * @param {{}} node - The sheet node.\n     * @param {{}} [relationshipsNode] - The optional sheet relationships node.\n     * @returns {undefined}\n     * @private\n     */\n    _init(workbook, idNode, node, relationshipsNode) {\n        if (!node) {\n            node = {\n                name: \"worksheet\",\n                attributes: {\n                    xmlns: \"http://schemas.openxmlformats.org/spreadsheetml/2006/main\",\n                    'xmlns:r': \"http://schemas.openxmlformats.org/officeDocument/2006/relationships\",\n                    'xmlns:mc': \"http://schemas.openxmlformats.org/markup-compatibility/2006\",\n                    'mc:Ignorable': \"x14ac\",\n                    'xmlns:x14ac': \"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\"\n                },\n                children: [{\n                    name: \"sheetData\",\n                    attributes: {},\n                    children: []\n                }]\n            };\n        }\n\n        this._workbook = workbook;\n        this._idNode = idNode;\n        this._node = node;\n        this._maxSharedFormulaId = -1;\n        this._mergeCells = {};\n        this._dataValidations = {};\n        this._hyperlinks = {};\n        this._autoFilter = null;\n\n        // Create the relationships.\n        this._relationships = new Relationships(relationshipsNode);\n\n        // Delete the optional dimension node\n        xmlq.removeChild(this._node, \"dimension\");\n\n        // Create the rows.\n        this._rows = [];\n        this._sheetDataNode = xmlq.findChild(this._node, \"sheetData\");\n        this._sheetDataNode.children.forEach(rowNode => {\n            const row = new Row(this, rowNode);\n            this._rows[row.rowNumber()] = row;\n        });\n        this._sheetDataNode.children = this._rows;\n\n        // Create the columns node.\n        this._columns = [];\n        this._colsNode = xmlq.findChild(this._node, \"cols\");\n        if (this._colsNode) {\n            xmlq.removeChild(this._node, this._colsNode);\n        } else {\n            this._colsNode = { name: 'cols', attributes: {}, children: [] };\n        }\n\n        // Cache the col nodes.\n        this._colNodes = [];\n        _.forEach(this._colsNode.children, colNode => {\n            const min = colNode.attributes.min;\n            const max = colNode.attributes.max;\n            for (let i = min; i <= max; i++) {\n                this._colNodes[i] = colNode;\n            }\n        });\n\n        // Create the sheet properties node.\n        this._sheetPrNode = xmlq.findChild(this._node, \"sheetPr\");\n        if (!this._sheetPrNode) {\n            this._sheetPrNode = { name: 'sheetPr', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, this._sheetPrNode, nodeOrder);\n        }\n\n        // Create the merge cells.\n        this._mergeCellsNode = xmlq.findChild(this._node, \"mergeCells\");\n        if (this._mergeCellsNode) {\n            xmlq.removeChild(this._node, this._mergeCellsNode);\n        } else {\n            this._mergeCellsNode = { name: 'mergeCells', attributes: {}, children: [] };\n        }\n\n        const mergeCellNodes = this._mergeCellsNode.children;\n        this._mergeCellsNode.children = [];\n        mergeCellNodes.forEach(mergeCellNode => {\n            this._mergeCells[mergeCellNode.attributes.ref] = mergeCellNode;\n        });\n\n\n        // Create the DataValidations.\n        this._dataValidationsNode = xmlq.findChild(this._node, \"dataValidations\");\n        if (this._dataValidationsNode) {\n            xmlq.removeChild(this._node, this._dataValidationsNode);\n        } else {\n            this._dataValidationsNode = { name: 'dataValidations', attributes: {}, children: [] };\n        }\n\n        const dataValidationNodes = this._dataValidationsNode.children;\n        this._dataValidationsNode.children = [];\n        dataValidationNodes.forEach(dataValidationNode => {\n            this._dataValidations[dataValidationNode.attributes.sqref] = dataValidationNode;\n        });\n\n\n        // Create the hyperlinks.\n        this._hyperlinksNode = xmlq.findChild(this._node, \"hyperlinks\");\n        if (this._hyperlinksNode) {\n            xmlq.removeChild(this._node, this._hyperlinksNode);\n        } else {\n            this._hyperlinksNode = { name: 'hyperlinks', attributes: {}, children: [] };\n        }\n\n        const hyperlinkNodes = this._hyperlinksNode.children;\n        this._hyperlinksNode.children = [];\n        hyperlinkNodes.forEach(hyperlinkNode => {\n            this._hyperlinks[hyperlinkNode.attributes.ref] = hyperlinkNode;\n        });\n\n\n        // Create the printOptions.\n        this._printOptionsNode = xmlq.findChild(this._node, \"printOptions\");\n        if (this._printOptionsNode) {\n            xmlq.removeChild(this._node, this._printOptionsNode);\n        } else {\n            this._printOptionsNode = { name: 'printOptions', attributes: {}, children: [] };\n        }\n\n\n        // Create the pageMargins.\n        this._pageMarginsPresets = {\n            normal: {\n                left: 0.7,\n                right: 0.7,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            },\n            wide: {\n                left: 1,\n                right: 1,\n                top: 1,\n                bottom: 1,\n                header: 0.5,\n                footer: 0.5\n            },\n            narrow: {\n                left: 0.25,\n                right: 0.25,\n                top: 0.75,\n                bottom: 0.75,\n                header: 0.3,\n                footer: 0.3\n            }\n        };\n        this._pageMarginsNode = xmlq.findChild(this._node, \"pageMargins\");\n        if (this._pageMarginsNode) {\n            // Sheet has page margins, assume preset is template.\n            this._pageMarginsPresetName = 'template';\n\n            // Search for a preset that matches existing attributes.\n            for (const presetName in this._pageMarginsPresets) {\n                if (_.isEqual(this._pageMarginsNode.attributes, this._pageMarginsPresets[presetName])) {\n                    this._pageMarginsPresetName = presetName;\n                    break;\n                }\n            }\n\n            // If template preset, then register as template preset, and clear attributes.\n            if (this._pageMarginsPresetName === 'template') {\n                this._pageMarginsPresets.template = this._pageMarginsNode.attributes;\n                this._pageMarginsNode.attributes = {};\n            }\n\n            xmlq.removeChild(this._node, this._pageMarginsNode);\n        } else {\n            // Sheet has no page margins, the preset assignment is therefore undefined.\n            this._pageMarginsPresetName = undefined;\n            this._pageMarginsNode = { name: 'pageMargins', attributes: {}, children: [] };\n        }\n\n        // Create the pageBreaks\n        ['colBreaks', 'rowBreaks'].forEach(name => {\n            this[`_${name}Node`] = xmlq.findChild(this._node, name);\n            if (this[`_${name}Node`]) {\n                xmlq.removeChild(this._node, this[`_${name}Node`]);\n            } else {\n                this[`_${name}Node`] = {\n                    name,\n                    children: [],\n                    attributes: {\n                        count: 0,\n                        manualBreakCount: 0\n                    }\n                };\n            }\n        });\n        this._pageBreaks = {\n            colBreaks: new PageBreaks(this._colBreaksNode),\n            rowBreaks: new PageBreaks(this._rowBreaksNode)\n        };\n    }\n}\n\nmodule.exports = Sheet;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<worksheet ...>\n    ...\n\n    <printOptions headings=\"1\" gridLines=\"1\" />\n    <pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\" />\n    <pageSetup orientation=\"portrait\" horizontalDpi=\"0\" verticalDpi=\"0\" />\n</worksheet>\n// */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}