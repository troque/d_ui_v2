{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar ArgHandler = require(\"./ArgHandler\");\nvar addressConverter = require(\"./addressConverter\");\n\n/**\n * A range of cells.\n */\nvar Range = /*#__PURE__*/function () {\n  // /**\n  //  * Creates a new instance of Range.\n  //  * @param {Cell} startCell - The start cell.\n  //  * @param {Cell} endCell - The end cell.\n  //  */\n  function Range(startCell, endCell) {\n    _classCallCheck(this, Range);\n    this._startCell = startCell;\n    this._endCell = endCell;\n    this._findRangeExtent(startCell, endCell);\n  }\n\n  /**\n   * Get the address of the range.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.startRowAnchored] - Anchor the start row.\n   * @param {boolean} [opts.startColumnAnchored] - Anchor the start column.\n   * @param {boolean} [opts.endRowAnchored] - Anchor the end row.\n   * @param {boolean} [opts.endColumnAnchored] - Anchor the end column.\n   * @param {boolean} [opts.anchored] - Anchor all row and columns.\n   * @returns {string} The address.\n   */\n  _createClass(Range, [{\n    key: \"address\",\n    value: function address(opts) {\n      return addressConverter.toAddress({\n        type: 'range',\n        startRowNumber: this.startCell().rowNumber(),\n        startRowAnchored: opts && (opts.startRowAnchored || opts.anchored),\n        startColumnName: this.startCell().columnName(),\n        startColumnAnchored: opts && (opts.startColumnAnchored || opts.anchored),\n        endRowNumber: this.endCell().rowNumber(),\n        endRowAnchored: opts && (opts.endRowAnchored || opts.anchored),\n        endColumnName: this.endCell().columnName(),\n        endColumnAnchored: opts && (opts.endColumnAnchored || opts.anchored),\n        sheetName: opts && opts.includeSheetName && this.sheet().name()\n      });\n    }\n\n    /**\n     * Gets a cell within the range.\n     * @param {number} ri - Row index relative to the top-left corner of the range (0-based).\n     * @param {number} ci - Column index relative to the top-left corner of the range (0-based).\n     * @returns {Cell} The cell.\n     */\n  }, {\n    key: \"cell\",\n    value: function cell(ri, ci) {\n      return this.sheet().cell(this._minRowNumber + ri, this._minColumnNumber + ci);\n    }\n\n    /**\n     * Sets sheet autoFilter to this range.\n     * @returns {Range} This range.\n     */\n  }, {\n    key: \"autoFilter\",\n    value: function autoFilter() {\n      this.sheet().autoFilter(this);\n      return this;\n    }\n\n    /**\n     * Get the cells in the range as a 2D array.\n     * @returns {Array.<Array.<Cell>>} The cells.\n     */\n  }, {\n    key: \"cells\",\n    value: function cells() {\n      return this.map(function (cell) {\n        return cell;\n      });\n    }\n\n    /**\n     * Clear the contents of all the cells in the range.\n     * @returns {Range} The range.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      return this.value(undefined);\n    }\n\n    /**\n     * Get the end cell of the range.\n     * @returns {Cell} The end cell.\n     */\n  }, {\n    key: \"endCell\",\n    value: function endCell() {\n      return this._endCell;\n    }\n\n    /**\n     * Callback used by forEach.\n     * @callback Range~forEachCallback\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {undefined}\n     */\n    /**\n     * Call a function for each cell in the range. Goes by row then column.\n     * @param {Range~forEachCallback} callback - Function called for each cell in the range.\n     * @returns {Range} The range.\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      for (var ri = 0; ri < this._numRows; ri++) {\n        for (var ci = 0; ci < this._numColumns; ci++) {\n          callback(this.cell(ri, ci), ri, ci, this);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Gets the shared formula in the start cell (assuming it's the source of the shared formula).\n     * @returns {string|undefined} The shared formula.\n     */ /**\n        * Sets the shared formula in the range. The formula will be translated for each cell.\n        * @param {string} formula - The formula to set.\n        * @returns {Range} The range.\n        */\n  }, {\n    key: \"formula\",\n    value: function formula() {\n      var _this = this;\n      return new ArgHandler(\"Range.formula\").case(function () {\n        return _this.startCell().getSharedRefFormula();\n      }).case('string', function (formula) {\n        var sharedFormulaId = _this.sheet().incrementMaxSharedFormulaId();\n        _this.forEach(function (cell, ri, ci) {\n          if (ri === 0 && ci === 0) {\n            cell.setSharedFormula(sharedFormulaId, formula, _this.address());\n          } else {\n            cell.setSharedFormula(sharedFormulaId);\n          }\n        });\n        return _this;\n      }).handle(arguments);\n    }\n\n    /**\n     * Callback used by map.\n     * @callback Range~mapCallback\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {*} The value to map to.\n     */\n    /**\n     * Creates a 2D array of values by running each cell through a callback.\n     * @param {Range~mapCallback} callback - Function called for each cell in the range.\n     * @returns {Array.<Array.<*>>} The 2D array of return values.\n     */\n  }, {\n    key: \"map\",\n    value: function map(callback) {\n      var _this2 = this;\n      var result = [];\n      this.forEach(function (cell, ri, ci) {\n        if (!result[ri]) result[ri] = [];\n        result[ri][ci] = callback(cell, ri, ci, _this2);\n      });\n      return result;\n    }\n\n    /**\n     * Gets a value indicating whether the cells in the range are merged.\n     * @returns {boolean} The value.\n     */ /**\n        * Sets a value indicating whether the cells in the range should be merged.\n        * @param {boolean} merged - True to merge, false to unmerge.\n        * @returns {Range} The range.\n        */\n  }, {\n    key: \"merged\",\n    value: function merged(_merged) {\n      var _this3 = this;\n      return new ArgHandler('Range.merged').case(function () {\n        return _this3.sheet().merged(_this3.address());\n      }).case('*', function (merged) {\n        _this3.sheet().merged(_this3.address(), merged);\n        return _this3;\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets the data validation object attached to the Range.\n     * @returns {object|undefined} The data validation object or undefined if not set.\n     */ /**\n        * Set or clear the data validation object of the entire range.\n        * @param {object|undefined} dataValidation - Object or null to clear.\n        * @returns {Range} The range.\n        */\n  }, {\n    key: \"dataValidation\",\n    value: function dataValidation() {\n      var _this4 = this;\n      return new ArgHandler('Range.dataValidation').case(function () {\n        return _this4.sheet().dataValidation(_this4.address());\n      }).case('boolean', function (obj) {\n        return _this4.sheet().dataValidation(_this4.address(), obj);\n      }).case('*', function (obj) {\n        _this4.sheet().dataValidation(_this4.address(), obj);\n        return _this4;\n      }).handle(arguments);\n    }\n\n    /**\n     * Callback used by reduce.\n     * @callback Range~reduceCallback\n     * @param {*} accumulator - The accumulated value.\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {*} The value to map to.\n     */\n    /**\n     * Reduces the range to a single value accumulated from the result of a function called for each cell.\n     * @param {Range~reduceCallback} callback - Function called for each cell in the range.\n     * @param {*} [initialValue] - The initial value.\n     * @returns {*} The accumulated value.\n     */\n  }, {\n    key: \"reduce\",\n    value: function reduce(callback, initialValue) {\n      var _this5 = this;\n      var accumulator = initialValue;\n      this.forEach(function (cell, ri, ci) {\n        accumulator = callback(accumulator, cell, ri, ci, _this5);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Gets the parent sheet of the range.\n     * @returns {Sheet} The parent sheet.\n     */\n  }, {\n    key: \"sheet\",\n    value: function sheet() {\n      return this.startCell().sheet();\n    }\n\n    /**\n     * Gets the start cell of the range.\n     * @returns {Cell} The start cell.\n     */\n  }, {\n    key: \"startCell\",\n    value: function startCell() {\n      return this._startCell;\n    }\n\n    /**\n     * Gets a single style for each cell.\n     * @param {string} name - The name of the style.\n     * @returns {Array.<Array.<*>>} 2D array of style values.\n     */ /**\n        * Gets multiple styles for each cell.\n        * @param {Array.<string>} names - The names of the styles.\n        * @returns {Object.<string, Array.<Array.<*>>>} Object whose keys are style names and values are 2D arrays of style values.\n        */ /**\n           * Set the style in each cell to the result of a function called for each.\n           * @param {string} name - The name of the style.\n           * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n           * @returns {Range} The range.\n           */ /**\n              * Sets the style in each cell to the corresponding value in the given 2D array of values.\n              * @param {string} name - The name of the style.\n              * @param {Array.<Array.<*>>} values - The style values to set.\n              * @returns {Range} The range.\n              */ /**\n                 * Set the style of all cells in the range to a single style value.\n                 * @param {string} name - The name of the style.\n                 * @param {*} value - The value to set.\n                 * @returns {Range} The range.\n                 */ /**\n                    * Set multiple styles for the cells in the range.\n                    * @param {object.<string,Range~mapCallback|Array.<Array.<*>>|*>} styles - Object whose keys are style names and values are either function callbacks, 2D arrays of style values, or a single value for all the cells.\n                    * @returns {Range} The range.\n                    */ /**\n                       * Sets to a specific style\n                       * @param {Style} style - Style object given from stylesheet.createStyle\n                       * @returns {Range} The range.\n                       */\n  }, {\n    key: \"style\",\n    value: function style() {\n      var _this6 = this;\n      return new ArgHandler(\"Range.style\").case('string', function (name) {\n        // Get single value\n        return _this6.map(function (cell) {\n          return cell.style(name);\n        });\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this6.style(name);\n        });\n        return values;\n      }).case(['string', 'function'], function (name, callback) {\n        // Set a single value for the cells to the result of a function\n        return _this6.forEach(function (cell, ri, ci) {\n          cell.style(name, callback(cell, ri, ci, _this6));\n        });\n      }).case(['string', 'array'], function (name, values) {\n        // Set a single value for the cells using an array of matching dimension\n        return _this6.forEach(function (cell, ri, ci) {\n          if (values[ri] && values[ri][ci] !== undefined) {\n            cell.style(name, values[ri][ci]);\n          }\n        });\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value for all cells to a single value\n        return _this6.forEach(function (cell) {\n          return cell.style(name, value);\n        });\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n          _this6.style(name, value);\n        }\n        return _this6;\n      }).case('Style', function (style) {\n        _this6._style = style;\n        return _this6.forEach(function (cell) {\n          return cell.style(style);\n        });\n      }).handle(arguments);\n    }\n\n    /**\n     * Callback used by tap.\n     * @callback Range~tapCallback\n     * @param {Range} range - The range.\n     * @returns {undefined}\n     */\n    /**\n     * Invoke a callback on the range and return the range. Useful for method chaining.\n     * @param {Range~tapCallback} callback - The callback function.\n     * @returns {Range} The range.\n     */\n  }, {\n    key: \"tap\",\n    value: function tap(callback) {\n      callback(this);\n      return this;\n    }\n\n    /**\n     * Callback used by thru.\n     * @callback Range~thruCallback\n     * @param {Range} range - The range.\n     * @returns {*} The value to return from thru.\n     */\n    /**\n     * Invoke a callback on the range and return the value provided by the callback. Useful for method chaining.\n     * @param {Range~thruCallback} callback - The callback function.\n     * @returns {*} The return value of the callback.\n     */\n  }, {\n    key: \"thru\",\n    value: function thru(callback) {\n      return callback(this);\n    }\n\n    /**\n     * Get the values of each cell in the range as a 2D array.\n     * @returns {Array.<Array.<*>>} The values.\n     */ /**\n        * Set the values in each cell to the result of a function called for each.\n        * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n        * @returns {Range} The range.\n        */ /**\n           * Sets the value in each cell to the corresponding value in the given 2D array of values.\n           * @param {Array.<Array.<*>>} values - The values to set.\n           * @returns {Range} The range.\n           */ /**\n              * Set the value of all cells in the range to a single value.\n              * @param {*} value - The value to set.\n              * @returns {Range} The range.\n              */\n  }, {\n    key: \"value\",\n    value: function value() {\n      var _this7 = this;\n      return new ArgHandler(\"Range.value\").case(function () {\n        // Get values\n        return _this7.map(function (cell) {\n          return cell.value();\n        });\n      }).case('function', function (callback) {\n        // Set a value for the cells to the result of a function\n        return _this7.forEach(function (cell, ri, ci) {\n          cell.value(callback(cell, ri, ci, _this7));\n        });\n      }).case('array', function (values) {\n        // Set value for the cells using an array of matching dimension\n        return _this7.forEach(function (cell, ri, ci) {\n          if (values[ri] && values[ri][ci] !== undefined) {\n            cell.value(values[ri][ci]);\n          }\n        });\n      }).case('*', function (value) {\n        // Set the value for all cells to a single value\n        return _this7.forEach(function (cell) {\n          return cell.value(value);\n        });\n      }).handle(arguments);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n  }, {\n    key: \"workbook\",\n    value: function workbook() {\n      return this.sheet().workbook();\n    }\n\n    /**\n     * Find the extent of the range.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_findRangeExtent\",\n    value: function _findRangeExtent() {\n      this._minRowNumber = Math.min(this._startCell.rowNumber(), this._endCell.rowNumber());\n      this._maxRowNumber = Math.max(this._startCell.rowNumber(), this._endCell.rowNumber());\n      this._minColumnNumber = Math.min(this._startCell.columnNumber(), this._endCell.columnNumber());\n      this._maxColumnNumber = Math.max(this._startCell.columnNumber(), this._endCell.columnNumber());\n      this._numRows = this._maxRowNumber - this._minRowNumber + 1;\n      this._numColumns = this._maxColumnNumber - this._minColumnNumber + 1;\n    }\n  }]);\n  return Range;\n}();\nmodule.exports = Range;","map":{"version":3,"names":["ArgHandler","require","addressConverter","Range","startCell","endCell","_startCell","_endCell","_findRangeExtent","opts","toAddress","type","startRowNumber","rowNumber","startRowAnchored","anchored","startColumnName","columnName","startColumnAnchored","endRowNumber","endRowAnchored","endColumnName","endColumnAnchored","sheetName","includeSheetName","sheet","name","ri","ci","cell","_minRowNumber","_minColumnNumber","autoFilter","map","value","undefined","callback","_numRows","_numColumns","case","getSharedRefFormula","formula","sharedFormulaId","incrementMaxSharedFormulaId","forEach","setSharedFormula","address","handle","arguments","result","merged","dataValidation","obj","initialValue","accumulator","style","names","values","nameValues","hasOwnProperty","_style","workbook","Math","min","_maxRowNumber","max","columnNumber","_maxColumnNumber","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Range.js"],"sourcesContent":["\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n/**\n * A range of cells.\n */\nclass Range {\n    // /**\n    //  * Creates a new instance of Range.\n    //  * @param {Cell} startCell - The start cell.\n    //  * @param {Cell} endCell - The end cell.\n    //  */\n    constructor(startCell, endCell) {\n        this._startCell = startCell;\n        this._endCell = endCell;\n        this._findRangeExtent(startCell, endCell);\n    }\n\n    /**\n     * Get the address of the range.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.startRowAnchored] - Anchor the start row.\n     * @param {boolean} [opts.startColumnAnchored] - Anchor the start column.\n     * @param {boolean} [opts.endRowAnchored] - Anchor the end row.\n     * @param {boolean} [opts.endColumnAnchored] - Anchor the end column.\n     * @param {boolean} [opts.anchored] - Anchor all row and columns.\n     * @returns {string} The address.\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'range',\n            startRowNumber: this.startCell().rowNumber(),\n            startRowAnchored: opts && (opts.startRowAnchored || opts.anchored),\n            startColumnName: this.startCell().columnName(),\n            startColumnAnchored: opts && (opts.startColumnAnchored || opts.anchored),\n            endRowNumber: this.endCell().rowNumber(),\n            endRowAnchored: opts && (opts.endRowAnchored || opts.anchored),\n            endColumnName: this.endCell().columnName(),\n            endColumnAnchored: opts && (opts.endColumnAnchored || opts.anchored),\n            sheetName: opts && opts.includeSheetName && this.sheet().name()\n        });\n    }\n\n    /**\n     * Gets a cell within the range.\n     * @param {number} ri - Row index relative to the top-left corner of the range (0-based).\n     * @param {number} ci - Column index relative to the top-left corner of the range (0-based).\n     * @returns {Cell} The cell.\n     */\n    cell(ri, ci) {\n        return this.sheet().cell(this._minRowNumber + ri, this._minColumnNumber + ci);\n    }\n\n    /**\n     * Sets sheet autoFilter to this range.\n     * @returns {Range} This range.\n     */\n    autoFilter() {\n        this.sheet().autoFilter(this);\n\n        return this;\n    }\n\n    /**\n     * Get the cells in the range as a 2D array.\n     * @returns {Array.<Array.<Cell>>} The cells.\n     */\n    cells() {\n        return this.map(cell => cell);\n    }\n\n    /**\n     * Clear the contents of all the cells in the range.\n     * @returns {Range} The range.\n     */\n    clear() {\n        return this.value(undefined);\n    }\n\n    /**\n     * Get the end cell of the range.\n     * @returns {Cell} The end cell.\n     */\n    endCell() {\n        return this._endCell;\n    }\n\n    /**\n     * Callback used by forEach.\n     * @callback Range~forEachCallback\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {undefined}\n     */\n    /**\n     * Call a function for each cell in the range. Goes by row then column.\n     * @param {Range~forEachCallback} callback - Function called for each cell in the range.\n     * @returns {Range} The range.\n     */\n    forEach(callback) {\n        for (let ri = 0; ri < this._numRows; ri++) {\n            for (let ci = 0; ci < this._numColumns; ci++) {\n                callback(this.cell(ri, ci), ri, ci, this);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Gets the shared formula in the start cell (assuming it's the source of the shared formula).\n     * @returns {string|undefined} The shared formula.\n     *//**\n     * Sets the shared formula in the range. The formula will be translated for each cell.\n     * @param {string} formula - The formula to set.\n     * @returns {Range} The range.\n     */\n    formula() {\n        return new ArgHandler(\"Range.formula\")\n            .case(() => {\n                return this.startCell().getSharedRefFormula();\n            })\n            .case('string', formula => {\n                const sharedFormulaId = this.sheet().incrementMaxSharedFormulaId();\n                this.forEach((cell, ri, ci) => {\n                    if (ri === 0 && ci === 0) {\n                        cell.setSharedFormula(sharedFormulaId, formula, this.address());\n                    } else {\n                        cell.setSharedFormula(sharedFormulaId);\n                    }\n                });\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by map.\n     * @callback Range~mapCallback\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {*} The value to map to.\n     */\n    /**\n     * Creates a 2D array of values by running each cell through a callback.\n     * @param {Range~mapCallback} callback - Function called for each cell in the range.\n     * @returns {Array.<Array.<*>>} The 2D array of return values.\n     */\n    map(callback) {\n        const result = [];\n        this.forEach((cell, ri, ci) => {\n            if (!result[ri]) result[ri] = [];\n            result[ri][ci] = callback(cell, ri, ci, this);\n        });\n\n        return result;\n    }\n\n    /**\n     * Gets a value indicating whether the cells in the range are merged.\n     * @returns {boolean} The value.\n     *//**\n     * Sets a value indicating whether the cells in the range should be merged.\n     * @param {boolean} merged - True to merge, false to unmerge.\n     * @returns {Range} The range.\n     */\n    merged(merged) {\n        return new ArgHandler('Range.merged')\n            .case(() => {\n                return this.sheet().merged(this.address());\n            })\n            .case('*', merged => {\n                this.sheet().merged(this.address(), merged);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the data validation object attached to the Range.\n     * @returns {object|undefined} The data validation object or undefined if not set.\n     *//**\n     * Set or clear the data validation object of the entire range.\n     * @param {object|undefined} dataValidation - Object or null to clear.\n     * @returns {Range} The range.\n     */\n    dataValidation() {\n        return new ArgHandler('Range.dataValidation')\n            .case(() => {\n                return this.sheet().dataValidation(this.address());\n            })\n            .case('boolean', obj => {\n                return this.sheet().dataValidation(this.address(), obj);\n            })\n            .case('*', obj => {\n                this.sheet().dataValidation(this.address(), obj);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by reduce.\n     * @callback Range~reduceCallback\n     * @param {*} accumulator - The accumulated value.\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {*} The value to map to.\n     */\n    /**\n     * Reduces the range to a single value accumulated from the result of a function called for each cell.\n     * @param {Range~reduceCallback} callback - Function called for each cell in the range.\n     * @param {*} [initialValue] - The initial value.\n     * @returns {*} The accumulated value.\n     */\n    reduce(callback, initialValue) {\n        let accumulator = initialValue;\n        this.forEach((cell, ri, ci) => {\n            accumulator = callback(accumulator, cell, ri, ci, this);\n        });\n\n        return accumulator;\n    }\n\n    /**\n     * Gets the parent sheet of the range.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this.startCell().sheet();\n    }\n\n    /**\n     * Gets the start cell of the range.\n     * @returns {Cell} The start cell.\n     */\n    startCell() {\n        return this._startCell;\n    }\n\n    /**\n     * Gets a single style for each cell.\n     * @param {string} name - The name of the style.\n     * @returns {Array.<Array.<*>>} 2D array of style values.\n     *//**\n     * Gets multiple styles for each cell.\n     * @param {Array.<string>} names - The names of the styles.\n     * @returns {Object.<string, Array.<Array.<*>>>} Object whose keys are style names and values are 2D arrays of style values.\n     *//**\n     * Set the style in each cell to the result of a function called for each.\n     * @param {string} name - The name of the style.\n     * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n     * @returns {Range} The range.\n     *//**\n     * Sets the style in each cell to the corresponding value in the given 2D array of values.\n     * @param {string} name - The name of the style.\n     * @param {Array.<Array.<*>>} values - The style values to set.\n     * @returns {Range} The range.\n     *//**\n     * Set the style of all cells in the range to a single style value.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Range} The range.\n     *//**\n     * Set multiple styles for the cells in the range.\n     * @param {object.<string,Range~mapCallback|Array.<Array.<*>>|*>} styles - Object whose keys are style names and values are either function callbacks, 2D arrays of style values, or a single value for all the cells.\n     * @returns {Range} The range.\n     *//**\n\t * Sets to a specific style\n\t * @param {Style} style - Style object given from stylesheet.createStyle\n\t * @returns {Range} The range.\n\t */\n    style() {\n        return new ArgHandler(\"Range.style\")\n            .case('string', name => {\n                // Get single value\n                return this.map(cell => cell.style(name));\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case(['string', 'function'], (name, callback) => {\n                // Set a single value for the cells to the result of a function\n                return this.forEach((cell, ri, ci) => {\n                    cell.style(name, callback(cell, ri, ci, this));\n                });\n            })\n            .case(['string', 'array'], (name, values) => {\n                // Set a single value for the cells using an array of matching dimension\n                return this.forEach((cell, ri, ci) => {\n                    if (values[ri] && values[ri][ci] !== undefined) {\n                        cell.style(name, values[ri][ci]);\n                    }\n                });\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                return this.forEach(cell => cell.style(name, value));\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                this._style = style;\n                return this.forEach(cell => cell.style(style));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by tap.\n     * @callback Range~tapCallback\n     * @param {Range} range - The range.\n     * @returns {undefined}\n     */\n    /**\n     * Invoke a callback on the range and return the range. Useful for method chaining.\n     * @param {Range~tapCallback} callback - The callback function.\n     * @returns {Range} The range.\n     */\n    tap(callback) {\n        callback(this);\n        return this;\n    }\n\n    /**\n     * Callback used by thru.\n     * @callback Range~thruCallback\n     * @param {Range} range - The range.\n     * @returns {*} The value to return from thru.\n     */\n    /**\n     * Invoke a callback on the range and return the value provided by the callback. Useful for method chaining.\n     * @param {Range~thruCallback} callback - The callback function.\n     * @returns {*} The return value of the callback.\n     */\n    thru(callback) {\n        return callback(this);\n    }\n\n    /**\n     * Get the values of each cell in the range as a 2D array.\n     * @returns {Array.<Array.<*>>} The values.\n     *//**\n     * Set the values in each cell to the result of a function called for each.\n     * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n     * @returns {Range} The range.\n     *//**\n     * Sets the value in each cell to the corresponding value in the given 2D array of values.\n     * @param {Array.<Array.<*>>} values - The values to set.\n     * @returns {Range} The range.\n     *//**\n     * Set the value of all cells in the range to a single value.\n     * @param {*} value - The value to set.\n     * @returns {Range} The range.\n     */\n    value() {\n        return new ArgHandler(\"Range.value\")\n            .case(() => {\n                // Get values\n                return this.map(cell => cell.value());\n            })\n            .case('function', callback => {\n                // Set a value for the cells to the result of a function\n                return this.forEach((cell, ri, ci) => {\n                    cell.value(callback(cell, ri, ci, this));\n                });\n            })\n            .case('array', values => {\n                // Set value for the cells using an array of matching dimension\n                return this.forEach((cell, ri, ci) => {\n                    if (values[ri] && values[ri][ci] !== undefined) {\n                        cell.value(values[ri][ci]);\n                    }\n                });\n            })\n            .case('*', value => {\n                // Set the value for all cells to a single value\n                return this.forEach(cell => cell.value(value));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.sheet().workbook();\n    }\n\n    /**\n     * Find the extent of the range.\n     * @returns {undefined}\n     * @private\n     */\n    _findRangeExtent() {\n        this._minRowNumber = Math.min(this._startCell.rowNumber(), this._endCell.rowNumber());\n        this._maxRowNumber = Math.max(this._startCell.rowNumber(), this._endCell.rowNumber());\n        this._minColumnNumber = Math.min(this._startCell.columnNumber(), this._endCell.columnNumber());\n        this._maxColumnNumber = Math.max(this._startCell.columnNumber(), this._endCell.columnNumber());\n        this._numRows = this._maxRowNumber - this._minRowNumber + 1;\n        this._numColumns = this._maxColumnNumber - this._minColumnNumber + 1;\n    }\n}\n\nmodule.exports = Range;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}