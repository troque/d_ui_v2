{"ast":null,"code":"\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\nconst _ = require(\"lodash\");\nconst cfb = require(\"cfb\");\nconst crypto = require(\"crypto\");\nconst externals = require(\"./externals\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst xmlq = require(\"./xmlq\");\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nconst BLOCK_KEYS = {\n  dataIntegrity: {\n    hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n    hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n  },\n  key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n  verifierHash: {\n    input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n    value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n  }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nclass Encryptor {\n  /**\n   * Encrypt the data with the password.\n   * @param {Buffer} data - The data to encrypt\n   * @param {string} password - The password\n   * @returns {Buffer} The encrypted data\n   */\n  encrypt(data, password) {\n    // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n    // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n    const packageKey = crypto.randomBytes(32);\n\n    // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n    const encryptionInfo = {\n      package: {\n        // Info on the encryption of the package.\n        cipherAlgorithm: 'AES',\n        // Cipher algorithm to use. Excel uses AES.\n        cipherChaining: 'ChainingModeCBC',\n        // Cipher chaining mode to use. Excel uses CBC.\n        saltValue: crypto.randomBytes(16),\n        // Random value to use as encryption salt. Excel uses 16 bytes.\n        hashAlgorithm: 'SHA512',\n        // Hash algorithm to use. Excel uses SHA512.\n        hashSize: 64,\n        // The size of the hash in bytes. SHA512 results in 64-byte hashes\n        blockSize: 16,\n        // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n        keyBits: packageKey.length * 8 // The number of bits in the package key.\n      },\n\n      key: {\n        // Info on the encryption of the package key.\n        cipherAlgorithm: 'AES',\n        // Cipher algorithm to use. Excel uses AES.\n        cipherChaining: 'ChainingModeCBC',\n        // Cipher chaining mode to use. Excel uses CBC.\n        saltValue: crypto.randomBytes(16),\n        // Random value to use as encryption salt. Excel uses 16 bytes.\n        hashAlgorithm: 'SHA512',\n        // Hash algorithm to use. Excel uses SHA512.\n        hashSize: 64,\n        // The size of the hash in bytes. SHA512 results in 64-byte hashes\n        blockSize: 16,\n        // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n        spinCount: 100000,\n        // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n        keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n      }\n    };\n\n    /* Package Encryption */\n\n    // Encrypt package using the package key.\n    const encryptedPackage = this._cryptPackage(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, data);\n\n    /* Data Integrity */\n\n    // Create the data integrity fields used by clients for integrity checks.\n    // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n    const hmacKey = crypto.randomBytes(64);\n\n    // Then create an initialization vector using the package encryption info and the appropriate block key.\n    const hmacKeyIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacKey);\n\n    // Use the package key and the IV to encrypt the HMAC key\n    const encryptedHmacKey = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacKeyIV, hmacKey);\n\n    // Now create the HMAC\n    const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n    // Next generate an initialization vector for encrypting the resulting HMAC value.\n    const hmacValueIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacValue);\n\n    // Now encrypt the value\n    const encryptedHmacValue = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacValueIV, hmacValue);\n\n    // Put the encrypted key and value on the encryption info\n    encryptionInfo.dataIntegrity = {\n      encryptedHmacKey,\n      encryptedHmacValue\n    };\n\n    /* Key Encryption */\n\n    // Convert the password to an encryption key\n    const key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key);\n\n    // Encrypt the package key with the\n    encryptionInfo.key.encryptedKeyValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, packageKey);\n\n    /* Verifier hash */\n\n    // Create a random byte array for hashing\n    const verifierHashInput = crypto.randomBytes(16);\n\n    // Create an encryption key from the password for the input\n    const verifierHashInputKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.input);\n\n    // Use the key to encrypt the verifier input\n    encryptionInfo.key.encryptedVerifierHashInput = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashInputKey, encryptionInfo.key.saltValue, verifierHashInput);\n\n    // Create a hash of the input\n    const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n    // Create an encryption key from the password for the hash\n    const verifierHashValueKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.value);\n\n    // Use the key to encrypt the hash value\n    encryptionInfo.key.encryptedVerifierHashValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashValueKey, encryptionInfo.key.saltValue, verifierHashValue);\n\n    // Build the encryption info buffer\n    const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n    // Create a new CFB\n    let output = cfb.utils.cfb_new();\n\n    // Add the encryption info and encrypted package\n    cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n    cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n    // Delete the SheetJS entry that is added at initialization\n    cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\");\n\n    // Write to a buffer and return\n    output = cfb.write(output);\n\n    // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n    if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n    return output;\n  }\n\n  /**\n   * Decrypt the data with the given password\n   * @param {Buffer} data - The data to decrypt\n   * @param {string} password - The password\n   * @returns {Promise.<Buffer>} The decrypted data\n   */\n  decryptAsync(data, password) {\n    // Parse the CFB input and pull out the encryption info and encrypted package entries.\n    const parsed = cfb.parse(data);\n    let encryptionInfoBuffer = _.find(parsed.FileIndex, {\n      name: \"EncryptionInfo\"\n    }).content;\n    let encryptedPackageBuffer = _.find(parsed.FileIndex, {\n      name: \"EncryptedPackage\"\n    }).content;\n\n    // In the browser the CFB content is an array. Convert to a Buffer.\n    if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n    if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n    return externals.Promise.resolve().then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n    .then(encryptionInfo => {\n      // Convert the password into an encryption key\n      const key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key);\n\n      // Use the key to decrypt the package key\n      const packageKey = this._crypt(false, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, encryptionInfo.key.encryptedKeyValue);\n\n      // Use the package key to decrypt the package\n      return this._cryptPackage(false, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, encryptedPackageBuffer);\n    });\n  }\n\n  /**\n   * Build the encryption info XML/buffer\n   * @param {{}} encryptionInfo - The encryption info object\n   * @returns {Buffer} The buffer\n   * @private\n   */\n  _buildEncryptionInfo(encryptionInfo) {\n    // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n    const encryptionInfoNode = {\n      name: \"encryption\",\n      attributes: {\n        xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n        'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n        'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n      },\n      children: [{\n        name: \"keyData\",\n        attributes: {\n          saltSize: encryptionInfo.package.saltValue.length,\n          blockSize: encryptionInfo.package.blockSize,\n          keyBits: encryptionInfo.package.keyBits,\n          hashSize: encryptionInfo.package.hashSize,\n          cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n          cipherChaining: encryptionInfo.package.cipherChaining,\n          hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n          saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n        }\n      }, {\n        name: \"dataIntegrity\",\n        attributes: {\n          encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n          encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n        }\n      }, {\n        name: \"keyEncryptors\",\n        children: [{\n          name: \"keyEncryptor\",\n          attributes: {\n            uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n          },\n          children: [{\n            name: \"p:encryptedKey\",\n            attributes: {\n              spinCount: encryptionInfo.key.spinCount,\n              saltSize: encryptionInfo.key.saltValue.length,\n              blockSize: encryptionInfo.key.blockSize,\n              keyBits: encryptionInfo.key.keyBits,\n              hashSize: encryptionInfo.key.hashSize,\n              cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n              cipherChaining: encryptionInfo.key.cipherChaining,\n              hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n              saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n              encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n              encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n              encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n            }\n          }]\n        }]\n      }]\n    };\n\n    // Convert to an XML string\n    const xmlBuilder = new XmlBuilder();\n    const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n    // Convert to a buffer and prefix with the appropriate bytes\n    return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n  }\n\n  /**\n   * Parse the encryption info from the XML/buffer\n   * @param {Buffer} buffer - The buffer\n   * @returns {Promise.<{}>} The parsed encryption info object\n   * @private\n   */\n  _parseEncryptionInfoAsync(buffer) {\n    // Pull off the prefix and convert to string\n    const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n    // Parse the XML\n    const xmlParser = new XmlParser();\n    return xmlParser.parseAsync(xml).then(doc => {\n      // Pull out the relevant values for decryption and return\n      const keyDataNode = xmlq.findChild(doc, \"keyData\");\n      const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n      const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n      const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n      return {\n        package: {\n          cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n          cipherChaining: keyDataNode.attributes.cipherChaining,\n          saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n          hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n          blockSize: keyDataNode.attributes.blockSize\n        },\n        key: {\n          encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n          cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n          cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n          saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n          hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n          spinCount: encryptedKeyNode.attributes.spinCount,\n          keyBits: encryptedKeyNode.attributes.keyBits\n        }\n      };\n    });\n  }\n\n  /**\n   * Calculate a hash of the concatenated buffers with the given algorithm.\n   * @param {string} algorithm - The hash algorithm.\n   * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n   * @returns {Buffer} The hash\n   * @private\n   */\n  _hash(algorithm) {\n    algorithm = algorithm.toLowerCase();\n    const hashes = crypto.getHashes();\n    if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n    const hash = crypto.createHash(algorithm);\n    for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      buffers[_key - 1] = arguments[_key];\n    }\n    hash.update(Buffer.concat(buffers));\n    return hash.digest();\n  }\n\n  /**\n   * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n   * @param {string} algorithm - The algorithm.\n   * @param {string} key - The key\n   * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n   * @returns {Buffer} The HMAC\n   * @private\n   */\n  _hmac(algorithm, key) {\n    algorithm = algorithm.toLowerCase();\n    const hashes = crypto.getHashes();\n    if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n    const hmac = crypto.createHmac(algorithm, key);\n    for (var _len2 = arguments.length, buffers = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      buffers[_key2 - 2] = arguments[_key2];\n    }\n    hmac.update(Buffer.concat(buffers));\n    return hmac.digest();\n  }\n\n  /**\n   * Encrypt/decrypt input\n   * @param {boolean} encrypt - True to encrypt, false to decrypt\n   * @param {string} cipherAlgorithm - The cipher algorithm\n   * @param {sring} cipherChaining - The cipher chaining mode\n   * @param {Buffer} key - The encryption key\n   * @param {Buffer} iv - The initialization vector\n   * @param {Buffer} input - The input\n   * @returns {Buffer} The output\n   * @private\n   */\n  _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n    let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n    if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n    const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n    cipher.setAutoPadding(false);\n    let output = cipher.update(input);\n    output = Buffer.concat([output, cipher.final()]);\n    return output;\n  }\n\n  /**\n   * Encrypt/decrypt the package\n   * @param {boolean} encrypt - True to encrypt, false to decrypt\n   * @param {string} cipherAlgorithm - The cipher algorithm\n   * @param {string} cipherChaining - The cipher chaining mode\n   * @param {string} hashAlgorithm - The hash algorithm\n   * @param {number} blockSize - The IV block size\n   * @param {Buffer} saltValue - The salt\n   * @param {Buffer} key - The encryption key\n   * @param {Buffer} input - The package input\n   * @returns {Buffer} The output\n   * @private\n   */\n  _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n    // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n    const outputChunks = [];\n    const offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n    // The package is encoded in chunks. Encrypt/decrypt each and concat.\n    let i = 0,\n      start = 0,\n      end = 0;\n    while (end < input.length) {\n      start = end;\n      end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n      if (end > input.length) end = input.length;\n\n      // Grab the next chunk\n      let inputChunk = input.slice(start + offset, end + offset);\n\n      // Pad the chunk if it is not an integer multiple of the block size\n      const remainder = inputChunk.length % blockSize;\n      if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n      // Create the initialization vector\n      const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n      // Encrypt/decrypt the chunk and add it to the array\n      const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n      outputChunks.push(outputChunk);\n      i++;\n    }\n\n    // Concat all of the output chunks.\n    let output = Buffer.concat(outputChunks);\n    if (encrypt) {\n      // Put the length of the package in the first 8 bytes\n      output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n    } else {\n      // Truncate the buffer to the size in the prefix\n      const length = input.readUInt32LE(0);\n      output = output.slice(0, length);\n    }\n    return output;\n  }\n\n  /**\n   * Create a buffer of an integer encoded as a uint32le\n   * @param {number} value - The integer to encode\n   * @param {number} [bufferSize=4] The output buffer size in bytes\n   * @returns {Buffer} The buffer\n   * @private\n   */\n  _createUInt32LEBuffer(value) {\n    let bufferSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n    const buffer = Buffer.alloc(bufferSize);\n    buffer.writeUInt32LE(value, 0);\n    return buffer;\n  }\n\n  /**\n   * Convert a password into an encryption key\n   * @param {string} password - The password\n   * @param {string} hashAlgorithm - The hash algoritm\n   * @param {Buffer} saltValue - The salt value\n   * @param {number} spinCount - The spin count\n   * @param {number} keyBits - The length of the key in bits\n   * @param {Buffer} blockKey - The block key\n   * @returns {Buffer} The encryption key\n   * @private\n   */\n  _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n    // Password must be in unicode buffer\n    const passwordBuffer = Buffer.from(password, 'utf16le');\n\n    // Generate the initial hash\n    let key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n    // Now regenerate until spin count\n    for (let i = 0; i < spinCount; i++) {\n      const iterator = this._createUInt32LEBuffer(i);\n      key = this._hash(hashAlgorithm, iterator, key);\n    }\n\n    // Now generate the final hash\n    key = this._hash(hashAlgorithm, key, blockKey);\n\n    // Truncate or pad as needed to get to length of keyBits\n    const keyBytes = keyBits / 8;\n    if (key.length < keyBytes) {\n      const tmp = Buffer.alloc(keyBytes, 0x36);\n      key.copy(tmp);\n      key = tmp;\n    } else if (key.length > keyBytes) {\n      key = key.slice(0, keyBytes);\n    }\n    return key;\n  }\n\n  /**\n   * Create an initialization vector (IV)\n   * @param {string} hashAlgorithm - The hash algorithm\n   * @param {Buffer} saltValue - The salt value\n   * @param {number} blockSize - The size of the IV\n   * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n   * @returns {Buffer} The IV\n   * @private\n   */\n  _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n    // Create the block key from the current index\n    if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n    // Create the initialization vector by hashing the salt with the block key.\n    // Truncate or pad as needed to meet the block size.\n    let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n    if (iv.length < blockSize) {\n      const tmp = Buffer.alloc(blockSize, 0x36);\n      iv.copy(tmp);\n      iv = tmp;\n    } else if (iv.length > blockSize) {\n      iv = iv.slice(0, blockSize);\n    }\n    return iv;\n  }\n}\nmodule.exports = Encryptor;","map":{"version":3,"names":["_","require","cfb","crypto","externals","XmlParser","XmlBuilder","xmlq","ENCRYPTION_INFO_PREFIX","Buffer","from","PACKAGE_ENCRYPTION_CHUNK_SIZE","PACKAGE_OFFSET","BLOCK_KEYS","dataIntegrity","hmacKey","hmacValue","key","verifierHash","input","value","Encryptor","encrypt","data","password","packageKey","randomBytes","encryptionInfo","package","cipherAlgorithm","cipherChaining","saltValue","hashAlgorithm","hashSize","blockSize","keyBits","length","spinCount","encryptedPackage","_cryptPackage","hmacKeyIV","_createIV","encryptedHmacKey","_crypt","_hmac","hmacValueIV","encryptedHmacValue","_convertPasswordToKey","encryptedKeyValue","verifierHashInput","verifierHashInputKey","encryptedVerifierHashInput","verifierHashValue","_hash","verifierHashValueKey","encryptedVerifierHashValue","encryptionInfoBuffer","_buildEncryptionInfo","output","utils","cfb_new","cfb_add","cfb_del","write","isBuffer","decryptAsync","parsed","parse","find","FileIndex","name","content","encryptedPackageBuffer","Promise","resolve","then","_parseEncryptionInfoAsync","encryptionInfoNode","attributes","xmlns","children","saltSize","toString","uri","xmlBuilder","encryptionInfoXml","build","concat","buffer","xml","slice","xmlParser","parseAsync","doc","keyDataNode","findChild","keyEncryptorsNode","keyEncryptorNode","encryptedKeyNode","algorithm","toLowerCase","hashes","getHashes","indexOf","Error","hash","createHash","buffers","update","digest","hmac","createHmac","iv","cipher","setAutoPadding","final","outputChunks","offset","i","start","end","inputChunk","remainder","alloc","outputChunk","push","_createUInt32LEBuffer","readUInt32LE","bufferSize","writeUInt32LE","blockKey","passwordBuffer","iterator","keyBytes","tmp","copy","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Encryptor.js"],"sourcesContent":["\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nconst _ = require(\"lodash\");\nconst cfb = require(\"cfb\");\nconst crypto = require(\"crypto\");\nconst externals = require(\"./externals\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst xmlq = require(\"./xmlq\");\n\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nconst BLOCK_KEYS = {\n    dataIntegrity: {\n        hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n        hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n    },\n    key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n    verifierHash: {\n        input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n        value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n    }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nclass Encryptor {\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    encrypt(data, password) {\n        // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n        // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n        const packageKey = crypto.randomBytes(32);\n\n        // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n        const encryptionInfo = {\n            package: { // Info on the encryption of the package.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                keyBits: packageKey.length * 8 // The number of bits in the package key.\n            },\n            key: { // Info on the encryption of the package key.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                spinCount: 100000, // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n                keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n            }\n        };\n\n        /* Package Encryption */\n\n        // Encrypt package using the package key.\n        const encryptedPackage = this._cryptPackage(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.blockSize,\n            encryptionInfo.package.saltValue,\n            packageKey,\n            data\n        );\n\n        /* Data Integrity */\n\n        // Create the data integrity fields used by clients for integrity checks.\n        // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n        const hmacKey = crypto.randomBytes(64);\n\n        // Then create an initialization vector using the package encryption info and the appropriate block key.\n        const hmacKeyIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacKey\n        );\n\n        // Use the package key and the IV to encrypt the HMAC key\n        const encryptedHmacKey = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacKeyIV,\n            hmacKey);\n\n        // Now create the HMAC\n        const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n        // Next generate an initialization vector for encrypting the resulting HMAC value.\n        const hmacValueIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacValue\n        );\n\n        // Now encrypt the value\n        const encryptedHmacValue = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacValueIV,\n            hmacValue\n        );\n\n        // Put the encrypted key and value on the encryption info\n        encryptionInfo.dataIntegrity = {\n            encryptedHmacKey,\n            encryptedHmacValue\n        };\n\n        /* Key Encryption */\n\n        // Convert the password to an encryption key\n        const key = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.key\n        );\n\n        // Encrypt the package key with the\n        encryptionInfo.key.encryptedKeyValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            key,\n            encryptionInfo.key.saltValue,\n            packageKey);\n\n        /* Verifier hash */\n\n        // Create a random byte array for hashing\n        const verifierHashInput = crypto.randomBytes(16);\n\n        // Create an encryption key from the password for the input\n        const verifierHashInputKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.input\n        );\n\n        // Use the key to encrypt the verifier input\n        encryptionInfo.key.encryptedVerifierHashInput = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashInputKey,\n            encryptionInfo.key.saltValue,\n            verifierHashInput\n        );\n\n        // Create a hash of the input\n        const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n        // Create an encryption key from the password for the hash\n        const verifierHashValueKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.value\n        );\n\n        // Use the key to encrypt the hash value\n        encryptionInfo.key.encryptedVerifierHashValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashValueKey,\n            encryptionInfo.key.saltValue,\n            verifierHashValue\n        );\n\n        // Build the encryption info buffer\n        const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n        // Create a new CFB\n        let output = cfb.utils.cfb_new();\n\n        // Add the encryption info and encrypted package\n        cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n        cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n        // Delete the SheetJS entry that is added at initialization\n        cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\");\n\n        // Write to a buffer and return\n        output = cfb.write(output);\n\n        // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n        if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n\n        return output;\n    }\n\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n    decryptAsync(data, password) {\n        // Parse the CFB input and pull out the encryption info and encrypted package entries.\n        const parsed = cfb.parse(data);\n        let encryptionInfoBuffer = _.find(parsed.FileIndex, { name: \"EncryptionInfo\" }).content;\n        let encryptedPackageBuffer = _.find(parsed.FileIndex, { name: \"EncryptedPackage\" }).content;\n\n        // In the browser the CFB content is an array. Convert to a Buffer.\n        if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n        if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n\n        return externals.Promise.resolve()\n            .then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n            .then(encryptionInfo => {\n                // Convert the password into an encryption key\n                const key = this._convertPasswordToKey(\n                    password,\n                    encryptionInfo.key.hashAlgorithm,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.spinCount,\n                    encryptionInfo.key.keyBits,\n                    BLOCK_KEYS.key\n                );\n\n                // Use the key to decrypt the package key\n                const packageKey = this._crypt(\n                    false,\n                    encryptionInfo.key.cipherAlgorithm,\n                    encryptionInfo.key.cipherChaining,\n                    key,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.encryptedKeyValue\n                );\n\n                // Use the package key to decrypt the package\n                return this._cryptPackage(\n                    false,\n                    encryptionInfo.package.cipherAlgorithm,\n                    encryptionInfo.package.cipherChaining,\n                    encryptionInfo.package.hashAlgorithm,\n                    encryptionInfo.package.blockSize,\n                    encryptionInfo.package.saltValue,\n                    packageKey,\n                    encryptedPackageBuffer);\n            });\n    }\n\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _buildEncryptionInfo(encryptionInfo) {\n        // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n        const encryptionInfoNode = {\n            name: \"encryption\",\n            attributes: {\n                xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n                'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n                'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n            },\n            children: [\n                {\n                    name: \"keyData\",\n                    attributes: {\n                        saltSize: encryptionInfo.package.saltValue.length,\n                        blockSize: encryptionInfo.package.blockSize,\n                        keyBits: encryptionInfo.package.keyBits,\n                        hashSize: encryptionInfo.package.hashSize,\n                        cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n                        cipherChaining: encryptionInfo.package.cipherChaining,\n                        hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n                        saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"dataIntegrity\",\n                    attributes: {\n                        encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n                        encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"keyEncryptors\",\n                    children: [\n                        {\n                            name: \"keyEncryptor\",\n                            attributes: {\n                                uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n                            },\n                            children: [\n                                {\n                                    name: \"p:encryptedKey\",\n                                    attributes: {\n                                        spinCount: encryptionInfo.key.spinCount,\n                                        saltSize: encryptionInfo.key.saltValue.length,\n                                        blockSize: encryptionInfo.key.blockSize,\n                                        keyBits: encryptionInfo.key.keyBits,\n                                        hashSize: encryptionInfo.key.hashSize,\n                                        cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                                        cipherChaining: encryptionInfo.key.cipherChaining,\n                                        hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                                        saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                                        encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                                        encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                                        encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n                                    }\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        };\n\n        // Convert to an XML string\n        const xmlBuilder = new XmlBuilder();\n        const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n        // Convert to a buffer and prefix with the appropriate bytes\n        return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n    _parseEncryptionInfoAsync(buffer) {\n        // Pull off the prefix and convert to string\n        const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n        // Parse the XML\n        const xmlParser = new XmlParser();\n        return xmlParser.parseAsync(xml)\n            .then(doc => {\n                // Pull out the relevant values for decryption and return\n                const keyDataNode = xmlq.findChild(doc, \"keyData\");\n                const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n                const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n                const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n\n                return {\n                    package: {\n                        cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n                        cipherChaining: keyDataNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n                        blockSize: keyDataNode.attributes.blockSize\n                    },\n                    key: {\n                        encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n                        cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n                        cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n                        spinCount: encryptedKeyNode.attributes.spinCount,\n                        keyBits: encryptedKeyNode.attributes.keyBits\n                    }\n                };\n            });\n    }\n\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n    _hash(algorithm, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n\n        const hash = crypto.createHash(algorithm);\n        hash.update(Buffer.concat(buffers));\n        return hash.digest();\n    }\n\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n    _hmac(algorithm, key, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n\n        const hmac = crypto.createHmac(algorithm, key);\n        hmac.update(Buffer.concat(buffers));\n        return hmac.digest();\n    }\n\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n        let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n        if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';\n        else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n\n        const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n        cipher.setAutoPadding(false);\n        let output = cipher.update(input);\n        output = Buffer.concat([output, cipher.final()]);\n        return output;\n    }\n\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n        // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n        const outputChunks = [];\n        const offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n        // The package is encoded in chunks. Encrypt/decrypt each and concat.\n        let i = 0, start = 0, end = 0;\n        while (end < input.length) {\n            start = end;\n            end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n            if (end > input.length) end = input.length;\n\n            // Grab the next chunk\n            let inputChunk = input.slice(start + offset, end + offset);\n\n            // Pad the chunk if it is not an integer multiple of the block size\n            const remainder = inputChunk.length % blockSize;\n            if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n            // Create the initialization vector\n            const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n            // Encrypt/decrypt the chunk and add it to the array\n            const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n            outputChunks.push(outputChunk);\n\n            i++;\n        }\n\n        // Concat all of the output chunks.\n        let output = Buffer.concat(outputChunks);\n\n        if (encrypt) {\n            // Put the length of the package in the first 8 bytes\n            output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n        } else {\n            // Truncate the buffer to the size in the prefix\n            const length = input.readUInt32LE(0);\n            output = output.slice(0, length);\n        }\n\n        return output;\n    }\n\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _createUInt32LEBuffer(value, bufferSize = 4) {\n        const buffer = Buffer.alloc(bufferSize);\n        buffer.writeUInt32LE(value, 0);\n        return buffer;\n    }\n\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n    _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n        // Password must be in unicode buffer\n        const passwordBuffer = Buffer.from(password, 'utf16le');\n\n        // Generate the initial hash\n        let key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n        // Now regenerate until spin count\n        for (let i = 0; i < spinCount; i++) {\n            const iterator = this._createUInt32LEBuffer(i);\n            key = this._hash(hashAlgorithm, iterator, key);\n        }\n\n        // Now generate the final hash\n        key = this._hash(hashAlgorithm, key, blockKey);\n\n        // Truncate or pad as needed to get to length of keyBits\n        const keyBytes = keyBits / 8;\n        if (key.length < keyBytes) {\n            const tmp = Buffer.alloc(keyBytes, 0x36);\n            key.copy(tmp);\n            key = tmp;\n        } else if (key.length > keyBytes) {\n            key = key.slice(0, keyBytes);\n        }\n\n        return key;\n    }\n\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n    _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n        // Create the block key from the current index\n        if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n        // Create the initialization vector by hashing the salt with the block key.\n        // Truncate or pad as needed to meet the block size.\n        let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n        if (iv.length < blockSize) {\n            const tmp = Buffer.alloc(blockSize, 0x36);\n            iv.copy(tmp);\n            iv = tmp;\n        } else if (iv.length > blockSize) {\n            iv = iv.slice(0, blockSize);\n        }\n\n        return iv;\n    }\n}\n\nmodule.exports = Encryptor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}