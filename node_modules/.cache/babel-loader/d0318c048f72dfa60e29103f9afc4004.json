{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _ = require(\"lodash\");\nvar fs = require(\"fs\");\nvar JSZip = require('jszip');\nvar externals = require(\"./externals\");\nvar regexify = require(\"./regexify\");\nvar blank = require(\"./blank\")();\nvar xmlq = require(\"./xmlq\");\nvar Sheet = require(\"./Sheet\");\nvar ContentTypes = require(\"./ContentTypes\");\nvar AppProperties = require(\"./AppProperties\");\nvar CoreProperties = require(\"./CoreProperties\");\nvar Relationships = require(\"./Relationships\");\nvar SharedStrings = require(\"./SharedStrings\");\nvar StyleSheet = require(\"./StyleSheet\");\nvar Encryptor = require(\"./Encryptor\");\nvar XmlParser = require(\"./XmlParser\");\nvar XmlBuilder = require(\"./XmlBuilder\");\nvar ArgHandler = require(\"./ArgHandler\");\nvar addressConverter = require(\"./addressConverter\");\n\n// Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\nvar zipFileOpts = {\n  date: new Date(0),\n  createFolders: false\n};\n\n// Initialize the parser and builder.\nvar xmlParser = new XmlParser();\nvar xmlBuilder = new XmlBuilder();\n\n// Initialize the encryptor if present (can be excluded in browser build).\nvar encryptor = typeof Encryptor === \"function\" && new Encryptor();\n\n// Characters not allowed in sheet names.\nvar badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?'];\n\n// Excel limits sheet names to 31 chars.\nvar maxSheetNameLength = 31;\n\n// Order of the nodes as defined by the spec.\nvar nodeOrder = [\"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\", \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\", \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"];\n\n/**\n * A workbook.\n */\nvar Workbook = /*#__PURE__*/function () {\n  function Workbook() {\n    _classCallCheck(this, Workbook);\n  }\n  _createClass(Workbook, [{\n    key: \"activeSheet\",\n    value:\n    /**\n     * Get the active sheet in the workbook.\n     * @returns {Sheet} The active sheet.\n     */ /**\n        * Set the active sheet in the workbook.\n        * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n        * @returns {Workbook} The workbook.\n        */\n    function activeSheet() {\n      var _this = this;\n      return new ArgHandler('Workbook.activeSheet').case(function () {\n        return _this._activeSheet;\n      }).case('*', function (sheet) {\n        // Get the sheet from name/index if needed.\n        if (!(sheet instanceof Sheet)) sheet = _this.sheet(sheet);\n\n        // Check if the sheet is hidden.\n        if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\");\n\n        // Deselect all sheets except the active one (mirroring ying Excel behavior).\n        _.forEach(_this._sheets, function (current) {\n          current.tabSelected(current === sheet);\n        });\n        _this._activeSheet = sheet;\n        return _this;\n      }).handle(arguments);\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n  }, {\n    key: \"addSheet\",\n    value: function addSheet(name, indexOrBeforeSheet) {\n      return this._addSheet(name, indexOrBeforeSheet);\n    }\n\n    /**\n     * Gets a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     */ /**\n        * Set a defined name scoped to the workbook.\n        * @param {string} name - The defined name.\n        * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n        * @returns {Workbook} The workbook.\n        */\n  }, {\n    key: \"definedName\",\n    value: function definedName() {\n      var _this2 = this;\n      return new ArgHandler(\"Workbook.definedName\").case('string', function (name) {\n        return _this2.scopedDefinedName(undefined, name);\n      }).case(['string', '*'], function (name, refersTo) {\n        _this2.scopedDefinedName(undefined, name, refersTo);\n        return _this2;\n      }).handle(arguments);\n    }\n\n    /**\n     * Delete a sheet from the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @returns {Workbook} The workbook.\n     */\n  }, {\n    key: \"deleteSheet\",\n    value: function deleteSheet(sheet) {\n      // Get the sheet to move.\n      if (!(sheet instanceof Sheet)) {\n        sheet = this.sheet(sheet);\n        if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n      }\n\n      // Make sure we are not deleting the only visible sheet.\n      var visibleSheets = _.filter(this._sheets, function (sheet) {\n        return !sheet.hidden();\n      });\n      if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n        throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n      }\n\n      // Remove the sheet.\n      var index = this._sheets.indexOf(sheet);\n      this._sheets.splice(index, 1);\n\n      // Set the new active sheet.\n      if (sheet === this.activeSheet()) {\n        if (index >= this._sheets.length) index--;\n        this.activeSheet(index);\n      }\n      return this;\n    }\n\n    /**\n     * Find the given pattern in the workbook and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n  }, {\n    key: \"find\",\n    value: function find(pattern, replacement) {\n      pattern = regexify(pattern);\n      var matches = [];\n      this._sheets.forEach(function (sheet) {\n        matches = matches.concat(sheet.find(pattern, replacement));\n      });\n      return matches;\n    }\n\n    /**\n     * Move a sheet to a new position.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Workbook} The workbook.\n     */\n  }, {\n    key: \"moveSheet\",\n    value: function moveSheet(sheet, indexOrBeforeSheet) {\n      // Get the sheet to move.\n      if (!(sheet instanceof Sheet)) {\n        sheet = this.sheet(sheet);\n        if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n      }\n\n      // Get the to/from indexes.\n      var from = this._sheets.indexOf(sheet);\n      var to;\n      if (_.isNil(indexOrBeforeSheet)) {\n        to = this._sheets.length - 1;\n      } else if (_.isInteger(indexOrBeforeSheet)) {\n        to = indexOrBeforeSheet;\n      } else {\n        if (!(indexOrBeforeSheet instanceof Sheet)) {\n          indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n          if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n        }\n        to = this._sheets.indexOf(indexOrBeforeSheet);\n      }\n\n      // Insert the sheet at the appropriate place.\n      this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n      return this;\n    }\n\n    /**\n     * Generates the workbook output.\n     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     */ /**\n        * Generates the workbook output.\n        * @param {{}} [opts] Options\n        * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n        * @param {string} [opts.password] - The password to use to encrypt the workbook.\n        * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n        */\n  }, {\n    key: \"outputAsync\",\n    value: function outputAsync(opts) {\n      var _this3 = this;\n      opts = opts || {};\n      if (typeof opts === 'string') opts = {\n        type: opts\n      };\n      this._setSheetRefs();\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      this._sheets.forEach(function (sheet, i) {\n        if (!sheet._autoFilter) return;\n        if (!definedNamesNode) {\n          definedNamesNode = {\n            name: \"definedNames\",\n            attributes: {},\n            children: []\n          };\n          xmlq.insertInOrder(_this3._node, definedNamesNode, nodeOrder);\n        }\n        xmlq.appendChild(definedNamesNode, {\n          name: \"definedName\",\n          attributes: {\n            name: \"_xlnm._FilterDatabase\",\n            localSheetId: i,\n            hidden: \"1\"\n          },\n          children: [sheet._autoFilter.address({\n            includeSheetName: true,\n            anchored: true\n          })]\n        });\n      });\n      this._sheetsNode.children = [];\n      this._sheets.forEach(function (sheet, i) {\n        var sheetPath = \"xl/worksheets/sheet\".concat(i + 1, \".xml\");\n        var sheetRelsPath = \"xl/worksheets/_rels/sheet\".concat(i + 1, \".xml.rels\");\n        var sheetXmls = sheet.toXmls();\n        var relationship = _this3._relationships.findById(sheetXmls.id.attributes['r:id']);\n        relationship.attributes.Target = \"worksheets/sheet\".concat(i + 1, \".xml\");\n        _this3._sheetsNode.children.push(sheetXmls.id);\n        _this3._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n        var relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n        if (relationshipsXml) {\n          _this3._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n        } else {\n          _this3._zip.remove(sheetRelsPath);\n        }\n      });\n\n      // Set the app security to true if a password is set, false if not.\n      // this._appProperties.isSecure(!!opts.password);\n\n      // Convert the various components to XML strings and add them to the zip.\n      this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n      this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n      this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n      this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n      this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n      this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n      this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts);\n\n      // Generate the zip.\n      return this._zip.generateAsync({\n        type: \"nodebuffer\",\n        compression: \"DEFLATE\"\n      }).then(function (output) {\n        // If a password is set, encrypt the workbook.\n        if (opts.password) output = encryptor.encrypt(output, opts.password);\n\n        // Convert and return\n        return _this3._convertBufferToOutput(output, opts.type);\n      });\n    }\n\n    /**\n     * Gets the sheet with the provided name or index (0-based).\n     * @param {string|number} sheetNameOrIndex - The sheet name or index.\n     * @returns {Sheet|undefined} The sheet or undefined if not found.\n     */\n  }, {\n    key: \"sheet\",\n    value: function sheet(sheetNameOrIndex) {\n      if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n      return _.find(this._sheets, function (sheet) {\n        return sheet.name() === sheetNameOrIndex;\n      });\n    }\n\n    /**\n     * Get an array of all the sheets in the workbook.\n     * @returns {Array.<Sheet>} The sheets.\n     */\n  }, {\n    key: \"sheets\",\n    value: function sheets() {\n      return this._sheets.slice();\n    }\n\n    /**\n     * Gets an individual property.\n     * @param {string} name - The name of the property.\n     * @returns {*} The property.\n     */ /**\n        * Gets multiple properties.\n        * @param {Array.<string>} names - The names of the properties.\n        * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n        */ /**\n           * Sets an individual property.\n           * @param {string} name - The name of the property.\n           * @param {*} value - The value to set.\n           * @returns {Workbook} The workbook.\n           */ /**\n              * Sets multiple properties.\n              * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n              * @returns {Workbook} The workbook.\n              */\n  }, {\n    key: \"property\",\n    value: function property() {\n      var _this4 = this;\n      return new ArgHandler(\"Workbook.property\").case('string', function (name) {\n        // Get single value\n        return _this4._coreProperties.get(name);\n      }).case('array', function (names) {\n        // Get list of values\n        var values = {};\n        names.forEach(function (name) {\n          values[name] = _this4._coreProperties.get(name);\n        });\n        return values;\n      }).case(['string', '*'], function (name, value) {\n        // Set a single value for all cells to a single value\n        _this4._coreProperties.set(name, value);\n        return _this4;\n      }).case('object', function (nameValues) {\n        // Object of key value pairs to set\n        for (var name in nameValues) {\n          if (!nameValues.hasOwnProperty(name)) continue;\n          var value = nameValues[name];\n          _this4._coreProperties.set(name, value);\n        }\n        return _this4;\n      }).handle(arguments);\n    }\n\n    /**\n     * Get access to core properties object\n     * @returns {CoreProperties} The core properties.\n     */\n  }, {\n    key: \"properties\",\n    value: function properties() {\n      return this._coreProperties;\n    }\n\n    /**\n     * Write the workbook to file. (Not supported in browsers.)\n     * @param {string} path - The path of the file to write.\n     * @param {{}} [opts] - Options\n     * @param {string} [opts.password] - The password to encrypt the workbook.\n     * @returns {Promise.<undefined>} A promise.\n     */\n  }, {\n    key: \"toFileAsync\",\n    value: function toFileAsync(path, opts) {\n      if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n      return this.outputAsync(opts).then(function (data) {\n        return new externals.Promise(function (resolve, reject) {\n          fs.writeFile(path, data, function (err) {\n            if (err) return reject(err);\n            resolve();\n          });\n        });\n      });\n    }\n\n    /**\n     * Gets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n     * @ignore\n     */ /**\n        * Sets a scoped defined name.\n        * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n        * @param {string} name - The defined name.\n        * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n        * @returns {Workbook} The workbook.\n        * @ignore\n        */\n  }, {\n    key: \"scopedDefinedName\",\n    value: function scopedDefinedName(sheetScope, name, refersTo) {\n      var _this5 = this;\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      var definedNameNode = definedNamesNode && _.find(definedNamesNode.children, function (node) {\n        return node.attributes.name === name && node.localSheet === sheetScope;\n      });\n      return new ArgHandler('Workbook.scopedDefinedName').case(['*', 'string'], function () {\n        // Get the address from the definedNames node.\n        var refersTo = definedNameNode && definedNameNode.children[0];\n        if (!refersTo) return undefined;\n\n        // Try to parse the address.\n        var ref = addressConverter.fromAddress(refersTo);\n        if (!ref) return refersTo;\n\n        // Load the appropriate selection type.\n        var sheet = _this5.sheet(ref.sheetName);\n        if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n        if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n        if (ref.type === 'row') return sheet.row(ref.rowNumber);\n        if (ref.type === 'column') return sheet.column(ref.columnNumber);\n        return refersTo;\n      }).case(['*', 'string', 'nil'], function () {\n        if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n        if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(_this5._node, definedNamesNode);\n        return _this5;\n      }).case(['*', 'string', '*'], function () {\n        if (typeof refersTo !== 'string') {\n          refersTo = refersTo.address({\n            includeSheetName: true,\n            anchored: true\n          });\n        }\n        if (!definedNamesNode) {\n          definedNamesNode = {\n            name: \"definedNames\",\n            attributes: {},\n            children: []\n          };\n          xmlq.insertInOrder(_this5._node, definedNamesNode, nodeOrder);\n        }\n        if (!definedNameNode) {\n          definedNameNode = {\n            name: \"definedName\",\n            attributes: {\n              name: name\n            },\n            children: [refersTo]\n          };\n          if (sheetScope) definedNameNode.localSheet = sheetScope;\n          xmlq.appendChild(definedNamesNode, definedNameNode);\n        }\n        definedNameNode.children = [refersTo];\n        return _this5;\n      }).handle(arguments);\n    }\n\n    /**\n     * Get the shared strings table.\n     * @returns {SharedStrings} The shared strings table.\n     * @ignore\n     */\n  }, {\n    key: \"sharedStrings\",\n    value: function sharedStrings() {\n      return this._sharedStrings;\n    }\n\n    /**\n     * Get the style sheet.\n     * @returns {StyleSheet} The style sheet.\n     * @ignore\n     */\n  }, {\n    key: \"styleSheet\",\n    value: function styleSheet() {\n      return this._styleSheet;\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * \n     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n     * @param {Sheet} from - The sheet to be cloned.\n     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n  }, {\n    key: \"cloneSheet\",\n    value: function cloneSheet(from, name, indexOrBeforeSheet) {\n      if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n      return this._addSheet(name, indexOrBeforeSheet, function () {\n        var cloneXml = function cloneXml(node) {\n          // If the node has a toXml method, call it.\n          if (node && _.isFunction(node.toXml)) node = node.toXml();\n          if (typeof node === 'object') {\n            if (node.name) {\n              var result = {\n                name: node.name,\n                attributes: {},\n                children: []\n              };\n              _.forOwn(node.attributes, function (value, name) {\n                result.attributes[name] = value;\n              });\n              var chld;\n              if (node.children) {\n                node.children.forEach(function (child) {\n                  chld = cloneXml(child);\n                  if (child !== null) {\n                    result.children.push(chld);\n                  }\n                });\n              }\n              return result;\n            }\n          } else if (node !== null) {\n            return node;\n          }\n          return null;\n        };\n\n        // clone SheetNode & relationshipNode from source\n        var fromXml = from.toXmls();\n        var sheetNode = cloneXml(fromXml.sheet);\n        var relationshipNode = cloneXml(fromXml.relationships);\n        return {\n          sheetNode: sheetNode,\n          relationshipNode: relationshipNode\n        };\n      });\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @param {callback} [getTemplateNodes] optional callback function for template nodes\n     * @returns {Sheet} The new sheet.\n     * @private\n     */\n  }, {\n    key: \"_addSheet\",\n    value: function _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n      // Validate the sheet name.\n      if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n      if (_.some(badSheetNameChars, function (char) {\n        return name.indexOf(char) >= 0;\n      })) throw new Error(\"Sheet name may not contain any of the following characters: \".concat(badSheetNameChars.join(\" \")));\n      if (name.length > maxSheetNameLength) throw new Error(\"Sheet name may not be greater than \".concat(maxSheetNameLength, \" characters.\"));\n      if (this.sheet(name)) throw new Error(\"Sheet with name \\\"\".concat(name, \"\\\" already exists.\"));\n\n      // Get the destination index of new sheet.\n      var index;\n      if (_.isNil(indexOrBeforeSheet)) {\n        index = this._sheets.length;\n      } else if (_.isInteger(indexOrBeforeSheet)) {\n        index = indexOrBeforeSheet;\n      } else {\n        if (!(indexOrBeforeSheet instanceof Sheet)) {\n          indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n          if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n        }\n        index = this._sheets.indexOf(indexOrBeforeSheet);\n      }\n\n      // Add a new relationship for the new sheet and create the new sheet ID node.\n      var relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n      var sheetIdNode = {\n        name: \"sheet\",\n        attributes: {\n          name: name,\n          sheetId: ++this._maxSheetId,\n          'r:id': relationship.attributes.Id\n        },\n        children: []\n      };\n\n      // Create the new sheet.\n      var sheet;\n      if (getTemplateNodes) {\n        var _getTemplateNodes = getTemplateNodes(),\n          sheetNode = _getTemplateNodes.sheetNode,\n          relationshipNode = _getTemplateNodes.relationshipNode;\n        sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n      } else {\n        sheet = new Sheet(this, sheetIdNode);\n      }\n\n      // Insert the sheet at the appropriate index.\n      this._sheets.splice(index, 0, sheet);\n      return sheet;\n    }\n\n    /**\n     * Initialize the workbook. (This is separated from the constructor to ease testing.)\n     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @private\n     */\n  }, {\n    key: \"_initAsync\",\n    value: function _initAsync(data, opts) {\n      var _this6 = this;\n      opts = opts || {};\n      this._maxSheetId = 0;\n      this._sheets = [];\n      return externals.Promise.resolve().then(function () {\n        // Make sure the input is a Buffer\n        return _this6._convertInputToBufferAsync(data, opts.base64).then(function (buffer) {\n          data = buffer;\n        });\n      }).then(function () {\n        if (!opts.password) return;\n        return encryptor.decryptAsync(data, opts.password).then(function (decrypted) {\n          data = decrypted;\n        });\n      }).then(function () {\n        return JSZip.loadAsync(data);\n      }).then(function (zip) {\n        _this6._zip = zip;\n        return _this6._parseNodesAsync([\"[Content_Types].xml\", \"docProps/app.xml\", \"docProps/core.xml\", \"xl/_rels/workbook.xml.rels\", \"xl/sharedStrings.xml\", \"xl/styles.xml\", \"xl/workbook.xml\"]);\n      }).then(function (nodes) {\n        var contentTypesNode = nodes[0];\n        var appPropertiesNode = nodes[1];\n        var corePropertiesNode = nodes[2];\n        var relationshipsNode = nodes[3];\n        var sharedStringsNode = nodes[4];\n        var styleSheetNode = nodes[5];\n        var workbookNode = nodes[6];\n\n        // Load the various components.\n        _this6._contentTypes = new ContentTypes(contentTypesNode);\n        _this6._appProperties = new AppProperties(appPropertiesNode);\n        _this6._coreProperties = new CoreProperties(corePropertiesNode);\n        _this6._relationships = new Relationships(relationshipsNode);\n        _this6._sharedStrings = new SharedStrings(sharedStringsNode);\n        _this6._styleSheet = new StyleSheet(styleSheetNode);\n        _this6._node = workbookNode;\n\n        // Add the shared strings relationship if it doesn't exist.\n        if (!_this6._relationships.findByType(\"sharedStrings\")) {\n          _this6._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n        }\n\n        // Add the shared string content type if it doesn't exist.\n        if (!_this6._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n          _this6._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n        }\n\n        // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n        _this6._zip.remove(\"xl/calcChain.xml\");\n\n        // Load each sheet.\n        _this6._sheetsNode = xmlq.findChild(_this6._node, \"sheets\");\n        return externals.Promise.all(_.map(_this6._sheetsNode.children, function (sheetIdNode, i) {\n          if (sheetIdNode.attributes.sheetId > _this6._maxSheetId) _this6._maxSheetId = sheetIdNode.attributes.sheetId;\n          return _this6._parseNodesAsync([\"xl/worksheets/sheet\".concat(i + 1, \".xml\"), \"xl/worksheets/_rels/sheet\".concat(i + 1, \".xml.rels\")]).then(function (nodes) {\n            var sheetNode = nodes[0];\n            var sheetRelationshipsNode = nodes[1];\n\n            // Insert at position i as the promises will resolve at different times.\n            _this6._sheets[i] = new Sheet(_this6, sheetIdNode, sheetNode, sheetRelationshipsNode);\n          });\n        }));\n      }).then(function () {\n        return _this6._parseSheetRefs();\n      }).then(function () {\n        return _this6;\n      });\n    }\n\n    /**\n     * Parse files out of zip into XML node objects.\n     * @param {Array.<string>} names - The file names to parse.\n     * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n     * @private\n     */\n  }, {\n    key: \"_parseNodesAsync\",\n    value: function _parseNodesAsync(names) {\n      var _this7 = this;\n      return externals.Promise.all(_.map(names, function (name) {\n        return _this7._zip.file(name);\n      })).then(function (files) {\n        return externals.Promise.all(_.map(files, function (file) {\n          return file && file.async(\"string\");\n        }));\n      }).then(function (texts) {\n        return externals.Promise.all(_.map(texts, function (text) {\n          return text && xmlParser.parseAsync(text);\n        }));\n      });\n    }\n\n    /**\n     * Parse the sheet references out so we can reorder freely.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_parseSheetRefs\",\n    value: function _parseSheetRefs() {\n      var _this8 = this;\n      // Parse the active sheet.\n      var bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n      var workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n      var activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n      this._activeSheet = this._sheets[activeTabId];\n\n      // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n      // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      if (definedNamesNode) {\n        _.forEach(definedNamesNode.children, function (definedNameNode) {\n          if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n            definedNameNode.localSheet = _this8._sheets[definedNameNode.attributes.localSheetId];\n          }\n        });\n      }\n    }\n\n    /**\n     * Set the proper sheet references in the XML.\n     * @returns {undefined}\n     * @private\n     */\n  }, {\n    key: \"_setSheetRefs\",\n    value: function _setSheetRefs() {\n      var _this9 = this;\n      // Set the active sheet.\n      var bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n      if (!bookViewsNode) {\n        bookViewsNode = {\n          name: 'bookViews',\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n      }\n      var workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n      if (!workbookViewNode) {\n        workbookViewNode = {\n          name: 'workbookView',\n          attributes: {},\n          children: []\n        };\n        xmlq.appendChild(bookViewsNode, workbookViewNode);\n      }\n      workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);\n\n      // Set the defined names local sheet indexes.\n      var definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n      if (definedNamesNode) {\n        _.forEach(definedNamesNode.children, function (definedNameNode) {\n          if (definedNameNode.localSheet) {\n            definedNameNode.attributes.localSheetId = _this9._sheets.indexOf(definedNameNode.localSheet);\n          }\n        });\n      }\n    }\n\n    /**\n     * Convert buffer to desired output format\n     * @param {Buffer} buffer - The buffer\n     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n     * @private\n     */\n  }, {\n    key: \"_convertBufferToOutput\",\n    value: function _convertBufferToOutput(buffer, type) {\n      if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n      if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n      if (process.browser && type === \"blob\") return new Blob([buffer], {\n        type: Workbook.MIME_TYPE\n      });\n      if (type === \"base64\") return buffer.toString(\"base64\");\n      if (type === \"binarystring\") return buffer.toString(\"utf8\");\n      if (type === \"uint8array\") return new Uint8Array(buffer);\n      if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n      throw new Error(\"Output type '\".concat(type, \"' not supported.\"));\n    }\n\n    /**\n     * Convert input to buffer\n     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n     * @returns {Promise.<Buffer>} The buffer.\n     * @private\n     */\n  }, {\n    key: \"_convertInputToBufferAsync\",\n    value: function _convertInputToBufferAsync(input, base64) {\n      return externals.Promise.resolve().then(function () {\n        if (Buffer.isBuffer(input)) return input;\n        if (process.browser && input instanceof Blob) {\n          return new externals.Promise(function (resolve) {\n            var fileReader = new FileReader();\n            fileReader.onload = function (event) {\n              resolve(Buffer.from(event.target.result));\n            };\n            fileReader.readAsArrayBuffer(input);\n          });\n        }\n        if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n        if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n        if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n        throw new Error(\"Input type unknown.\");\n      });\n    }\n  }], [{\n    key: \"fromBlankAsync\",\n    value:\n    /**\n     * Create a new blank workbook.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    function fromBlankAsync() {\n      return Workbook.fromDataAsync(blank);\n    }\n\n    /**\n     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n     * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n  }, {\n    key: \"fromDataAsync\",\n    value: function fromDataAsync(data, opts) {\n      return new Workbook()._initAsync(data, opts);\n    }\n\n    /**\n     * Loads a workbook from file.\n     * @param {string} path - The path to the workbook.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n  }, {\n    key: \"fromFileAsync\",\n    value: function fromFileAsync(path, opts) {\n      if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n      return new externals.Promise(function (resolve, reject) {\n        fs.readFile(path, function (err, data) {\n          if (err) return reject(err);\n          resolve(data);\n        });\n      }).then(function (data) {\n        return Workbook.fromDataAsync(data, opts);\n      });\n    }\n  }]);\n  return Workbook;\n}();\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\nmodule.exports = Workbook;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */","map":{"version":3,"names":["_","require","fs","JSZip","externals","regexify","blank","xmlq","Sheet","ContentTypes","AppProperties","CoreProperties","Relationships","SharedStrings","StyleSheet","Encryptor","XmlParser","XmlBuilder","ArgHandler","addressConverter","zipFileOpts","date","Date","createFolders","xmlParser","xmlBuilder","encryptor","badSheetNameChars","maxSheetNameLength","nodeOrder","Workbook","case","_activeSheet","sheet","hidden","Error","forEach","_sheets","current","tabSelected","handle","arguments","name","indexOrBeforeSheet","_addSheet","scopedDefinedName","undefined","refersTo","visibleSheets","filter","length","index","indexOf","splice","activeSheet","pattern","replacement","matches","concat","find","from","to","isNil","isInteger","opts","type","_setSheetRefs","definedNamesNode","findChild","_node","i","_autoFilter","attributes","children","insertInOrder","appendChild","localSheetId","address","includeSheetName","anchored","_sheetsNode","sheetPath","sheetRelsPath","sheetXmls","toXmls","relationship","_relationships","findById","id","Target","push","_zip","file","build","relationshipsXml","relationships","remove","_contentTypes","_appProperties","_coreProperties","_sharedStrings","_styleSheet","generateAsync","compression","then","output","password","encrypt","_convertBufferToOutput","sheetNameOrIndex","slice","get","names","values","value","set","nameValues","hasOwnProperty","path","process","browser","outputAsync","data","Promise","resolve","reject","writeFile","err","sheetScope","definedNameNode","node","localSheet","ref","fromAddress","sheetName","cell","rowNumber","columnNumber","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","row","column","removeChild","cloneXml","isFunction","toXml","result","forOwn","chld","child","fromXml","sheetNode","relationshipNode","getTemplateNodes","some","char","join","add","sheetIdNode","sheetId","_maxSheetId","Id","_convertInputToBufferAsync","base64","buffer","decryptAsync","decrypted","loadAsync","zip","_parseNodesAsync","nodes","contentTypesNode","appPropertiesNode","corePropertiesNode","relationshipsNode","sharedStringsNode","styleSheetNode","workbookNode","findByType","findByPartName","all","map","sheetRelationshipsNode","_parseSheetRefs","files","async","texts","text","parseAsync","bookViewsNode","workbookViewNode","activeTabId","activeTab","Blob","MIME_TYPE","toString","Uint8Array","input","Buffer","isBuffer","fileReader","FileReader","onload","event","target","readAsArrayBuffer","ArrayBuffer","fromDataAsync","_initAsync","readFile","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Workbook.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst fs = require(\"fs\");\nconst JSZip = require('jszip');\n\nconst externals = require(\"./externals\");\nconst regexify = require(\"./regexify\");\nconst blank = require(\"./blank\")();\nconst xmlq = require(\"./xmlq\");\nconst Sheet = require(\"./Sheet\");\nconst ContentTypes = require(\"./ContentTypes\");\nconst AppProperties = require(\"./AppProperties\");\nconst CoreProperties = require(\"./CoreProperties\");\nconst Relationships = require(\"./Relationships\");\nconst SharedStrings = require(\"./SharedStrings\");\nconst StyleSheet = require(\"./StyleSheet\");\nconst Encryptor = require(\"./Encryptor\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n// Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\nconst zipFileOpts = {\n    date: new Date(0),\n    createFolders: false\n};\n\n// Initialize the parser and builder.\nconst xmlParser = new XmlParser();\nconst xmlBuilder = new XmlBuilder();\n\n// Initialize the encryptor if present (can be excluded in browser build).\nconst encryptor = typeof Encryptor === \"function\" && new Encryptor();\n\n// Characters not allowed in sheet names.\nconst badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?'];\n\n// Excel limits sheet names to 31 chars.\nconst maxSheetNameLength = 31;\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\",\n    \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\",\n    \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"\n];\n\n/**\n * A workbook.\n */\nclass Workbook {\n    /**\n     * Create a new blank workbook.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromBlankAsync() {\n        return Workbook.fromDataAsync(blank);\n    }\n\n    /**\n     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n     * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromDataAsync(data, opts) {\n        return new Workbook()._initAsync(data, opts);\n    }\n\n    /**\n     * Loads a workbook from file.\n     * @param {string} path - The path to the workbook.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n        return new externals.Promise((resolve, reject) => {\n            fs.readFile(path, (err, data) => {\n                if (err) return reject(err);\n                resolve(data);\n            });\n        }).then(data => Workbook.fromDataAsync(data, opts));\n    }\n\n    /**\n     * Get the active sheet in the workbook.\n     * @returns {Sheet} The active sheet.\n     *//**\n     * Set the active sheet in the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n     * @returns {Workbook} The workbook.\n     */\n    activeSheet() {\n        return new ArgHandler('Workbook.activeSheet')\n            .case(() => {\n                return this._activeSheet;\n            })\n            .case('*', sheet => {\n                // Get the sheet from name/index if needed.\n                if (!(sheet instanceof Sheet)) sheet = this.sheet(sheet);\n\n                // Check if the sheet is hidden.\n                if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\");\n\n                // Deselect all sheets except the active one (mirroring ying Excel behavior).\n                _.forEach(this._sheets, current => {\n                    current.tabSelected(current === sheet);\n                });\n\n                this._activeSheet = sheet;\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    addSheet(name, indexOrBeforeSheet) {\n        return this._addSheet(name, indexOrBeforeSheet);\n    }\n    \n    /**\n     * Gets a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.scopedDefinedName(undefined, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.scopedDefinedName(undefined, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Delete a sheet from the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @returns {Workbook} The workbook.\n     */\n    deleteSheet(sheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Make sure we are not deleting the only visible sheet.\n        const visibleSheets = _.filter(this._sheets, sheet => !sheet.hidden());\n        if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n            throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n        }\n\n        // Remove the sheet.\n        let index = this._sheets.indexOf(sheet);\n        this._sheets.splice(index, 1);\n\n        // Set the new active sheet.\n        if (sheet === this.activeSheet()) {\n            if (index >= this._sheets.length) index--;\n            this.activeSheet(index);\n        }\n\n        return this;\n    }\n\n    /**\n     * Find the given pattern in the workbook and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._sheets.forEach(sheet => {\n            matches = matches.concat(sheet.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Move a sheet to a new position.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Workbook} The workbook.\n     */\n    moveSheet(sheet, indexOrBeforeSheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Get the to/from indexes.\n        const from = this._sheets.indexOf(sheet);\n        let to;\n        if (_.isNil(indexOrBeforeSheet)) {\n            to = this._sheets.length - 1;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            to = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            to = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Insert the sheet at the appropriate place.\n        this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n\n        return this;\n    }\n\n    /**\n     * Generates the workbook output.\n     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     *//**\n     * Generates the workbook output.\n     * @param {{}} [opts] Options\n     * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @param {string} [opts.password] - The password to use to encrypt the workbook.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     */\n    outputAsync(opts) {\n        opts = opts || {};\n        if (typeof opts === 'string') opts = { type: opts };\n\n        this._setSheetRefs();\n\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n        this._sheets.forEach((sheet, i) => {\n            if (!sheet._autoFilter) return;\n\n            if (!definedNamesNode) {\n                definedNamesNode = {\n                    name: \"definedNames\",\n                    attributes: {},\n                    children: []\n                };\n\n                xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n            }\n\n            xmlq.appendChild(definedNamesNode, {\n                name: \"definedName\",\n                attributes: {\n                    name: \"_xlnm._FilterDatabase\",\n                    localSheetId: i,\n                    hidden: \"1\"\n                },\n                children: [sheet._autoFilter.address({ includeSheetName: true, anchored: true })]\n            });\n        });\n\n        this._sheetsNode.children = [];\n        this._sheets.forEach((sheet, i) => {\n            const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;\n            const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;\n            const sheetXmls = sheet.toXmls();\n            const relationship = this._relationships.findById(sheetXmls.id.attributes['r:id']);\n            relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;\n            this._sheetsNode.children.push(sheetXmls.id);\n            this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n\n            const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n            if (relationshipsXml) {\n                this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n            } else {\n                this._zip.remove(sheetRelsPath);\n            }\n        });\n\n        // Set the app security to true if a password is set, false if not.\n        // this._appProperties.isSecure(!!opts.password);\n\n        // Convert the various components to XML strings and add them to the zip.\n        this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n        this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n        this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n        this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n        this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n        this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n        this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts);\n\n        // Generate the zip.\n        return this._zip.generateAsync({\n            type: \"nodebuffer\",\n            compression: \"DEFLATE\"\n        }).then(output => {\n            // If a password is set, encrypt the workbook.\n            if (opts.password) output = encryptor.encrypt(output, opts.password);\n\n            // Convert and return\n            return this._convertBufferToOutput(output, opts.type);\n        });\n    }\n\n    /**\n     * Gets the sheet with the provided name or index (0-based).\n     * @param {string|number} sheetNameOrIndex - The sheet name or index.\n     * @returns {Sheet|undefined} The sheet or undefined if not found.\n     */\n    sheet(sheetNameOrIndex) {\n        if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n        return _.find(this._sheets, sheet => sheet.name() === sheetNameOrIndex);\n    }\n\n    /**\n     * Get an array of all the sheets in the workbook.\n     * @returns {Array.<Sheet>} The sheets.\n     */\n    sheets() {\n        return this._sheets.slice();\n    }\n\n    /**\n     * Gets an individual property.\n     * @param {string} name - The name of the property.\n     * @returns {*} The property.\n     *//**\n     * Gets multiple properties.\n     * @param {Array.<string>} names - The names of the properties.\n     * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n     *//**\n     * Sets an individual property.\n     * @param {string} name - The name of the property.\n     * @param {*} value - The value to set.\n     * @returns {Workbook} The workbook.\n     *//**\n     * Sets multiple properties.\n     * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n     * @returns {Workbook} The workbook.\n     */\n    property() {\n        return new ArgHandler(\"Workbook.property\")\n            .case('string', name => {\n                // Get single value\n                return this._coreProperties.get(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this._coreProperties.get(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                this._coreProperties.set(name, value);\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this._coreProperties.set(name, value);\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get access to core properties object\n     * @returns {CoreProperties} The core properties.\n     */\n    properties() {\n        return this._coreProperties;\n    }\n\n    /**\n     * Write the workbook to file. (Not supported in browsers.)\n     * @param {string} path - The path of the file to write.\n     * @param {{}} [opts] - Options\n     * @param {string} [opts.password] - The password to encrypt the workbook.\n     * @returns {Promise.<undefined>} A promise.\n     */\n    toFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n        return this.outputAsync(opts)\n            .then(data => new externals.Promise((resolve, reject) => {\n                fs.writeFile(path, data, err => {\n                    if (err) return reject(err);\n                    resolve();\n                });\n            }));\n    }\n\n    /**\n     * Gets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n     * @ignore\n     *//**\n     * Sets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n     * @returns {Workbook} The workbook.\n     * @ignore\n     */\n    scopedDefinedName(sheetScope, name, refersTo) {\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        let definedNameNode = definedNamesNode && _.find(definedNamesNode.children, node => node.attributes.name === name && node.localSheet === sheetScope);\n\n        return new ArgHandler('Workbook.scopedDefinedName')\n            .case(['*', 'string'], () => {\n                // Get the address from the definedNames node.\n                const refersTo = definedNameNode && definedNameNode.children[0];\n                if (!refersTo) return undefined;\n\n                // Try to parse the address.\n                const ref = addressConverter.fromAddress(refersTo);\n                if (!ref) return refersTo;\n\n                // Load the appropriate selection type.\n                const sheet = this.sheet(ref.sheetName);\n                if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n                if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n                if (ref.type === 'row') return sheet.row(ref.rowNumber);\n                if (ref.type === 'column') return sheet.column(ref.columnNumber);\n                return refersTo;\n            })\n            .case(['*', 'string', 'nil'], () => {\n                if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n                if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(this._node, definedNamesNode);\n                return this;\n            })\n            .case(['*', 'string', '*'], () => {\n                if (typeof refersTo !== 'string') {\n                    refersTo = refersTo.address({\n                        includeSheetName: true,\n                        anchored: true\n                    });\n                }\n\n                if (!definedNamesNode) {\n                    definedNamesNode = {\n                        name: \"definedNames\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n                }\n\n                if (!definedNameNode) {\n                    definedNameNode = {\n                        name: \"definedName\",\n                        attributes: { name },\n                        children: [refersTo]\n                    };\n\n                    if (sheetScope) definedNameNode.localSheet = sheetScope;\n\n                    xmlq.appendChild(definedNamesNode, definedNameNode);\n                }\n\n                definedNameNode.children = [refersTo];\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the shared strings table.\n     * @returns {SharedStrings} The shared strings table.\n     * @ignore\n     */\n    sharedStrings() {\n        return this._sharedStrings;\n    }\n\n    /**\n     * Get the style sheet.\n     * @returns {StyleSheet} The style sheet.\n     * @ignore\n     */\n    styleSheet() {\n        return this._styleSheet;\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * \n     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n     * @param {Sheet} from - The sheet to be cloned.\n     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    cloneSheet(from, name, indexOrBeforeSheet) {\n        if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n\n        return this._addSheet(name, indexOrBeforeSheet, () => {\n            const cloneXml = node => {\n                // If the node has a toXml method, call it.\n                if (node && _.isFunction(node.toXml)) node = node.toXml();\n        \n                if (typeof node === 'object') {\n                    if (node.name) {\n                        const result = {\n                            name: node.name,\n                            attributes: {},\n                            children: []\n                        };\n                        \n                        _.forOwn(node.attributes, (value, name) => {\n                            result.attributes[name] = value;\n                        }); \n                    \n                        let chld;\n                        if (node.children) { \n                            node.children.forEach(child => {\n                                chld = cloneXml(child);\n                                if (child !== null) {\n                                    result.children.push(chld);\n                                }\n                            });\n                        }\n                        return result;\n                    }\n                } else if (node !== null) {\n                    return node;\n                } \n                return null;\n            };\n\n            // clone SheetNode & relationshipNode from source\n            const fromXml = from.toXmls();\n            const sheetNode = cloneXml(fromXml.sheet);\n            const relationshipNode = cloneXml(fromXml.relationships);\n            return { sheetNode, relationshipNode };\n        });\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @param {callback} [getTemplateNodes] optional callback function for template nodes\n     * @returns {Sheet} The new sheet.\n     * @private\n     */\n    _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n        // Validate the sheet name.\n        if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n        if (_.some(badSheetNameChars, char => name.indexOf(char) >= 0)) throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(\" \")}`);\n        if (name.length > maxSheetNameLength) throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);\n        if (this.sheet(name)) throw new Error(`Sheet with name \"${name}\" already exists.`);\n\n        // Get the destination index of new sheet.\n        let index;\n        if (_.isNil(indexOrBeforeSheet)) {\n            index = this._sheets.length;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            index = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            index = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Add a new relationship for the new sheet and create the new sheet ID node.\n        const relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n        const sheetIdNode = {\n            name: \"sheet\",\n            attributes: {\n                name,\n                sheetId: ++this._maxSheetId,\n                'r:id': relationship.attributes.Id\n            },\n            children: []\n        };\n\n        // Create the new sheet.\n        let sheet;\n        if (getTemplateNodes) {\n            const { sheetNode, relationshipNode } = getTemplateNodes();\n            sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n        } else {\n            sheet = new Sheet(this, sheetIdNode);\n        }\n\n        // Insert the sheet at the appropriate index.\n        this._sheets.splice(index, 0, sheet);\n\n        return sheet;\n    }\n\n    /**\n     * Initialize the workbook. (This is separated from the constructor to ease testing.)\n     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @private\n     */\n    _initAsync(data, opts) {\n        opts = opts || {};\n\n        this._maxSheetId = 0;\n        this._sheets = [];\n\n        return externals.Promise.resolve()\n            .then(() => {\n                // Make sure the input is a Buffer\n                return this._convertInputToBufferAsync(data, opts.base64)\n                    .then(buffer => {\n                        data = buffer;\n                    });\n            })\n            .then(() => {\n                if (!opts.password) return;\n                return encryptor.decryptAsync(data, opts.password)\n                    .then(decrypted => {\n                        data = decrypted;\n                    });\n            })\n            .then(() => JSZip.loadAsync(data))\n            .then(zip => {\n                this._zip = zip;\n                return this._parseNodesAsync([\n                    \"[Content_Types].xml\",\n                    \"docProps/app.xml\",\n                    \"docProps/core.xml\",\n                    \"xl/_rels/workbook.xml.rels\",\n                    \"xl/sharedStrings.xml\",\n                    \"xl/styles.xml\",\n                    \"xl/workbook.xml\"\n                ]);\n            })\n            .then(nodes => {\n                const contentTypesNode = nodes[0];\n                const appPropertiesNode = nodes[1];\n                const corePropertiesNode = nodes[2];\n                const relationshipsNode = nodes[3];\n                const sharedStringsNode = nodes[4];\n                const styleSheetNode = nodes[5];\n                const workbookNode = nodes[6];\n\n                // Load the various components.\n                this._contentTypes = new ContentTypes(contentTypesNode);\n                this._appProperties = new AppProperties(appPropertiesNode);\n                this._coreProperties = new CoreProperties(corePropertiesNode);\n                this._relationships = new Relationships(relationshipsNode);\n                this._sharedStrings = new SharedStrings(sharedStringsNode);\n                this._styleSheet = new StyleSheet(styleSheetNode);\n                this._node = workbookNode;\n\n                // Add the shared strings relationship if it doesn't exist.\n                if (!this._relationships.findByType(\"sharedStrings\")) {\n                    this._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n                }\n\n                // Add the shared string content type if it doesn't exist.\n                if (!this._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n                    this._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n                }\n\n                // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n                this._zip.remove(\"xl/calcChain.xml\");\n\n                // Load each sheet.\n                this._sheetsNode = xmlq.findChild(this._node, \"sheets\");\n                return externals.Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {\n                    if (sheetIdNode.attributes.sheetId > this._maxSheetId) this._maxSheetId = sheetIdNode.attributes.sheetId;\n\n                    return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`])\n                        .then(nodes => {\n                            const sheetNode = nodes[0];\n                            const sheetRelationshipsNode = nodes[1];\n\n                            // Insert at position i as the promises will resolve at different times.\n                            this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);\n                        });\n                }));\n            })\n            .then(() => this._parseSheetRefs())\n            .then(() => this);\n    }\n\n    /**\n     * Parse files out of zip into XML node objects.\n     * @param {Array.<string>} names - The file names to parse.\n     * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n     * @private\n     */\n    _parseNodesAsync(names) {\n        return externals.Promise.all(_.map(names, name => this._zip.file(name)))\n            .then(files => externals.Promise.all(_.map(files, file => file && file.async(\"string\"))))\n            .then(texts => externals.Promise.all(_.map(texts, text => text && xmlParser.parseAsync(text))));\n    }\n\n    /**\n     * Parse the sheet references out so we can reorder freely.\n     * @returns {undefined}\n     * @private\n     */\n    _parseSheetRefs() {\n        // Parse the active sheet.\n        const bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        const workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n        const activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n        this._activeSheet = this._sheets[activeTabId];\n\n        // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n        // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n                    definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];\n                }\n            });\n        }\n    }\n\n    /**\n     * Set the proper sheet references in the XML.\n     * @returns {undefined}\n     * @private\n     */\n    _setSheetRefs() {\n        // Set the active sheet.\n        let bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        if (!bookViewsNode) {\n            bookViewsNode = { name: 'bookViews', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n        }\n\n        let workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n        if (!workbookViewNode) {\n            workbookViewNode = { name: 'workbookView', attributes: {}, children: [] };\n            xmlq.appendChild(bookViewsNode, workbookViewNode);\n        }\n\n        workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);\n\n        // Set the defined names local sheet indexes.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.localSheet) {\n                    definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);\n                }\n            });\n        }\n    }\n\n    /**\n     * Convert buffer to desired output format\n     * @param {Buffer} buffer - The buffer\n     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n     * @private\n     */\n    _convertBufferToOutput(buffer, type) {\n        if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n\n        if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n        if (process.browser && type === \"blob\") return new Blob([buffer], { type: Workbook.MIME_TYPE });\n        if (type === \"base64\") return buffer.toString(\"base64\");\n        if (type === \"binarystring\") return buffer.toString(\"utf8\");\n        if (type === \"uint8array\") return new Uint8Array(buffer);\n        if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n\n        throw new Error(`Output type '${type}' not supported.`);\n    }\n\n    /**\n     * Convert input to buffer\n     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n     * @returns {Promise.<Buffer>} The buffer.\n     * @private\n     */\n    _convertInputToBufferAsync(input, base64) {\n        return externals.Promise.resolve()\n            .then(() => {\n                if (Buffer.isBuffer(input)) return input;\n\n                if (process.browser && input instanceof Blob) {\n                    return new externals.Promise(resolve => {\n                        const fileReader = new FileReader();\n                        fileReader.onload = event => {\n                            resolve(Buffer.from(event.target.result));\n                        };\n                        fileReader.readAsArrayBuffer(input);\n                    });\n                }\n\n                if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n                if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n                if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n\n                throw new Error(`Input type unknown.`);\n            });\n    }\n}\n\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n\nmodule.exports = Workbook;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}