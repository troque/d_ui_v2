{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst XML_DECLARATION = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>`;\n\n/**\n * XML document builder.\n * @private\n */\nclass XmlBuilder {\n  /**\n   * Build an XML string from the JSON object.\n   * @param {{}} node - The node.\n   * @returns {string} The XML text.\n   */\n  build(node) {\n    this._i = 0;\n    const xml = this._build(node, '');\n    if (xml === '') return;\n    return XML_DECLARATION + xml;\n  }\n\n  /**\n   * Build the XML string. (This is the internal recursive method.)\n   * @param {{}} node - The node.\n   * @param {string} xml - The initial XML doc string.\n   * @returns {string} The generated XML element.\n   * @private\n   */\n  _build(node, xml) {\n    // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n    // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n    // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n    // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n    // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n    if (this._i++ % 1000000 === 0) {\n      this._c = xml[0];\n    }\n\n    // If the node has a toXml method, call it.\n    if (node && _.isFunction(node.toXml)) node = node.toXml();\n    if (_.isObject(node)) {\n      // If the node is an object, then it maps to an element. Check if it has a name.\n      if (!node.name) throw new Error(`XML node does not have name: ${JSON.stringify(node)}`);\n\n      // Add the opening tag.\n      xml += `<${node.name}`;\n\n      // Add any node attributes\n      _.forOwn(node.attributes, (value, name) => {\n        xml += ` ${name}=\"${this._escapeString(value, true)}\"`;\n      });\n      if (_.isEmpty(node.children)) {\n        // Self-close the tag if no children.\n        xml += \"/>\";\n      } else {\n        xml += \">\";\n\n        // Recursively add any children.\n        _.forEach(node.children, child => {\n          // Add the children to the XML.\n          xml = this._build(child, xml);\n        });\n\n        // Close the tag.\n        xml += `</${node.name}>`;\n      }\n    } else if (!_.isNil(node)) {\n      // It not an object, this should be a text node. Just add it.\n      xml += this._escapeString(node);\n    }\n\n    // Return the updated XML element.\n    return xml;\n  }\n\n  /**\n   * Escape a string for use in XML by replacing &, \", ', <, and >.\n   * @param {*} value - The value to escape.\n   * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n   * @returns {string} The escaped string.\n   * @private\n   */\n  _escapeString(value, isAttribute) {\n    if (_.isNil(value)) return value;\n    value = value.toString().replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n    .replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n    if (isAttribute) {\n      value = value.replace(/\"/g, \"&quot;\");\n    }\n    return value;\n  }\n}\nmodule.exports = XmlBuilder;","map":{"version":3,"names":["_","require","XML_DECLARATION","XmlBuilder","build","node","_i","xml","_build","_c","isFunction","toXml","isObject","name","Error","JSON","stringify","forOwn","attributes","value","_escapeString","isEmpty","children","forEach","child","isNil","isAttribute","toString","replace","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/XmlBuilder.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\n\nconst XML_DECLARATION = `<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>`;\n\n/**\n * XML document builder.\n * @private\n */\nclass XmlBuilder {\n    /**\n     * Build an XML string from the JSON object.\n     * @param {{}} node - The node.\n     * @returns {string} The XML text.\n     */\n    build(node) {\n        this._i = 0;\n        const xml = this._build(node, '');\n        if (xml === '') return;\n        return XML_DECLARATION + xml;\n    }\n\n    /**\n     * Build the XML string. (This is the internal recursive method.)\n     * @param {{}} node - The node.\n     * @param {string} xml - The initial XML doc string.\n     * @returns {string} The generated XML element.\n     * @private\n     */\n    _build(node, xml) {\n        // For CPU performance, JS engines don't truly concatenate strings; they create a tree of pointers to\n        // the various concatenated strings. The downside of this is that it consumes a lot of memory, which\n        // will cause problems with large workbooks. So periodically, we grab a character from the xml, which\n        // causes the JS engine to flatten the tree into a single string. Do this too often and CPU takes a hit.\n        // Too frequently and memory takes a hit. Every 100k nodes seems to be a good balance.\n        if (this._i++ % 1000000 === 0) {\n            this._c = xml[0];\n        }\n\n        // If the node has a toXml method, call it.\n        if (node && _.isFunction(node.toXml)) node = node.toXml();\n\n        if (_.isObject(node)) {\n            // If the node is an object, then it maps to an element. Check if it has a name.\n            if (!node.name) throw new Error(`XML node does not have name: ${JSON.stringify(node)}`);\n\n            // Add the opening tag.\n            xml += `<${node.name}`;\n\n            // Add any node attributes\n            _.forOwn(node.attributes, (value, name) => {\n                xml += ` ${name}=\"${this._escapeString(value, true)}\"`;\n            });\n\n            if (_.isEmpty(node.children)) {\n                // Self-close the tag if no children.\n                xml += \"/>\";\n            } else {\n                xml += \">\";\n                \n                // Recursively add any children.\n                _.forEach(node.children, child => {\n                    // Add the children to the XML.\n                    xml = this._build(child, xml);\n                });\n\n                // Close the tag.\n                xml += `</${node.name}>`;\n            }\n        } else if (!_.isNil(node)) {\n            // It not an object, this should be a text node. Just add it.\n            xml += this._escapeString(node);\n        }\n\n        // Return the updated XML element.\n        return xml;\n    }\n\n    /**\n     * Escape a string for use in XML by replacing &, \", ', <, and >.\n     * @param {*} value - The value to escape.\n     * @param {boolean} [isAttribute] - A flag indicating if this is an attribute.\n     * @returns {string} The escaped string.\n     * @private\n     */\n    _escapeString(value, isAttribute) {\n        if (_.isNil(value)) return value;\n        value = value.toString()\n            .replace(/&/g, \"&amp;\") // Escape '&' first as the other escapes add them.\n            .replace(/</g, \"&lt;\")\n            .replace(/>/g, \"&gt;\");\n\n        if (isAttribute) {\n            value = value.replace(/\"/g, \"&quot;\");\n        }\n\n        return value;\n    }\n}\n\nmodule.exports = XmlBuilder;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAE3B,MAAMC,eAAe,GAAI,yDAAwD;;AAEjF;AACA;AACA;AACA;AACA,MAAMC,UAAU,CAAC;EACb;AACJ;AACA;AACA;AACA;EACIC,KAAK,CAACC,IAAI,EAAE;IACR,IAAI,CAACC,EAAE,GAAG,CAAC;IACX,MAAMC,GAAG,GAAG,IAAI,CAACC,MAAM,CAACH,IAAI,EAAE,EAAE,CAAC;IACjC,IAAIE,GAAG,KAAK,EAAE,EAAE;IAChB,OAAOL,eAAe,GAAGK,GAAG;EAChC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIC,MAAM,CAACH,IAAI,EAAEE,GAAG,EAAE;IACd;IACA;IACA;IACA;IACA;IACA,IAAI,IAAI,CAACD,EAAE,EAAE,GAAG,OAAO,KAAK,CAAC,EAAE;MAC3B,IAAI,CAACG,EAAE,GAAGF,GAAG,CAAC,CAAC,CAAC;IACpB;;IAEA;IACA,IAAIF,IAAI,IAAIL,CAAC,CAACU,UAAU,CAACL,IAAI,CAACM,KAAK,CAAC,EAAEN,IAAI,GAAGA,IAAI,CAACM,KAAK,EAAE;IAEzD,IAAIX,CAAC,CAACY,QAAQ,CAACP,IAAI,CAAC,EAAE;MAClB;MACA,IAAI,CAACA,IAAI,CAACQ,IAAI,EAAE,MAAM,IAAIC,KAAK,CAAE,gCAA+BC,IAAI,CAACC,SAAS,CAACX,IAAI,CAAE,EAAC,CAAC;;MAEvF;MACAE,GAAG,IAAK,IAAGF,IAAI,CAACQ,IAAK,EAAC;;MAEtB;MACAb,CAAC,CAACiB,MAAM,CAACZ,IAAI,CAACa,UAAU,EAAE,CAACC,KAAK,EAAEN,IAAI,KAAK;QACvCN,GAAG,IAAK,IAAGM,IAAK,KAAI,IAAI,CAACO,aAAa,CAACD,KAAK,EAAE,IAAI,CAAE,GAAE;MAC1D,CAAC,CAAC;MAEF,IAAInB,CAAC,CAACqB,OAAO,CAAChB,IAAI,CAACiB,QAAQ,CAAC,EAAE;QAC1B;QACAf,GAAG,IAAI,IAAI;MACf,CAAC,MAAM;QACHA,GAAG,IAAI,GAAG;;QAEV;QACAP,CAAC,CAACuB,OAAO,CAAClB,IAAI,CAACiB,QAAQ,EAAEE,KAAK,IAAI;UAC9B;UACAjB,GAAG,GAAG,IAAI,CAACC,MAAM,CAACgB,KAAK,EAAEjB,GAAG,CAAC;QACjC,CAAC,CAAC;;QAEF;QACAA,GAAG,IAAK,KAAIF,IAAI,CAACQ,IAAK,GAAE;MAC5B;IACJ,CAAC,MAAM,IAAI,CAACb,CAAC,CAACyB,KAAK,CAACpB,IAAI,CAAC,EAAE;MACvB;MACAE,GAAG,IAAI,IAAI,CAACa,aAAa,CAACf,IAAI,CAAC;IACnC;;IAEA;IACA,OAAOE,GAAG;EACd;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIa,aAAa,CAACD,KAAK,EAAEO,WAAW,EAAE;IAC9B,IAAI1B,CAAC,CAACyB,KAAK,CAACN,KAAK,CAAC,EAAE,OAAOA,KAAK;IAChCA,KAAK,GAAGA,KAAK,CAACQ,QAAQ,EAAE,CACnBC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;IAAA,CACvBA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC,CACrBA,OAAO,CAAC,IAAI,EAAE,MAAM,CAAC;IAE1B,IAAIF,WAAW,EAAE;MACbP,KAAK,GAAGA,KAAK,CAACS,OAAO,CAAC,IAAI,EAAE,QAAQ,CAAC;IACzC;IAEA,OAAOT,KAAK;EAChB;AACJ;AAEAU,MAAM,CAACC,OAAO,GAAG3B,UAAU"},"metadata":{},"sourceType":"script"}