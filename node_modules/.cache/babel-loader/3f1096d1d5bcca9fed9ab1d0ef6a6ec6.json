{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tr = tr;\nexports.stringExists = stringExists;\nexports.setLanguage = setLanguage;\nexports.addTranslations = addTranslations;\nexports.setTranslator = setTranslator;\nexports.setTranslateVariableRegex = setTranslateVariableRegex;\nexports.setTranslateReferenceRegex = setTranslateReferenceRegex;\n\nvar _utils = require(\"./utils.js\");\n\nvar translations = {};\nvar varRegex = /__(.*?)__/g;\nvar refRegex = /@@(.*?)@@/g;\n\nfunction findString() {\n  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var part = id.split('.');\n  var lastIndex = part.length - 1;\n  return part.reduce(function (nodeInfo, cur, index) {\n    var node = nodeInfo.node,\n        found = nodeInfo.found;\n    var isLast = index == lastIndex;\n    var isString = typeof node == 'string';\n\n    if (isString) {\n      return {\n        found: found,\n        node: node\n      };\n    } else {\n      if (node && node[cur]) {\n        if (isLast && node[cur]._) {\n          return {\n            found: true,\n            node: node[cur]._\n          };\n        } else {\n          return {\n            found: isLast,\n            node: node[cur]\n          };\n        }\n      } else {\n        return {\n          found: node && '_' in node,\n          node: node && node._\n        };\n      }\n    }\n  }, {\n    node: translations\n  });\n}\n\nfunction regexReplace(regex, str, callback) {\n  var match;\n  var result = str;\n  var re = new RegExp(regex);\n\n  while ((match = re.exec(str)) !== null) {\n    var value = callback(match[1]);\n    if (typeof value != 'undefined') result = result.replace(match[0], value);\n  }\n\n  return result;\n}\n/**\n * Translates a string given its id.\n *\n * @param {string} id Identifier in the form\n * \t`key1.key2.key3`\n * @param {object} vars Object with substitution variables. It will\n * \tsubstitute ocurrences when string contains this expression:\n * \t`__variable__`. For example the string `\"My name is __name__\"` with\n * \t`vars = { name: 'David' }` will return `\"My name is David\"`.\n *\n * \tKeys will be searched by partitioning the path.\n *\n * \tIt will get the latest found key if any. For example, given the\n * \tstrings `{ \"a\": { \"b\": 'Hello' } }` and looking for `'a.b.c'` it will\n * \treturn `'a.b'` (`\"Hello\"`).\n * @returns Translated string\n */\n\n\nfunction tr(id) {\n  var vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _findString = findString(id),\n      node = _findString.node;\n\n  if (node) {\n    // Find variables\n    node = regexReplace(varRegex, node, function (match) {\n      return vars[match];\n    }); // Find references\n\n    node = regexReplace(refRegex, node, function (match) {\n      return tr(match, vars);\n    });\n    return node;\n  } else return id;\n}\n/**\n * Returns if the string does exist\n *\n * @param {string} id Identifier\n *\n * @returns { boolean } true if it exists\n */\n\n\nfunction stringExists(id) {\n  var _findString2 = findString(id),\n      found = _findString2.found;\n\n  return found;\n}\n/**\n * Sets the language.\n *\n * At the moment this does the same as addTranslations. The\n * reason is not to lose translations reference until a better\n * way is figured out.\n *\n * @param {lang} Translations object with the format\n * \t{ key: { _: 'Some string', inner: 'Some other string' } }\n * \tThen, we have the following paths\n * \t- key -> 'Some string'\n * \t- key.inner -> 'Some other string'\n */\n\n\nfunction setLanguage(lang) {\n  addTranslations(lang);\n}\n/**\n * Appends translations to current translation table\n *\n * @param {object} lang Translations merged into current.\n */\n\n\nfunction addTranslations(lang) {\n  translations = (0, _utils.deepmerge)(translations, lang);\n}\n/**\n * Sets the translation engine that responds to tr().\n *\n * @param {function} translate Function with signature\n * \ttranslate(id, params).\n */\n\n\nfunction setTranslator(translate) {\n  exports.tr = tr = translate;\n}\n/**\n * Sets the regex for the variables\n */\n\n\nfunction setTranslateVariableRegex(newVarRegex) {\n  varRegex = newVarRegex;\n}\n/**\n * Sets the regex for the substitutions\n */\n\n\nfunction setTranslateReferenceRegex(newRefRegex) {\n  refRegex = newRefRegex;\n}","map":{"version":3,"sources":["C:/w2d/personeria/personeria-ui/node_modules/react-hook-form-auto/lib/translate.js"],"names":["Object","defineProperty","exports","value","tr","stringExists","setLanguage","addTranslations","setTranslator","setTranslateVariableRegex","setTranslateReferenceRegex","_utils","require","translations","varRegex","refRegex","findString","id","part","split","lastIndex","length","reduce","nodeInfo","cur","index","node","found","isLast","isString","_","regexReplace","regex","str","callback","match","result","re","RegExp","exec","replace","vars","lang","deepmerge","translate","newVarRegex","newRefRegex"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.tr = tr;\nexports.stringExists = stringExists;\nexports.setLanguage = setLanguage;\nexports.addTranslations = addTranslations;\nexports.setTranslator = setTranslator;\nexports.setTranslateVariableRegex = setTranslateVariableRegex;\nexports.setTranslateReferenceRegex = setTranslateReferenceRegex;\n\nvar _utils = require(\"./utils.js\");\n\nlet translations = {};\nlet varRegex = /__(.*?)__/g;\nlet refRegex = /@@(.*?)@@/g;\n\nfunction findString(id = '') {\n  const part = id.split('.');\n  const lastIndex = part.length - 1;\n  return part.reduce((nodeInfo, cur, index) => {\n    const {\n      node,\n      found\n    } = nodeInfo;\n    const isLast = index == lastIndex;\n    const isString = typeof node == 'string';\n\n    if (isString) {\n      return {\n        found,\n        node\n      };\n    } else {\n      if (node && node[cur]) {\n        if (isLast && node[cur]._) {\n          return {\n            found: true,\n            node: node[cur]._\n          };\n        } else {\n          return {\n            found: isLast,\n            node: node[cur]\n          };\n        }\n      } else {\n        return {\n          found: node && '_' in node,\n          node: node && node._\n        };\n      }\n    }\n  }, {\n    node: translations\n  });\n}\n\nfunction regexReplace(regex, str, callback) {\n  let match;\n  let result = str;\n  const re = new RegExp(regex);\n\n  while ((match = re.exec(str)) !== null) {\n    const value = callback(match[1]);\n    if (typeof value != 'undefined') result = result.replace(match[0], value);\n  }\n\n  return result;\n}\n/**\n * Translates a string given its id.\n *\n * @param {string} id Identifier in the form\n * \t`key1.key2.key3`\n * @param {object} vars Object with substitution variables. It will\n * \tsubstitute ocurrences when string contains this expression:\n * \t`__variable__`. For example the string `\"My name is __name__\"` with\n * \t`vars = { name: 'David' }` will return `\"My name is David\"`.\n *\n * \tKeys will be searched by partitioning the path.\n *\n * \tIt will get the latest found key if any. For example, given the\n * \tstrings `{ \"a\": { \"b\": 'Hello' } }` and looking for `'a.b.c'` it will\n * \treturn `'a.b'` (`\"Hello\"`).\n * @returns Translated string\n */\n\n\nfunction tr(id, vars = {}) {\n  let {\n    node\n  } = findString(id);\n\n  if (node) {\n    // Find variables\n    node = regexReplace(varRegex, node, match => vars[match]); // Find references\n\n    node = regexReplace(refRegex, node, match => tr(match, vars));\n    return node;\n  } else return id;\n}\n/**\n * Returns if the string does exist\n *\n * @param {string} id Identifier\n *\n * @returns { boolean } true if it exists\n */\n\n\nfunction stringExists(id) {\n  const {\n    found\n  } = findString(id);\n  return found;\n}\n/**\n * Sets the language.\n *\n * At the moment this does the same as addTranslations. The\n * reason is not to lose translations reference until a better\n * way is figured out.\n *\n * @param {lang} Translations object with the format\n * \t{ key: { _: 'Some string', inner: 'Some other string' } }\n * \tThen, we have the following paths\n * \t- key -> 'Some string'\n * \t- key.inner -> 'Some other string'\n */\n\n\nfunction setLanguage(lang) {\n  addTranslations(lang);\n}\n/**\n * Appends translations to current translation table\n *\n * @param {object} lang Translations merged into current.\n */\n\n\nfunction addTranslations(lang) {\n  translations = (0, _utils.deepmerge)(translations, lang);\n}\n/**\n * Sets the translation engine that responds to tr().\n *\n * @param {function} translate Function with signature\n * \ttranslate(id, params).\n */\n\n\nfunction setTranslator(translate) {\n  exports.tr = tr = translate;\n}\n/**\n * Sets the regex for the variables\n */\n\n\nfunction setTranslateVariableRegex(newVarRegex) {\n  varRegex = newVarRegex;\n}\n/**\n * Sets the regex for the substitutions\n */\n\n\nfunction setTranslateReferenceRegex(newRefRegex) {\n  refRegex = newRefRegex;\n}"]},"metadata":{},"sourceType":"script"}