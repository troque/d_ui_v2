{"ast":null,"code":"\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _ = require(\"lodash\");\nvar cfb = require(\"cfb\");\nvar crypto = require(\"crypto\");\nvar externals = require(\"./externals\");\nvar XmlParser = require(\"./XmlParser\");\nvar XmlBuilder = require(\"./XmlBuilder\");\nvar xmlq = require(\"./xmlq\");\nvar ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nvar PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nvar PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nvar BLOCK_KEYS = {\n  dataIntegrity: {\n    hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n    hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n  },\n  key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n  verifierHash: {\n    input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n    value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n  }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nvar Encryptor = /*#__PURE__*/function () {\n  function Encryptor() {\n    _classCallCheck(this, Encryptor);\n  }\n  _createClass(Encryptor, [{\n    key: \"encrypt\",\n    value:\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    function encrypt(data, password) {\n      // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n      // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n      var packageKey = crypto.randomBytes(32);\n\n      // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n      var encryptionInfo = {\n        package: {\n          // Info on the encryption of the package.\n          cipherAlgorithm: 'AES',\n          // Cipher algorithm to use. Excel uses AES.\n          cipherChaining: 'ChainingModeCBC',\n          // Cipher chaining mode to use. Excel uses CBC.\n          saltValue: crypto.randomBytes(16),\n          // Random value to use as encryption salt. Excel uses 16 bytes.\n          hashAlgorithm: 'SHA512',\n          // Hash algorithm to use. Excel uses SHA512.\n          hashSize: 64,\n          // The size of the hash in bytes. SHA512 results in 64-byte hashes\n          blockSize: 16,\n          // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n          keyBits: packageKey.length * 8 // The number of bits in the package key.\n        },\n\n        key: {\n          // Info on the encryption of the package key.\n          cipherAlgorithm: 'AES',\n          // Cipher algorithm to use. Excel uses AES.\n          cipherChaining: 'ChainingModeCBC',\n          // Cipher chaining mode to use. Excel uses CBC.\n          saltValue: crypto.randomBytes(16),\n          // Random value to use as encryption salt. Excel uses 16 bytes.\n          hashAlgorithm: 'SHA512',\n          // Hash algorithm to use. Excel uses SHA512.\n          hashSize: 64,\n          // The size of the hash in bytes. SHA512 results in 64-byte hashes\n          blockSize: 16,\n          // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n          spinCount: 100000,\n          // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n          keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n        }\n      };\n\n      /* Package Encryption */\n\n      // Encrypt package using the package key.\n      var encryptedPackage = this._cryptPackage(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, data);\n\n      /* Data Integrity */\n\n      // Create the data integrity fields used by clients for integrity checks.\n      // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n      var hmacKey = crypto.randomBytes(64);\n\n      // Then create an initialization vector using the package encryption info and the appropriate block key.\n      var hmacKeyIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacKey);\n\n      // Use the package key and the IV to encrypt the HMAC key\n      var encryptedHmacKey = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacKeyIV, hmacKey);\n\n      // Now create the HMAC\n      var hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n      // Next generate an initialization vector for encrypting the resulting HMAC value.\n      var hmacValueIV = this._createIV(encryptionInfo.package.hashAlgorithm, encryptionInfo.package.saltValue, encryptionInfo.package.blockSize, BLOCK_KEYS.dataIntegrity.hmacValue);\n\n      // Now encrypt the value\n      var encryptedHmacValue = this._crypt(true, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, packageKey, hmacValueIV, hmacValue);\n\n      // Put the encrypted key and value on the encryption info\n      encryptionInfo.dataIntegrity = {\n        encryptedHmacKey: encryptedHmacKey,\n        encryptedHmacValue: encryptedHmacValue\n      };\n\n      /* Key Encryption */\n\n      // Convert the password to an encryption key\n      var key = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key);\n\n      // Encrypt the package key with the\n      encryptionInfo.key.encryptedKeyValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, packageKey);\n\n      /* Verifier hash */\n\n      // Create a random byte array for hashing\n      var verifierHashInput = crypto.randomBytes(16);\n\n      // Create an encryption key from the password for the input\n      var verifierHashInputKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.input);\n\n      // Use the key to encrypt the verifier input\n      encryptionInfo.key.encryptedVerifierHashInput = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashInputKey, encryptionInfo.key.saltValue, verifierHashInput);\n\n      // Create a hash of the input\n      var verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n      // Create an encryption key from the password for the hash\n      var verifierHashValueKey = this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.verifierHash.value);\n\n      // Use the key to encrypt the hash value\n      encryptionInfo.key.encryptedVerifierHashValue = this._crypt(true, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, verifierHashValueKey, encryptionInfo.key.saltValue, verifierHashValue);\n\n      // Build the encryption info buffer\n      var encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n      // Create a new CFB\n      var output = cfb.utils.cfb_new();\n\n      // Add the encryption info and encrypted package\n      cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n      cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n      // Delete the SheetJS entry that is added at initialization\n      cfb.utils.cfb_del(output, \"\\x01Sh33tJ5\");\n\n      // Write to a buffer and return\n      output = cfb.write(output);\n\n      // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n      if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n      return output;\n    }\n\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n  }, {\n    key: \"decryptAsync\",\n    value: function decryptAsync(data, password) {\n      var _this = this;\n      // Parse the CFB input and pull out the encryption info and encrypted package entries.\n      var parsed = cfb.parse(data);\n      var encryptionInfoBuffer = _.find(parsed.FileIndex, {\n        name: \"EncryptionInfo\"\n      }).content;\n      var encryptedPackageBuffer = _.find(parsed.FileIndex, {\n        name: \"EncryptedPackage\"\n      }).content;\n\n      // In the browser the CFB content is an array. Convert to a Buffer.\n      if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n      if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n      return externals.Promise.resolve().then(function () {\n        return _this._parseEncryptionInfoAsync(encryptionInfoBuffer);\n      }) // Parse the encryption info XML into an object\n      .then(function (encryptionInfo) {\n        // Convert the password into an encryption key\n        var key = _this._convertPasswordToKey(password, encryptionInfo.key.hashAlgorithm, encryptionInfo.key.saltValue, encryptionInfo.key.spinCount, encryptionInfo.key.keyBits, BLOCK_KEYS.key);\n\n        // Use the key to decrypt the package key\n        var packageKey = _this._crypt(false, encryptionInfo.key.cipherAlgorithm, encryptionInfo.key.cipherChaining, key, encryptionInfo.key.saltValue, encryptionInfo.key.encryptedKeyValue);\n\n        // Use the package key to decrypt the package\n        return _this._cryptPackage(false, encryptionInfo.package.cipherAlgorithm, encryptionInfo.package.cipherChaining, encryptionInfo.package.hashAlgorithm, encryptionInfo.package.blockSize, encryptionInfo.package.saltValue, packageKey, encryptedPackageBuffer);\n      });\n    }\n\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n  }, {\n    key: \"_buildEncryptionInfo\",\n    value: function _buildEncryptionInfo(encryptionInfo) {\n      // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n      var encryptionInfoNode = {\n        name: \"encryption\",\n        attributes: {\n          xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n          'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n          'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n        },\n        children: [{\n          name: \"keyData\",\n          attributes: {\n            saltSize: encryptionInfo.package.saltValue.length,\n            blockSize: encryptionInfo.package.blockSize,\n            keyBits: encryptionInfo.package.keyBits,\n            hashSize: encryptionInfo.package.hashSize,\n            cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n            cipherChaining: encryptionInfo.package.cipherChaining,\n            hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n            saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n          }\n        }, {\n          name: \"dataIntegrity\",\n          attributes: {\n            encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n            encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n          }\n        }, {\n          name: \"keyEncryptors\",\n          children: [{\n            name: \"keyEncryptor\",\n            attributes: {\n              uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n            },\n            children: [{\n              name: \"p:encryptedKey\",\n              attributes: {\n                spinCount: encryptionInfo.key.spinCount,\n                saltSize: encryptionInfo.key.saltValue.length,\n                blockSize: encryptionInfo.key.blockSize,\n                keyBits: encryptionInfo.key.keyBits,\n                hashSize: encryptionInfo.key.hashSize,\n                cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                cipherChaining: encryptionInfo.key.cipherChaining,\n                hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n              }\n            }]\n          }]\n        }]\n      };\n\n      // Convert to an XML string\n      var xmlBuilder = new XmlBuilder();\n      var encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n      // Convert to a buffer and prefix with the appropriate bytes\n      return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n  }, {\n    key: \"_parseEncryptionInfoAsync\",\n    value: function _parseEncryptionInfoAsync(buffer) {\n      // Pull off the prefix and convert to string\n      var xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n      // Parse the XML\n      var xmlParser = new XmlParser();\n      return xmlParser.parseAsync(xml).then(function (doc) {\n        // Pull out the relevant values for decryption and return\n        var keyDataNode = xmlq.findChild(doc, \"keyData\");\n        var keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n        var keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n        var encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n        return {\n          package: {\n            cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n            cipherChaining: keyDataNode.attributes.cipherChaining,\n            saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n            hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n            blockSize: keyDataNode.attributes.blockSize\n          },\n          key: {\n            encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n            cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n            cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n            saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n            hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n            spinCount: encryptedKeyNode.attributes.spinCount,\n            keyBits: encryptedKeyNode.attributes.keyBits\n          }\n        };\n      });\n    }\n\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n  }, {\n    key: \"_hash\",\n    value: function _hash(algorithm) {\n      algorithm = algorithm.toLowerCase();\n      var hashes = crypto.getHashes();\n      if (hashes.indexOf(algorithm) < 0) throw new Error(\"Hash algorithm '\".concat(algorithm, \"' not supported!\"));\n      var hash = crypto.createHash(algorithm);\n      for (var _len = arguments.length, buffers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        buffers[_key - 1] = arguments[_key];\n      }\n      hash.update(Buffer.concat(buffers));\n      return hash.digest();\n    }\n\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n  }, {\n    key: \"_hmac\",\n    value: function _hmac(algorithm, key) {\n      algorithm = algorithm.toLowerCase();\n      var hashes = crypto.getHashes();\n      if (hashes.indexOf(algorithm) < 0) throw new Error(\"HMAC algorithm '\".concat(algorithm, \"' not supported!\"));\n      var hmac = crypto.createHmac(algorithm, key);\n      for (var _len2 = arguments.length, buffers = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        buffers[_key2 - 2] = arguments[_key2];\n      }\n      hmac.update(Buffer.concat(buffers));\n      return hmac.digest();\n    }\n\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n  }, {\n    key: \"_crypt\",\n    value: function _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n      var algorithm = \"\".concat(cipherAlgorithm.toLowerCase(), \"-\").concat(key.length * 8);\n      if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';else throw new Error(\"Unknown cipher chaining: \".concat(cipherChaining));\n      var cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n      cipher.setAutoPadding(false);\n      var output = cipher.update(input);\n      output = Buffer.concat([output, cipher.final()]);\n      return output;\n    }\n\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n  }, {\n    key: \"_cryptPackage\",\n    value: function _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n      // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n      var outputChunks = [];\n      var offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n      // The package is encoded in chunks. Encrypt/decrypt each and concat.\n      var i = 0,\n        start = 0,\n        end = 0;\n      while (end < input.length) {\n        start = end;\n        end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n        if (end > input.length) end = input.length;\n\n        // Grab the next chunk\n        var inputChunk = input.slice(start + offset, end + offset);\n\n        // Pad the chunk if it is not an integer multiple of the block size\n        var remainder = inputChunk.length % blockSize;\n        if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n        // Create the initialization vector\n        var iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n        // Encrypt/decrypt the chunk and add it to the array\n        var outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n        outputChunks.push(outputChunk);\n        i++;\n      }\n\n      // Concat all of the output chunks.\n      var output = Buffer.concat(outputChunks);\n      if (encrypt) {\n        // Put the length of the package in the first 8 bytes\n        output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n      } else {\n        // Truncate the buffer to the size in the prefix\n        var length = input.readUInt32LE(0);\n        output = output.slice(0, length);\n      }\n      return output;\n    }\n\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n  }, {\n    key: \"_createUInt32LEBuffer\",\n    value: function _createUInt32LEBuffer(value) {\n      var bufferSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n      var buffer = Buffer.alloc(bufferSize);\n      buffer.writeUInt32LE(value, 0);\n      return buffer;\n    }\n\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n  }, {\n    key: \"_convertPasswordToKey\",\n    value: function _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n      // Password must be in unicode buffer\n      var passwordBuffer = Buffer.from(password, 'utf16le');\n\n      // Generate the initial hash\n      var key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n      // Now regenerate until spin count\n      for (var i = 0; i < spinCount; i++) {\n        var iterator = this._createUInt32LEBuffer(i);\n        key = this._hash(hashAlgorithm, iterator, key);\n      }\n\n      // Now generate the final hash\n      key = this._hash(hashAlgorithm, key, blockKey);\n\n      // Truncate or pad as needed to get to length of keyBits\n      var keyBytes = keyBits / 8;\n      if (key.length < keyBytes) {\n        var tmp = Buffer.alloc(keyBytes, 0x36);\n        key.copy(tmp);\n        key = tmp;\n      } else if (key.length > keyBytes) {\n        key = key.slice(0, keyBytes);\n      }\n      return key;\n    }\n\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n  }, {\n    key: \"_createIV\",\n    value: function _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n      // Create the block key from the current index\n      if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n      // Create the initialization vector by hashing the salt with the block key.\n      // Truncate or pad as needed to meet the block size.\n      var iv = this._hash(hashAlgorithm, saltValue, blockKey);\n      if (iv.length < blockSize) {\n        var tmp = Buffer.alloc(blockSize, 0x36);\n        iv.copy(tmp);\n        iv = tmp;\n      } else if (iv.length > blockSize) {\n        iv = iv.slice(0, blockSize);\n      }\n      return iv;\n    }\n  }]);\n  return Encryptor;\n}();\nmodule.exports = Encryptor;","map":{"version":3,"names":["_","require","cfb","crypto","externals","XmlParser","XmlBuilder","xmlq","ENCRYPTION_INFO_PREFIX","Buffer","from","PACKAGE_ENCRYPTION_CHUNK_SIZE","PACKAGE_OFFSET","BLOCK_KEYS","dataIntegrity","hmacKey","hmacValue","key","verifierHash","input","value","Encryptor","data","password","packageKey","randomBytes","encryptionInfo","package","cipherAlgorithm","cipherChaining","saltValue","hashAlgorithm","hashSize","blockSize","keyBits","length","spinCount","encryptedPackage","_cryptPackage","hmacKeyIV","_createIV","encryptedHmacKey","_crypt","_hmac","hmacValueIV","encryptedHmacValue","_convertPasswordToKey","encryptedKeyValue","verifierHashInput","verifierHashInputKey","encryptedVerifierHashInput","verifierHashValue","_hash","verifierHashValueKey","encryptedVerifierHashValue","encryptionInfoBuffer","_buildEncryptionInfo","output","utils","cfb_new","cfb_add","cfb_del","write","isBuffer","parsed","parse","find","FileIndex","name","content","encryptedPackageBuffer","Promise","resolve","then","_parseEncryptionInfoAsync","encryptionInfoNode","attributes","xmlns","children","saltSize","toString","uri","xmlBuilder","encryptionInfoXml","build","concat","buffer","xml","slice","xmlParser","parseAsync","doc","keyDataNode","findChild","keyEncryptorsNode","keyEncryptorNode","encryptedKeyNode","algorithm","toLowerCase","hashes","getHashes","indexOf","Error","hash","createHash","buffers","update","digest","hmac","createHmac","encrypt","iv","cipher","setAutoPadding","final","outputChunks","offset","i","start","end","inputChunk","remainder","alloc","outputChunk","push","_createUInt32LEBuffer","readUInt32LE","bufferSize","writeUInt32LE","blockKey","passwordBuffer","iterator","keyBytes","tmp","copy","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Encryptor.js"],"sourcesContent":["\"use strict\";\n\n/**\n * OOXML uses the CFB file format with Agile Encryption. The details of the encryption are here:\n * https://msdn.microsoft.com/en-us/library/dd950165(v=office.12).aspx\n *\n * Helpful guidance also take from this Github project:\n * https://github.com/nolze/ms-offcrypto-tool\n */\n\nconst _ = require(\"lodash\");\nconst cfb = require(\"cfb\");\nconst crypto = require(\"crypto\");\nconst externals = require(\"./externals\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst xmlq = require(\"./xmlq\");\n\nconst ENCRYPTION_INFO_PREFIX = Buffer.from([0x04, 0x00, 0x04, 0x00, 0x40, 0x00, 0x00, 0x00]); // First 4 bytes are the version number, second 4 bytes are reserved.\nconst PACKAGE_ENCRYPTION_CHUNK_SIZE = 4096;\nconst PACKAGE_OFFSET = 8; // First 8 bytes are the size of the stream\n\n// Block keys used for encryption\nconst BLOCK_KEYS = {\n    dataIntegrity: {\n        hmacKey: Buffer.from([0x5f, 0xb2, 0xad, 0x01, 0x0c, 0xb9, 0xe1, 0xf6]),\n        hmacValue: Buffer.from([0xa0, 0x67, 0x7f, 0x02, 0xb2, 0x2c, 0x84, 0x33])\n    },\n    key: Buffer.from([0x14, 0x6e, 0x0b, 0xe7, 0xab, 0xac, 0xd0, 0xd6]),\n    verifierHash: {\n        input: Buffer.from([0xfe, 0xa7, 0xd2, 0x76, 0x3b, 0x4b, 0x9e, 0x79]),\n        value: Buffer.from([0xd7, 0xaa, 0x0f, 0x6d, 0x30, 0x61, 0x34, 0x4e])\n    }\n};\n\n/**\n * Encrypts/decrypts XLSXs.\n * @private\n */\nclass Encryptor {\n    /**\n     * Encrypt the data with the password.\n     * @param {Buffer} data - The data to encrypt\n     * @param {string} password - The password\n     * @returns {Buffer} The encrypted data\n     */\n    encrypt(data, password) {\n        // Generate a random key to use to encrypt the document. Excel uses 32 bytes. We'll use the password to encrypt this key.\n        // N.B. The number of bits needs to correspond to an algorithm available in crypto (e.g. aes-256-cbc).\n        const packageKey = crypto.randomBytes(32);\n\n        // Create the encryption info. We'll use this for all of the encryption operations and for building the encryption info XML entry\n        const encryptionInfo = {\n            package: { // Info on the encryption of the package.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                keyBits: packageKey.length * 8 // The number of bits in the package key.\n            },\n            key: { // Info on the encryption of the package key.\n                cipherAlgorithm: 'AES', // Cipher algorithm to use. Excel uses AES.\n                cipherChaining: 'ChainingModeCBC', // Cipher chaining mode to use. Excel uses CBC.\n                saltValue: crypto.randomBytes(16), // Random value to use as encryption salt. Excel uses 16 bytes.\n                hashAlgorithm: 'SHA512', // Hash algorithm to use. Excel uses SHA512.\n                hashSize: 64, // The size of the hash in bytes. SHA512 results in 64-byte hashes\n                blockSize: 16, // The number of bytes used to encrypt one block of data. It MUST be at least 2, no greater than 4096, and a multiple of 2. Excel uses 16\n                spinCount: 100000, // The number of times to iterate on a hash of a password. It MUST NOT be greater than 10,000,000. Excel uses 100,000.\n                keyBits: 256 // The length of the key to generate from the password. Must be a multiple of 8. Excel uses 256.\n            }\n        };\n\n        /* Package Encryption */\n\n        // Encrypt package using the package key.\n        const encryptedPackage = this._cryptPackage(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.blockSize,\n            encryptionInfo.package.saltValue,\n            packageKey,\n            data\n        );\n\n        /* Data Integrity */\n\n        // Create the data integrity fields used by clients for integrity checks.\n        // First generate a random array of bytes to use in HMAC. The docs say to use the same length as the key salt, but Excel seems to use 64.\n        const hmacKey = crypto.randomBytes(64);\n\n        // Then create an initialization vector using the package encryption info and the appropriate block key.\n        const hmacKeyIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacKey\n        );\n\n        // Use the package key and the IV to encrypt the HMAC key\n        const encryptedHmacKey = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacKeyIV,\n            hmacKey);\n\n        // Now create the HMAC\n        const hmacValue = this._hmac(encryptionInfo.package.hashAlgorithm, hmacKey, encryptedPackage);\n\n        // Next generate an initialization vector for encrypting the resulting HMAC value.\n        const hmacValueIV = this._createIV(\n            encryptionInfo.package.hashAlgorithm,\n            encryptionInfo.package.saltValue,\n            encryptionInfo.package.blockSize,\n            BLOCK_KEYS.dataIntegrity.hmacValue\n        );\n\n        // Now encrypt the value\n        const encryptedHmacValue = this._crypt(\n            true,\n            encryptionInfo.package.cipherAlgorithm,\n            encryptionInfo.package.cipherChaining,\n            packageKey,\n            hmacValueIV,\n            hmacValue\n        );\n\n        // Put the encrypted key and value on the encryption info\n        encryptionInfo.dataIntegrity = {\n            encryptedHmacKey,\n            encryptedHmacValue\n        };\n\n        /* Key Encryption */\n\n        // Convert the password to an encryption key\n        const key = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.key\n        );\n\n        // Encrypt the package key with the\n        encryptionInfo.key.encryptedKeyValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            key,\n            encryptionInfo.key.saltValue,\n            packageKey);\n\n        /* Verifier hash */\n\n        // Create a random byte array for hashing\n        const verifierHashInput = crypto.randomBytes(16);\n\n        // Create an encryption key from the password for the input\n        const verifierHashInputKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.input\n        );\n\n        // Use the key to encrypt the verifier input\n        encryptionInfo.key.encryptedVerifierHashInput = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashInputKey,\n            encryptionInfo.key.saltValue,\n            verifierHashInput\n        );\n\n        // Create a hash of the input\n        const verifierHashValue = this._hash(encryptionInfo.key.hashAlgorithm, verifierHashInput);\n\n        // Create an encryption key from the password for the hash\n        const verifierHashValueKey = this._convertPasswordToKey(\n            password,\n            encryptionInfo.key.hashAlgorithm,\n            encryptionInfo.key.saltValue,\n            encryptionInfo.key.spinCount,\n            encryptionInfo.key.keyBits,\n            BLOCK_KEYS.verifierHash.value\n        );\n\n        // Use the key to encrypt the hash value\n        encryptionInfo.key.encryptedVerifierHashValue = this._crypt(\n            true,\n            encryptionInfo.key.cipherAlgorithm,\n            encryptionInfo.key.cipherChaining,\n            verifierHashValueKey,\n            encryptionInfo.key.saltValue,\n            verifierHashValue\n        );\n\n        // Build the encryption info buffer\n        const encryptionInfoBuffer = this._buildEncryptionInfo(encryptionInfo);\n\n        // Create a new CFB\n        let output = cfb.utils.cfb_new();\n\n        // Add the encryption info and encrypted package\n        cfb.utils.cfb_add(output, \"EncryptionInfo\", encryptionInfoBuffer);\n        cfb.utils.cfb_add(output, \"EncryptedPackage\", encryptedPackage);\n\n        // Delete the SheetJS entry that is added at initialization\n        cfb.utils.cfb_del(output, \"\\u0001Sh33tJ5\");\n\n        // Write to a buffer and return\n        output = cfb.write(output);\n\n        // The cfb library writes to a Uint8array in the browser. Convert to a Buffer.\n        if (!Buffer.isBuffer(output)) output = Buffer.from(output);\n\n        return output;\n    }\n\n    /**\n     * Decrypt the data with the given password\n     * @param {Buffer} data - The data to decrypt\n     * @param {string} password - The password\n     * @returns {Promise.<Buffer>} The decrypted data\n     */\n    decryptAsync(data, password) {\n        // Parse the CFB input and pull out the encryption info and encrypted package entries.\n        const parsed = cfb.parse(data);\n        let encryptionInfoBuffer = _.find(parsed.FileIndex, { name: \"EncryptionInfo\" }).content;\n        let encryptedPackageBuffer = _.find(parsed.FileIndex, { name: \"EncryptedPackage\" }).content;\n\n        // In the browser the CFB content is an array. Convert to a Buffer.\n        if (!Buffer.isBuffer(encryptionInfoBuffer)) encryptionInfoBuffer = Buffer.from(encryptionInfoBuffer);\n        if (!Buffer.isBuffer(encryptedPackageBuffer)) encryptedPackageBuffer = Buffer.from(encryptedPackageBuffer);\n\n        return externals.Promise.resolve()\n            .then(() => this._parseEncryptionInfoAsync(encryptionInfoBuffer)) // Parse the encryption info XML into an object\n            .then(encryptionInfo => {\n                // Convert the password into an encryption key\n                const key = this._convertPasswordToKey(\n                    password,\n                    encryptionInfo.key.hashAlgorithm,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.spinCount,\n                    encryptionInfo.key.keyBits,\n                    BLOCK_KEYS.key\n                );\n\n                // Use the key to decrypt the package key\n                const packageKey = this._crypt(\n                    false,\n                    encryptionInfo.key.cipherAlgorithm,\n                    encryptionInfo.key.cipherChaining,\n                    key,\n                    encryptionInfo.key.saltValue,\n                    encryptionInfo.key.encryptedKeyValue\n                );\n\n                // Use the package key to decrypt the package\n                return this._cryptPackage(\n                    false,\n                    encryptionInfo.package.cipherAlgorithm,\n                    encryptionInfo.package.cipherChaining,\n                    encryptionInfo.package.hashAlgorithm,\n                    encryptionInfo.package.blockSize,\n                    encryptionInfo.package.saltValue,\n                    packageKey,\n                    encryptedPackageBuffer);\n            });\n    }\n\n    /**\n     * Build the encryption info XML/buffer\n     * @param {{}} encryptionInfo - The encryption info object\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _buildEncryptionInfo(encryptionInfo) {\n        // Map the object into the appropriate XML structure. Buffers are encoded in base 64.\n        const encryptionInfoNode = {\n            name: \"encryption\",\n            attributes: {\n                xmlns: \"http://schemas.microsoft.com/office/2006/encryption\",\n                'xmlns:p': \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\",\n                'xmlns:c': \"http://schemas.microsoft.com/office/2006/keyEncryptor/certificate\"\n            },\n            children: [\n                {\n                    name: \"keyData\",\n                    attributes: {\n                        saltSize: encryptionInfo.package.saltValue.length,\n                        blockSize: encryptionInfo.package.blockSize,\n                        keyBits: encryptionInfo.package.keyBits,\n                        hashSize: encryptionInfo.package.hashSize,\n                        cipherAlgorithm: encryptionInfo.package.cipherAlgorithm,\n                        cipherChaining: encryptionInfo.package.cipherChaining,\n                        hashAlgorithm: encryptionInfo.package.hashAlgorithm,\n                        saltValue: encryptionInfo.package.saltValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"dataIntegrity\",\n                    attributes: {\n                        encryptedHmacKey: encryptionInfo.dataIntegrity.encryptedHmacKey.toString(\"base64\"),\n                        encryptedHmacValue: encryptionInfo.dataIntegrity.encryptedHmacValue.toString(\"base64\")\n                    }\n                },\n                {\n                    name: \"keyEncryptors\",\n                    children: [\n                        {\n                            name: \"keyEncryptor\",\n                            attributes: {\n                                uri: \"http://schemas.microsoft.com/office/2006/keyEncryptor/password\"\n                            },\n                            children: [\n                                {\n                                    name: \"p:encryptedKey\",\n                                    attributes: {\n                                        spinCount: encryptionInfo.key.spinCount,\n                                        saltSize: encryptionInfo.key.saltValue.length,\n                                        blockSize: encryptionInfo.key.blockSize,\n                                        keyBits: encryptionInfo.key.keyBits,\n                                        hashSize: encryptionInfo.key.hashSize,\n                                        cipherAlgorithm: encryptionInfo.key.cipherAlgorithm,\n                                        cipherChaining: encryptionInfo.key.cipherChaining,\n                                        hashAlgorithm: encryptionInfo.key.hashAlgorithm,\n                                        saltValue: encryptionInfo.key.saltValue.toString(\"base64\"),\n                                        encryptedVerifierHashInput: encryptionInfo.key.encryptedVerifierHashInput.toString(\"base64\"),\n                                        encryptedVerifierHashValue: encryptionInfo.key.encryptedVerifierHashValue.toString(\"base64\"),\n                                        encryptedKeyValue: encryptionInfo.key.encryptedKeyValue.toString(\"base64\")\n                                    }\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        };\n\n        // Convert to an XML string\n        const xmlBuilder = new XmlBuilder();\n        const encryptionInfoXml = xmlBuilder.build(encryptionInfoNode);\n\n        // Convert to a buffer and prefix with the appropriate bytes\n        return Buffer.concat([ENCRYPTION_INFO_PREFIX, Buffer.from(encryptionInfoXml, \"utf8\")]);\n    }\n\n    /**\n     * Parse the encryption info from the XML/buffer\n     * @param {Buffer} buffer - The buffer\n     * @returns {Promise.<{}>} The parsed encryption info object\n     * @private\n     */\n    _parseEncryptionInfoAsync(buffer) {\n        // Pull off the prefix and convert to string\n        const xml = buffer.slice(ENCRYPTION_INFO_PREFIX.length).toString(\"utf8\");\n\n        // Parse the XML\n        const xmlParser = new XmlParser();\n        return xmlParser.parseAsync(xml)\n            .then(doc => {\n                // Pull out the relevant values for decryption and return\n                const keyDataNode = xmlq.findChild(doc, \"keyData\");\n                const keyEncryptorsNode = xmlq.findChild(doc, \"keyEncryptors\");\n                const keyEncryptorNode = xmlq.findChild(keyEncryptorsNode, \"keyEncryptor\");\n                const encryptedKeyNode = xmlq.findChild(keyEncryptorNode, \"p:encryptedKey\");\n\n                return {\n                    package: {\n                        cipherAlgorithm: keyDataNode.attributes.cipherAlgorithm,\n                        cipherChaining: keyDataNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(keyDataNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: keyDataNode.attributes.hashAlgorithm,\n                        blockSize: keyDataNode.attributes.blockSize\n                    },\n                    key: {\n                        encryptedKeyValue: Buffer.from(encryptedKeyNode.attributes.encryptedKeyValue, \"base64\"),\n                        cipherAlgorithm: encryptedKeyNode.attributes.cipherAlgorithm,\n                        cipherChaining: encryptedKeyNode.attributes.cipherChaining,\n                        saltValue: Buffer.from(encryptedKeyNode.attributes.saltValue, \"base64\"),\n                        hashAlgorithm: encryptedKeyNode.attributes.hashAlgorithm,\n                        spinCount: encryptedKeyNode.attributes.spinCount,\n                        keyBits: encryptedKeyNode.attributes.keyBits\n                    }\n                };\n            });\n    }\n\n    /**\n     * Calculate a hash of the concatenated buffers with the given algorithm.\n     * @param {string} algorithm - The hash algorithm.\n     * @param {Array.<Buffer>} buffers - The buffers to concat and hash\n     * @returns {Buffer} The hash\n     * @private\n     */\n    _hash(algorithm, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`Hash algorithm '${algorithm}' not supported!`);\n\n        const hash = crypto.createHash(algorithm);\n        hash.update(Buffer.concat(buffers));\n        return hash.digest();\n    }\n\n    /**\n     * Calculate an HMAC of the concatenated buffers with the given algorithm and key\n     * @param {string} algorithm - The algorithm.\n     * @param {string} key - The key\n     * @param {Array.<Buffer>} buffers - The buffer to concat and HMAC\n     * @returns {Buffer} The HMAC\n     * @private\n     */\n    _hmac(algorithm, key, ...buffers) {\n        algorithm = algorithm.toLowerCase();\n        const hashes = crypto.getHashes();\n        if (hashes.indexOf(algorithm) < 0) throw new Error(`HMAC algorithm '${algorithm}' not supported!`);\n\n        const hmac = crypto.createHmac(algorithm, key);\n        hmac.update(Buffer.concat(buffers));\n        return hmac.digest();\n    }\n\n    /**\n     * Encrypt/decrypt input\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {sring} cipherChaining - The cipher chaining mode\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} iv - The initialization vector\n     * @param {Buffer} input - The input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, input) {\n        let algorithm = `${cipherAlgorithm.toLowerCase()}-${key.length * 8}`;\n        if (cipherChaining === 'ChainingModeCBC') algorithm += '-cbc';\n        else throw new Error(`Unknown cipher chaining: ${cipherChaining}`);\n\n        const cipher = crypto[encrypt ? 'createCipheriv' : 'createDecipheriv'](algorithm, key, iv);\n        cipher.setAutoPadding(false);\n        let output = cipher.update(input);\n        output = Buffer.concat([output, cipher.final()]);\n        return output;\n    }\n\n    /**\n     * Encrypt/decrypt the package\n     * @param {boolean} encrypt - True to encrypt, false to decrypt\n     * @param {string} cipherAlgorithm - The cipher algorithm\n     * @param {string} cipherChaining - The cipher chaining mode\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {number} blockSize - The IV block size\n     * @param {Buffer} saltValue - The salt\n     * @param {Buffer} key - The encryption key\n     * @param {Buffer} input - The package input\n     * @returns {Buffer} The output\n     * @private\n     */\n    _cryptPackage(encrypt, cipherAlgorithm, cipherChaining, hashAlgorithm, blockSize, saltValue, key, input) {\n        // The first 8 bytes is supposed to be the length, but it seems like it is really the length - 4..\n        const outputChunks = [];\n        const offset = encrypt ? 0 : PACKAGE_OFFSET;\n\n        // The package is encoded in chunks. Encrypt/decrypt each and concat.\n        let i = 0, start = 0, end = 0;\n        while (end < input.length) {\n            start = end;\n            end = start + PACKAGE_ENCRYPTION_CHUNK_SIZE;\n            if (end > input.length) end = input.length;\n\n            // Grab the next chunk\n            let inputChunk = input.slice(start + offset, end + offset);\n\n            // Pad the chunk if it is not an integer multiple of the block size\n            const remainder = inputChunk.length % blockSize;\n            if (remainder) inputChunk = Buffer.concat([inputChunk, Buffer.alloc(blockSize - remainder)]);\n\n            // Create the initialization vector\n            const iv = this._createIV(hashAlgorithm, saltValue, blockSize, i);\n\n            // Encrypt/decrypt the chunk and add it to the array\n            const outputChunk = this._crypt(encrypt, cipherAlgorithm, cipherChaining, key, iv, inputChunk);\n            outputChunks.push(outputChunk);\n\n            i++;\n        }\n\n        // Concat all of the output chunks.\n        let output = Buffer.concat(outputChunks);\n\n        if (encrypt) {\n            // Put the length of the package in the first 8 bytes\n            output = Buffer.concat([this._createUInt32LEBuffer(input.length, PACKAGE_OFFSET), output]);\n        } else {\n            // Truncate the buffer to the size in the prefix\n            const length = input.readUInt32LE(0);\n            output = output.slice(0, length);\n        }\n\n        return output;\n    }\n\n    /**\n     * Create a buffer of an integer encoded as a uint32le\n     * @param {number} value - The integer to encode\n     * @param {number} [bufferSize=4] The output buffer size in bytes\n     * @returns {Buffer} The buffer\n     * @private\n     */\n    _createUInt32LEBuffer(value, bufferSize = 4) {\n        const buffer = Buffer.alloc(bufferSize);\n        buffer.writeUInt32LE(value, 0);\n        return buffer;\n    }\n\n    /**\n     * Convert a password into an encryption key\n     * @param {string} password - The password\n     * @param {string} hashAlgorithm - The hash algoritm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} spinCount - The spin count\n     * @param {number} keyBits - The length of the key in bits\n     * @param {Buffer} blockKey - The block key\n     * @returns {Buffer} The encryption key\n     * @private\n     */\n    _convertPasswordToKey(password, hashAlgorithm, saltValue, spinCount, keyBits, blockKey) {\n        // Password must be in unicode buffer\n        const passwordBuffer = Buffer.from(password, 'utf16le');\n\n        // Generate the initial hash\n        let key = this._hash(hashAlgorithm, saltValue, passwordBuffer);\n\n        // Now regenerate until spin count\n        for (let i = 0; i < spinCount; i++) {\n            const iterator = this._createUInt32LEBuffer(i);\n            key = this._hash(hashAlgorithm, iterator, key);\n        }\n\n        // Now generate the final hash\n        key = this._hash(hashAlgorithm, key, blockKey);\n\n        // Truncate or pad as needed to get to length of keyBits\n        const keyBytes = keyBits / 8;\n        if (key.length < keyBytes) {\n            const tmp = Buffer.alloc(keyBytes, 0x36);\n            key.copy(tmp);\n            key = tmp;\n        } else if (key.length > keyBytes) {\n            key = key.slice(0, keyBytes);\n        }\n\n        return key;\n    }\n\n    /**\n     * Create an initialization vector (IV)\n     * @param {string} hashAlgorithm - The hash algorithm\n     * @param {Buffer} saltValue - The salt value\n     * @param {number} blockSize - The size of the IV\n     * @param {Buffer|number} blockKey - The block key or an int to convert to a buffer\n     * @returns {Buffer} The IV\n     * @private\n     */\n    _createIV(hashAlgorithm, saltValue, blockSize, blockKey) {\n        // Create the block key from the current index\n        if (typeof blockKey === \"number\") blockKey = this._createUInt32LEBuffer(blockKey);\n\n        // Create the initialization vector by hashing the salt with the block key.\n        // Truncate or pad as needed to meet the block size.\n        let iv = this._hash(hashAlgorithm, saltValue, blockKey);\n        if (iv.length < blockSize) {\n            const tmp = Buffer.alloc(blockSize, 0x36);\n            iv.copy(tmp);\n            iv = tmp;\n        } else if (iv.length > blockSize) {\n            iv = iv.slice(0, blockSize);\n        }\n\n        return iv;\n    }\n}\n\nmodule.exports = Encryptor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}