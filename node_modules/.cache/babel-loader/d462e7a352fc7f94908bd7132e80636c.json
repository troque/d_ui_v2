{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar sax = require(\"sax\");\nvar externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nvar allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nvar XmlParser = /*#__PURE__*/function () {\n  function XmlParser() {\n    _classCallCheck(this, XmlParser);\n  }\n  _createClass(XmlParser, [{\n    key: \"parseAsync\",\n    value:\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    function parseAsync(xmlText) {\n      var _this = this;\n      return new externals.Promise(function (resolve, reject) {\n        // Create the SAX parser.\n        var parser = sax.parser(true);\n\n        // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n        // nodes leading to the current one.\n        var parsed, current;\n        var stack = [];\n\n        // On error: Reject the promise.\n        parser.onerror = reject;\n\n        // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n        parser.ontext = function (text) {\n          if (allWhitespaceRegex.test(text)) {\n            if (current && current.attributes['xml:space'] === 'preserve') {\n              current.children.push(text);\n            }\n          } else {\n            current.children.push(_this._covertToNumberIfNumber(text));\n          }\n        };\n\n        // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n        // it as a child to the current node.\n        parser.onopentagstart = function (node) {\n          var child = {\n            name: node.name,\n            attributes: {},\n            children: []\n          };\n          if (current) {\n            current.children.push(child);\n          } else {\n            parsed = child;\n          }\n          stack.push(child);\n          current = child;\n        };\n\n        // On close tag: Pop the stack.\n        parser.onclosetag = function (node) {\n          stack.pop();\n          current = stack[stack.length - 1];\n        };\n\n        // On attribute: Try to convert the value to a number and add to the current node.\n        parser.onattribute = function (attribute) {\n          current.attributes[attribute.name] = _this._covertToNumberIfNumber(attribute.value);\n        };\n\n        // On end: Resolve the promise.\n        parser.onend = function () {\n          return resolve(parsed);\n        };\n\n        // Start parsing the text.\n        parser.write(xmlText).close();\n      });\n    }\n\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n  }, {\n    key: \"_covertToNumberIfNumber\",\n    value: function _covertToNumberIfNumber(str) {\n      var num = Number(str);\n      return num.toString() === str ? num : str;\n    }\n  }]);\n  return XmlParser;\n}();\nmodule.exports = XmlParser;","map":{"version":3,"names":["sax","require","externals","allWhitespaceRegex","XmlParser","xmlText","Promise","resolve","reject","parser","parsed","current","stack","onerror","ontext","text","test","attributes","children","push","_covertToNumberIfNumber","onopentagstart","node","child","name","onclosetag","pop","length","onattribute","attribute","value","onend","write","close","str","num","Number","toString","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/XmlParser.js"],"sourcesContent":["\"use strict\";\n\nconst sax = require(\"sax\");\nconst externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nconst allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nclass XmlParser {\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    parseAsync(xmlText) {\n        return new externals.Promise((resolve, reject) => {\n            // Create the SAX parser.\n            const parser = sax.parser(true);\n\n            // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n            // nodes leading to the current one.\n            let parsed, current;\n            const stack = [];\n\n            // On error: Reject the promise.\n            parser.onerror = reject;\n\n            // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n            parser.ontext = text => {\n                if (allWhitespaceRegex.test(text)) {\n                    if (current && current.attributes['xml:space'] === 'preserve') {\n                        current.children.push(text);\n                    }\n                } else {\n                    current.children.push(this._covertToNumberIfNumber(text));\n                }\n            };\n\n            // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n            // it as a child to the current node.\n            parser.onopentagstart = node => {\n                const child = { name: node.name, attributes: {}, children: [] };\n                if (current) {\n                    current.children.push(child);\n                } else {\n                    parsed = child;\n                }\n\n                stack.push(child);\n                current = child;\n            };\n\n            // On close tag: Pop the stack.\n            parser.onclosetag = node => {\n                stack.pop();\n                current = stack[stack.length - 1];\n            };\n\n            // On attribute: Try to convert the value to a number and add to the current node.\n            parser.onattribute = attribute => {\n                current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n            };\n\n            // On end: Resolve the promise.\n            parser.onend = () => resolve(parsed);\n\n            // Start parsing the text.\n            parser.write(xmlText).close();\n        });\n    }\n\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n    _covertToNumberIfNumber(str) {\n        const num = Number(str);\n        return num.toString() === str ? num : str;\n    }\n}\n\nmodule.exports = XmlParser;\n"],"mappings":"AAAA,YAAY;;AAAC;AAAA;AAEb,IAAMA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC1B,IAAMC,SAAS,GAAGD,OAAO,CAAC,aAAa,CAAC;;AAExC;AACA,IAAME,kBAAkB,GAAG,OAAO;;AAElC;AACA;AACA;AACA;AAHA,IAIMC,SAAS;EAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IACX;AACJ;AACA;AACA;AACA;IACI,oBAAWC,OAAO,EAAE;MAAA;MAChB,OAAO,IAAIH,SAAS,CAACI,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;QAC9C;QACA,IAAMC,MAAM,GAAGT,GAAG,CAACS,MAAM,CAAC,IAAI,CAAC;;QAE/B;QACA;QACA,IAAIC,MAAM,EAAEC,OAAO;QACnB,IAAMC,KAAK,GAAG,EAAE;;QAEhB;QACAH,MAAM,CAACI,OAAO,GAAGL,MAAM;;QAEvB;QACAC,MAAM,CAACK,MAAM,GAAG,UAAAC,IAAI,EAAI;UACpB,IAAIZ,kBAAkB,CAACa,IAAI,CAACD,IAAI,CAAC,EAAE;YAC/B,IAAIJ,OAAO,IAAIA,OAAO,CAACM,UAAU,CAAC,WAAW,CAAC,KAAK,UAAU,EAAE;cAC3DN,OAAO,CAACO,QAAQ,CAACC,IAAI,CAACJ,IAAI,CAAC;YAC/B;UACJ,CAAC,MAAM;YACHJ,OAAO,CAACO,QAAQ,CAACC,IAAI,CAAC,KAAI,CAACC,uBAAuB,CAACL,IAAI,CAAC,CAAC;UAC7D;QACJ,CAAC;;QAED;QACA;QACAN,MAAM,CAACY,cAAc,GAAG,UAAAC,IAAI,EAAI;UAC5B,IAAMC,KAAK,GAAG;YAAEC,IAAI,EAAEF,IAAI,CAACE,IAAI;YAAEP,UAAU,EAAE,CAAC,CAAC;YAAEC,QAAQ,EAAE;UAAG,CAAC;UAC/D,IAAIP,OAAO,EAAE;YACTA,OAAO,CAACO,QAAQ,CAACC,IAAI,CAACI,KAAK,CAAC;UAChC,CAAC,MAAM;YACHb,MAAM,GAAGa,KAAK;UAClB;UAEAX,KAAK,CAACO,IAAI,CAACI,KAAK,CAAC;UACjBZ,OAAO,GAAGY,KAAK;QACnB,CAAC;;QAED;QACAd,MAAM,CAACgB,UAAU,GAAG,UAAAH,IAAI,EAAI;UACxBV,KAAK,CAACc,GAAG,EAAE;UACXf,OAAO,GAAGC,KAAK,CAACA,KAAK,CAACe,MAAM,GAAG,CAAC,CAAC;QACrC,CAAC;;QAED;QACAlB,MAAM,CAACmB,WAAW,GAAG,UAAAC,SAAS,EAAI;UAC9BlB,OAAO,CAACM,UAAU,CAACY,SAAS,CAACL,IAAI,CAAC,GAAG,KAAI,CAACJ,uBAAuB,CAACS,SAAS,CAACC,KAAK,CAAC;QACtF,CAAC;;QAED;QACArB,MAAM,CAACsB,KAAK,GAAG;UAAA,OAAMxB,OAAO,CAACG,MAAM,CAAC;QAAA;;QAEpC;QACAD,MAAM,CAACuB,KAAK,CAAC3B,OAAO,CAAC,CAAC4B,KAAK,EAAE;MACjC,CAAC,CAAC;IACN;;IAEA;AACJ;AACA;AACA;AACA;AACA;EALI;IAAA;IAAA,OAMA,iCAAwBC,GAAG,EAAE;MACzB,IAAMC,GAAG,GAAGC,MAAM,CAACF,GAAG,CAAC;MACvB,OAAOC,GAAG,CAACE,QAAQ,EAAE,KAAKH,GAAG,GAAGC,GAAG,GAAGD,GAAG;IAC7C;EAAC;EAAA;AAAA;AAGLI,MAAM,CAACC,OAAO,GAAGnC,SAAS"},"metadata":{},"sourceType":"script"}