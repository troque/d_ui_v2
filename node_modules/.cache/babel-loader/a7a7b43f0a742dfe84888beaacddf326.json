{"ast":null,"code":"\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n/**\n * A range of cells.\n */\nclass Range {\n  // /**\n  //  * Creates a new instance of Range.\n  //  * @param {Cell} startCell - The start cell.\n  //  * @param {Cell} endCell - The end cell.\n  //  */\n  constructor(startCell, endCell) {\n    this._startCell = startCell;\n    this._endCell = endCell;\n    this._findRangeExtent(startCell, endCell);\n  }\n\n  /**\n   * Get the address of the range.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n   * @param {boolean} [opts.startRowAnchored] - Anchor the start row.\n   * @param {boolean} [opts.startColumnAnchored] - Anchor the start column.\n   * @param {boolean} [opts.endRowAnchored] - Anchor the end row.\n   * @param {boolean} [opts.endColumnAnchored] - Anchor the end column.\n   * @param {boolean} [opts.anchored] - Anchor all row and columns.\n   * @returns {string} The address.\n   */\n  address(opts) {\n    return addressConverter.toAddress({\n      type: 'range',\n      startRowNumber: this.startCell().rowNumber(),\n      startRowAnchored: opts && (opts.startRowAnchored || opts.anchored),\n      startColumnName: this.startCell().columnName(),\n      startColumnAnchored: opts && (opts.startColumnAnchored || opts.anchored),\n      endRowNumber: this.endCell().rowNumber(),\n      endRowAnchored: opts && (opts.endRowAnchored || opts.anchored),\n      endColumnName: this.endCell().columnName(),\n      endColumnAnchored: opts && (opts.endColumnAnchored || opts.anchored),\n      sheetName: opts && opts.includeSheetName && this.sheet().name()\n    });\n  }\n\n  /**\n   * Gets a cell within the range.\n   * @param {number} ri - Row index relative to the top-left corner of the range (0-based).\n   * @param {number} ci - Column index relative to the top-left corner of the range (0-based).\n   * @returns {Cell} The cell.\n   */\n  cell(ri, ci) {\n    return this.sheet().cell(this._minRowNumber + ri, this._minColumnNumber + ci);\n  }\n\n  /**\n   * Sets sheet autoFilter to this range.\n   * @returns {Range} This range.\n   */\n  autoFilter() {\n    this.sheet().autoFilter(this);\n    return this;\n  }\n\n  /**\n   * Get the cells in the range as a 2D array.\n   * @returns {Array.<Array.<Cell>>} The cells.\n   */\n  cells() {\n    return this.map(cell => cell);\n  }\n\n  /**\n   * Clear the contents of all the cells in the range.\n   * @returns {Range} The range.\n   */\n  clear() {\n    return this.value(undefined);\n  }\n\n  /**\n   * Get the end cell of the range.\n   * @returns {Cell} The end cell.\n   */\n  endCell() {\n    return this._endCell;\n  }\n\n  /**\n   * Callback used by forEach.\n   * @callback Range~forEachCallback\n   * @param {Cell} cell - The cell.\n   * @param {number} ri - The relative row index.\n   * @param {number} ci - The relative column index.\n   * @param {Range} range - The range.\n   * @returns {undefined}\n   */\n  /**\n   * Call a function for each cell in the range. Goes by row then column.\n   * @param {Range~forEachCallback} callback - Function called for each cell in the range.\n   * @returns {Range} The range.\n   */\n  forEach(callback) {\n    for (let ri = 0; ri < this._numRows; ri++) {\n      for (let ci = 0; ci < this._numColumns; ci++) {\n        callback(this.cell(ri, ci), ri, ci, this);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Gets the shared formula in the start cell (assuming it's the source of the shared formula).\n   * @returns {string|undefined} The shared formula.\n   */ /**\n      * Sets the shared formula in the range. The formula will be translated for each cell.\n      * @param {string} formula - The formula to set.\n      * @returns {Range} The range.\n      */\n  formula() {\n    return new ArgHandler(\"Range.formula\").case(() => {\n      return this.startCell().getSharedRefFormula();\n    }).case('string', formula => {\n      const sharedFormulaId = this.sheet().incrementMaxSharedFormulaId();\n      this.forEach((cell, ri, ci) => {\n        if (ri === 0 && ci === 0) {\n          cell.setSharedFormula(sharedFormulaId, formula, this.address());\n        } else {\n          cell.setSharedFormula(sharedFormulaId);\n        }\n      });\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Callback used by map.\n   * @callback Range~mapCallback\n   * @param {Cell} cell - The cell.\n   * @param {number} ri - The relative row index.\n   * @param {number} ci - The relative column index.\n   * @param {Range} range - The range.\n   * @returns {*} The value to map to.\n   */\n  /**\n   * Creates a 2D array of values by running each cell through a callback.\n   * @param {Range~mapCallback} callback - Function called for each cell in the range.\n   * @returns {Array.<Array.<*>>} The 2D array of return values.\n   */\n  map(callback) {\n    const result = [];\n    this.forEach((cell, ri, ci) => {\n      if (!result[ri]) result[ri] = [];\n      result[ri][ci] = callback(cell, ri, ci, this);\n    });\n    return result;\n  }\n\n  /**\n   * Gets a value indicating whether the cells in the range are merged.\n   * @returns {boolean} The value.\n   */ /**\n      * Sets a value indicating whether the cells in the range should be merged.\n      * @param {boolean} merged - True to merge, false to unmerge.\n      * @returns {Range} The range.\n      */\n  merged(merged) {\n    return new ArgHandler('Range.merged').case(() => {\n      return this.sheet().merged(this.address());\n    }).case('*', merged => {\n      this.sheet().merged(this.address(), merged);\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets the data validation object attached to the Range.\n   * @returns {object|undefined} The data validation object or undefined if not set.\n   */ /**\n      * Set or clear the data validation object of the entire range.\n      * @param {object|undefined} dataValidation - Object or null to clear.\n      * @returns {Range} The range.\n      */\n  dataValidation() {\n    return new ArgHandler('Range.dataValidation').case(() => {\n      return this.sheet().dataValidation(this.address());\n    }).case('boolean', obj => {\n      return this.sheet().dataValidation(this.address(), obj);\n    }).case('*', obj => {\n      this.sheet().dataValidation(this.address(), obj);\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Callback used by reduce.\n   * @callback Range~reduceCallback\n   * @param {*} accumulator - The accumulated value.\n   * @param {Cell} cell - The cell.\n   * @param {number} ri - The relative row index.\n   * @param {number} ci - The relative column index.\n   * @param {Range} range - The range.\n   * @returns {*} The value to map to.\n   */\n  /**\n   * Reduces the range to a single value accumulated from the result of a function called for each cell.\n   * @param {Range~reduceCallback} callback - Function called for each cell in the range.\n   * @param {*} [initialValue] - The initial value.\n   * @returns {*} The accumulated value.\n   */\n  reduce(callback, initialValue) {\n    let accumulator = initialValue;\n    this.forEach((cell, ri, ci) => {\n      accumulator = callback(accumulator, cell, ri, ci, this);\n    });\n    return accumulator;\n  }\n\n  /**\n   * Gets the parent sheet of the range.\n   * @returns {Sheet} The parent sheet.\n   */\n  sheet() {\n    return this.startCell().sheet();\n  }\n\n  /**\n   * Gets the start cell of the range.\n   * @returns {Cell} The start cell.\n   */\n  startCell() {\n    return this._startCell;\n  }\n\n  /**\n   * Gets a single style for each cell.\n   * @param {string} name - The name of the style.\n   * @returns {Array.<Array.<*>>} 2D array of style values.\n   */ /**\n      * Gets multiple styles for each cell.\n      * @param {Array.<string>} names - The names of the styles.\n      * @returns {Object.<string, Array.<Array.<*>>>} Object whose keys are style names and values are 2D arrays of style values.\n      */ /**\n         * Set the style in each cell to the result of a function called for each.\n         * @param {string} name - The name of the style.\n         * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n         * @returns {Range} The range.\n         */ /**\n            * Sets the style in each cell to the corresponding value in the given 2D array of values.\n            * @param {string} name - The name of the style.\n            * @param {Array.<Array.<*>>} values - The style values to set.\n            * @returns {Range} The range.\n            */ /**\n               * Set the style of all cells in the range to a single style value.\n               * @param {string} name - The name of the style.\n               * @param {*} value - The value to set.\n               * @returns {Range} The range.\n               */ /**\n                  * Set multiple styles for the cells in the range.\n                  * @param {object.<string,Range~mapCallback|Array.<Array.<*>>|*>} styles - Object whose keys are style names and values are either function callbacks, 2D arrays of style values, or a single value for all the cells.\n                  * @returns {Range} The range.\n                  */ /**\n                     * Sets to a specific style\n                     * @param {Style} style - Style object given from stylesheet.createStyle\n                     * @returns {Range} The range.\n                     */\n  style() {\n    return new ArgHandler(\"Range.style\").case('string', name => {\n      // Get single value\n      return this.map(cell => cell.style(name));\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this.style(name);\n      });\n      return values;\n    }).case(['string', 'function'], (name, callback) => {\n      // Set a single value for the cells to the result of a function\n      return this.forEach((cell, ri, ci) => {\n        cell.style(name, callback(cell, ri, ci, this));\n      });\n    }).case(['string', 'array'], (name, values) => {\n      // Set a single value for the cells using an array of matching dimension\n      return this.forEach((cell, ri, ci) => {\n        if (values[ri] && values[ri][ci] !== undefined) {\n          cell.style(name, values[ri][ci]);\n        }\n      });\n    }).case(['string', '*'], (name, value) => {\n      // Set a single value for all cells to a single value\n      return this.forEach(cell => cell.style(name, value));\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n        this.style(name, value);\n      }\n      return this;\n    }).case('Style', style => {\n      this._style = style;\n      return this.forEach(cell => cell.style(style));\n    }).handle(arguments);\n  }\n\n  /**\n   * Callback used by tap.\n   * @callback Range~tapCallback\n   * @param {Range} range - The range.\n   * @returns {undefined}\n   */\n  /**\n   * Invoke a callback on the range and return the range. Useful for method chaining.\n   * @param {Range~tapCallback} callback - The callback function.\n   * @returns {Range} The range.\n   */\n  tap(callback) {\n    callback(this);\n    return this;\n  }\n\n  /**\n   * Callback used by thru.\n   * @callback Range~thruCallback\n   * @param {Range} range - The range.\n   * @returns {*} The value to return from thru.\n   */\n  /**\n   * Invoke a callback on the range and return the value provided by the callback. Useful for method chaining.\n   * @param {Range~thruCallback} callback - The callback function.\n   * @returns {*} The return value of the callback.\n   */\n  thru(callback) {\n    return callback(this);\n  }\n\n  /**\n   * Get the values of each cell in the range as a 2D array.\n   * @returns {Array.<Array.<*>>} The values.\n   */ /**\n      * Set the values in each cell to the result of a function called for each.\n      * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n      * @returns {Range} The range.\n      */ /**\n         * Sets the value in each cell to the corresponding value in the given 2D array of values.\n         * @param {Array.<Array.<*>>} values - The values to set.\n         * @returns {Range} The range.\n         */ /**\n            * Set the value of all cells in the range to a single value.\n            * @param {*} value - The value to set.\n            * @returns {Range} The range.\n            */\n  value() {\n    return new ArgHandler(\"Range.value\").case(() => {\n      // Get values\n      return this.map(cell => cell.value());\n    }).case('function', callback => {\n      // Set a value for the cells to the result of a function\n      return this.forEach((cell, ri, ci) => {\n        cell.value(callback(cell, ri, ci, this));\n      });\n    }).case('array', values => {\n      // Set value for the cells using an array of matching dimension\n      return this.forEach((cell, ri, ci) => {\n        if (values[ri] && values[ri][ci] !== undefined) {\n          cell.value(values[ri][ci]);\n        }\n      });\n    }).case('*', value => {\n      // Set the value for all cells to a single value\n      return this.forEach(cell => cell.value(value));\n    }).handle(arguments);\n  }\n\n  /**\n   * Gets the parent workbook.\n   * @returns {Workbook} The parent workbook.\n   */\n  workbook() {\n    return this.sheet().workbook();\n  }\n\n  /**\n   * Find the extent of the range.\n   * @returns {undefined}\n   * @private\n   */\n  _findRangeExtent() {\n    this._minRowNumber = Math.min(this._startCell.rowNumber(), this._endCell.rowNumber());\n    this._maxRowNumber = Math.max(this._startCell.rowNumber(), this._endCell.rowNumber());\n    this._minColumnNumber = Math.min(this._startCell.columnNumber(), this._endCell.columnNumber());\n    this._maxColumnNumber = Math.max(this._startCell.columnNumber(), this._endCell.columnNumber());\n    this._numRows = this._maxRowNumber - this._minRowNumber + 1;\n    this._numColumns = this._maxColumnNumber - this._minColumnNumber + 1;\n  }\n}\nmodule.exports = Range;","map":{"version":3,"names":["ArgHandler","require","addressConverter","Range","constructor","startCell","endCell","_startCell","_endCell","_findRangeExtent","address","opts","toAddress","type","startRowNumber","rowNumber","startRowAnchored","anchored","startColumnName","columnName","startColumnAnchored","endRowNumber","endRowAnchored","endColumnName","endColumnAnchored","sheetName","includeSheetName","sheet","name","cell","ri","ci","_minRowNumber","_minColumnNumber","autoFilter","cells","map","clear","value","undefined","forEach","callback","_numRows","_numColumns","formula","case","getSharedRefFormula","sharedFormulaId","incrementMaxSharedFormulaId","setSharedFormula","handle","arguments","result","merged","dataValidation","obj","reduce","initialValue","accumulator","style","names","values","nameValues","hasOwnProperty","_style","tap","thru","workbook","Math","min","_maxRowNumber","max","columnNumber","_maxColumnNumber","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Range.js"],"sourcesContent":["\"use strict\";\n\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n/**\n * A range of cells.\n */\nclass Range {\n    // /**\n    //  * Creates a new instance of Range.\n    //  * @param {Cell} startCell - The start cell.\n    //  * @param {Cell} endCell - The end cell.\n    //  */\n    constructor(startCell, endCell) {\n        this._startCell = startCell;\n        this._endCell = endCell;\n        this._findRangeExtent(startCell, endCell);\n    }\n\n    /**\n     * Get the address of the range.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.includeSheetName] - Include the sheet name in the address.\n     * @param {boolean} [opts.startRowAnchored] - Anchor the start row.\n     * @param {boolean} [opts.startColumnAnchored] - Anchor the start column.\n     * @param {boolean} [opts.endRowAnchored] - Anchor the end row.\n     * @param {boolean} [opts.endColumnAnchored] - Anchor the end column.\n     * @param {boolean} [opts.anchored] - Anchor all row and columns.\n     * @returns {string} The address.\n     */\n    address(opts) {\n        return addressConverter.toAddress({\n            type: 'range',\n            startRowNumber: this.startCell().rowNumber(),\n            startRowAnchored: opts && (opts.startRowAnchored || opts.anchored),\n            startColumnName: this.startCell().columnName(),\n            startColumnAnchored: opts && (opts.startColumnAnchored || opts.anchored),\n            endRowNumber: this.endCell().rowNumber(),\n            endRowAnchored: opts && (opts.endRowAnchored || opts.anchored),\n            endColumnName: this.endCell().columnName(),\n            endColumnAnchored: opts && (opts.endColumnAnchored || opts.anchored),\n            sheetName: opts && opts.includeSheetName && this.sheet().name()\n        });\n    }\n\n    /**\n     * Gets a cell within the range.\n     * @param {number} ri - Row index relative to the top-left corner of the range (0-based).\n     * @param {number} ci - Column index relative to the top-left corner of the range (0-based).\n     * @returns {Cell} The cell.\n     */\n    cell(ri, ci) {\n        return this.sheet().cell(this._minRowNumber + ri, this._minColumnNumber + ci);\n    }\n\n    /**\n     * Sets sheet autoFilter to this range.\n     * @returns {Range} This range.\n     */\n    autoFilter() {\n        this.sheet().autoFilter(this);\n\n        return this;\n    }\n\n    /**\n     * Get the cells in the range as a 2D array.\n     * @returns {Array.<Array.<Cell>>} The cells.\n     */\n    cells() {\n        return this.map(cell => cell);\n    }\n\n    /**\n     * Clear the contents of all the cells in the range.\n     * @returns {Range} The range.\n     */\n    clear() {\n        return this.value(undefined);\n    }\n\n    /**\n     * Get the end cell of the range.\n     * @returns {Cell} The end cell.\n     */\n    endCell() {\n        return this._endCell;\n    }\n\n    /**\n     * Callback used by forEach.\n     * @callback Range~forEachCallback\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {undefined}\n     */\n    /**\n     * Call a function for each cell in the range. Goes by row then column.\n     * @param {Range~forEachCallback} callback - Function called for each cell in the range.\n     * @returns {Range} The range.\n     */\n    forEach(callback) {\n        for (let ri = 0; ri < this._numRows; ri++) {\n            for (let ci = 0; ci < this._numColumns; ci++) {\n                callback(this.cell(ri, ci), ri, ci, this);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Gets the shared formula in the start cell (assuming it's the source of the shared formula).\n     * @returns {string|undefined} The shared formula.\n     *//**\n     * Sets the shared formula in the range. The formula will be translated for each cell.\n     * @param {string} formula - The formula to set.\n     * @returns {Range} The range.\n     */\n    formula() {\n        return new ArgHandler(\"Range.formula\")\n            .case(() => {\n                return this.startCell().getSharedRefFormula();\n            })\n            .case('string', formula => {\n                const sharedFormulaId = this.sheet().incrementMaxSharedFormulaId();\n                this.forEach((cell, ri, ci) => {\n                    if (ri === 0 && ci === 0) {\n                        cell.setSharedFormula(sharedFormulaId, formula, this.address());\n                    } else {\n                        cell.setSharedFormula(sharedFormulaId);\n                    }\n                });\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by map.\n     * @callback Range~mapCallback\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {*} The value to map to.\n     */\n    /**\n     * Creates a 2D array of values by running each cell through a callback.\n     * @param {Range~mapCallback} callback - Function called for each cell in the range.\n     * @returns {Array.<Array.<*>>} The 2D array of return values.\n     */\n    map(callback) {\n        const result = [];\n        this.forEach((cell, ri, ci) => {\n            if (!result[ri]) result[ri] = [];\n            result[ri][ci] = callback(cell, ri, ci, this);\n        });\n\n        return result;\n    }\n\n    /**\n     * Gets a value indicating whether the cells in the range are merged.\n     * @returns {boolean} The value.\n     *//**\n     * Sets a value indicating whether the cells in the range should be merged.\n     * @param {boolean} merged - True to merge, false to unmerge.\n     * @returns {Range} The range.\n     */\n    merged(merged) {\n        return new ArgHandler('Range.merged')\n            .case(() => {\n                return this.sheet().merged(this.address());\n            })\n            .case('*', merged => {\n                this.sheet().merged(this.address(), merged);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the data validation object attached to the Range.\n     * @returns {object|undefined} The data validation object or undefined if not set.\n     *//**\n     * Set or clear the data validation object of the entire range.\n     * @param {object|undefined} dataValidation - Object or null to clear.\n     * @returns {Range} The range.\n     */\n    dataValidation() {\n        return new ArgHandler('Range.dataValidation')\n            .case(() => {\n                return this.sheet().dataValidation(this.address());\n            })\n            .case('boolean', obj => {\n                return this.sheet().dataValidation(this.address(), obj);\n            })\n            .case('*', obj => {\n                this.sheet().dataValidation(this.address(), obj);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by reduce.\n     * @callback Range~reduceCallback\n     * @param {*} accumulator - The accumulated value.\n     * @param {Cell} cell - The cell.\n     * @param {number} ri - The relative row index.\n     * @param {number} ci - The relative column index.\n     * @param {Range} range - The range.\n     * @returns {*} The value to map to.\n     */\n    /**\n     * Reduces the range to a single value accumulated from the result of a function called for each cell.\n     * @param {Range~reduceCallback} callback - Function called for each cell in the range.\n     * @param {*} [initialValue] - The initial value.\n     * @returns {*} The accumulated value.\n     */\n    reduce(callback, initialValue) {\n        let accumulator = initialValue;\n        this.forEach((cell, ri, ci) => {\n            accumulator = callback(accumulator, cell, ri, ci, this);\n        });\n\n        return accumulator;\n    }\n\n    /**\n     * Gets the parent sheet of the range.\n     * @returns {Sheet} The parent sheet.\n     */\n    sheet() {\n        return this.startCell().sheet();\n    }\n\n    /**\n     * Gets the start cell of the range.\n     * @returns {Cell} The start cell.\n     */\n    startCell() {\n        return this._startCell;\n    }\n\n    /**\n     * Gets a single style for each cell.\n     * @param {string} name - The name of the style.\n     * @returns {Array.<Array.<*>>} 2D array of style values.\n     *//**\n     * Gets multiple styles for each cell.\n     * @param {Array.<string>} names - The names of the styles.\n     * @returns {Object.<string, Array.<Array.<*>>>} Object whose keys are style names and values are 2D arrays of style values.\n     *//**\n     * Set the style in each cell to the result of a function called for each.\n     * @param {string} name - The name of the style.\n     * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n     * @returns {Range} The range.\n     *//**\n     * Sets the style in each cell to the corresponding value in the given 2D array of values.\n     * @param {string} name - The name of the style.\n     * @param {Array.<Array.<*>>} values - The style values to set.\n     * @returns {Range} The range.\n     *//**\n     * Set the style of all cells in the range to a single style value.\n     * @param {string} name - The name of the style.\n     * @param {*} value - The value to set.\n     * @returns {Range} The range.\n     *//**\n     * Set multiple styles for the cells in the range.\n     * @param {object.<string,Range~mapCallback|Array.<Array.<*>>|*>} styles - Object whose keys are style names and values are either function callbacks, 2D arrays of style values, or a single value for all the cells.\n     * @returns {Range} The range.\n     *//**\n\t * Sets to a specific style\n\t * @param {Style} style - Style object given from stylesheet.createStyle\n\t * @returns {Range} The range.\n\t */\n    style() {\n        return new ArgHandler(\"Range.style\")\n            .case('string', name => {\n                // Get single value\n                return this.map(cell => cell.style(name));\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this.style(name);\n                });\n\n                return values;\n            })\n            .case(['string', 'function'], (name, callback) => {\n                // Set a single value for the cells to the result of a function\n                return this.forEach((cell, ri, ci) => {\n                    cell.style(name, callback(cell, ri, ci, this));\n                });\n            })\n            .case(['string', 'array'], (name, values) => {\n                // Set a single value for the cells using an array of matching dimension\n                return this.forEach((cell, ri, ci) => {\n                    if (values[ri] && values[ri][ci] !== undefined) {\n                        cell.style(name, values[ri][ci]);\n                    }\n                });\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                return this.forEach(cell => cell.style(name, value));\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this.style(name, value);\n                }\n\n                return this;\n            })\n            .case('Style', style => {\n                this._style = style;\n                return this.forEach(cell => cell.style(style));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Callback used by tap.\n     * @callback Range~tapCallback\n     * @param {Range} range - The range.\n     * @returns {undefined}\n     */\n    /**\n     * Invoke a callback on the range and return the range. Useful for method chaining.\n     * @param {Range~tapCallback} callback - The callback function.\n     * @returns {Range} The range.\n     */\n    tap(callback) {\n        callback(this);\n        return this;\n    }\n\n    /**\n     * Callback used by thru.\n     * @callback Range~thruCallback\n     * @param {Range} range - The range.\n     * @returns {*} The value to return from thru.\n     */\n    /**\n     * Invoke a callback on the range and return the value provided by the callback. Useful for method chaining.\n     * @param {Range~thruCallback} callback - The callback function.\n     * @returns {*} The return value of the callback.\n     */\n    thru(callback) {\n        return callback(this);\n    }\n\n    /**\n     * Get the values of each cell in the range as a 2D array.\n     * @returns {Array.<Array.<*>>} The values.\n     *//**\n     * Set the values in each cell to the result of a function called for each.\n     * @param {Range~mapCallback} callback - The callback to provide value for the cell.\n     * @returns {Range} The range.\n     *//**\n     * Sets the value in each cell to the corresponding value in the given 2D array of values.\n     * @param {Array.<Array.<*>>} values - The values to set.\n     * @returns {Range} The range.\n     *//**\n     * Set the value of all cells in the range to a single value.\n     * @param {*} value - The value to set.\n     * @returns {Range} The range.\n     */\n    value() {\n        return new ArgHandler(\"Range.value\")\n            .case(() => {\n                // Get values\n                return this.map(cell => cell.value());\n            })\n            .case('function', callback => {\n                // Set a value for the cells to the result of a function\n                return this.forEach((cell, ri, ci) => {\n                    cell.value(callback(cell, ri, ci, this));\n                });\n            })\n            .case('array', values => {\n                // Set value for the cells using an array of matching dimension\n                return this.forEach((cell, ri, ci) => {\n                    if (values[ri] && values[ri][ci] !== undefined) {\n                        cell.value(values[ri][ci]);\n                    }\n                });\n            })\n            .case('*', value => {\n                // Set the value for all cells to a single value\n                return this.forEach(cell => cell.value(value));\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Gets the parent workbook.\n     * @returns {Workbook} The parent workbook.\n     */\n    workbook() {\n        return this.sheet().workbook();\n    }\n\n    /**\n     * Find the extent of the range.\n     * @returns {undefined}\n     * @private\n     */\n    _findRangeExtent() {\n        this._minRowNumber = Math.min(this._startCell.rowNumber(), this._endCell.rowNumber());\n        this._maxRowNumber = Math.max(this._startCell.rowNumber(), this._endCell.rowNumber());\n        this._minColumnNumber = Math.min(this._startCell.columnNumber(), this._endCell.columnNumber());\n        this._maxColumnNumber = Math.max(this._startCell.columnNumber(), this._endCell.columnNumber());\n        this._numRows = this._maxRowNumber - this._minRowNumber + 1;\n        this._numColumns = this._maxColumnNumber - this._minColumnNumber + 1;\n    }\n}\n\nmodule.exports = Range;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}