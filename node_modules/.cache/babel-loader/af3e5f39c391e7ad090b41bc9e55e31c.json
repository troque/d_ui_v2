{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addTranslations = addTranslations;\nexports.setLanguage = setLanguage;\nexports.setTranslateReferenceRegex = setTranslateReferenceRegex;\nexports.setTranslateVariableRegex = setTranslateVariableRegex;\nexports.setTranslator = setTranslator;\nexports.stringExists = stringExists;\nexports.tr = tr;\nvar _utils = require(\"./utils.js\");\nlet translations = {};\nlet varRegex = /__(.*?)__/g;\nlet refRegex = /@@(.*?)@@/g;\nfunction findString() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  const part = id.split('.');\n  const lastIndex = part.length - 1;\n  return part.reduce((nodeInfo, cur, index) => {\n    const {\n      node,\n      found\n    } = nodeInfo;\n    const isLast = index == lastIndex;\n    const isString = typeof node == 'string';\n    if (isString) {\n      return {\n        found,\n        node\n      };\n    } else {\n      if (node && node[cur]) {\n        if (isLast && node[cur]._) {\n          return {\n            found: true,\n            node: node[cur]._\n          };\n        } else {\n          return {\n            found: isLast,\n            node: node[cur]\n          };\n        }\n      } else {\n        return {\n          found: node && '_' in node,\n          node: node && node._\n        };\n      }\n    }\n  }, {\n    node: translations\n  });\n}\nfunction regexReplace(regex, str, callback) {\n  let match;\n  let result = str;\n  const re = new RegExp(regex);\n  while ((match = re.exec(str)) !== null) {\n    const value = callback(match[1]);\n    if (typeof value != 'undefined') result = result.replace(match[0], value);\n  }\n  return result;\n}\n/**\n * Translates a string given its id.\n *\n * @param {string} id Identifier in the form\n * \t`key1.key2.key3`\n * @param {object} vars Object with substitution variables. It will\n * \tsubstitute ocurrences when string contains this expression:\n * \t`__variable__`. For example the string `\"My name is __name__\"` with\n * \t`vars = { name: 'David' }` will return `\"My name is David\"`.\n *\n * \tKeys will be searched by partitioning the path.\n *\n * \tIt will get the latest found key if any. For example, given the\n * \tstrings `{ \"a\": { \"b\": 'Hello' } }` and looking for `'a.b.c'` it will\n * \treturn `'a.b'` (`\"Hello\"`).\n * @returns Translated string\n */\n\nfunction tr(id) {\n  let vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    node\n  } = findString(id);\n  if (node) {\n    // Find variables\n    node = regexReplace(varRegex, node, match => vars[match]); // Find references\n\n    node = regexReplace(refRegex, node, match => tr(match, vars));\n    return node;\n  } else return id;\n}\n/**\n * Returns if the string does exist\n *\n * @param {string} id Identifier\n *\n * @returns { boolean } true if it exists\n */\n\nfunction stringExists(id) {\n  const {\n    found\n  } = findString(id);\n  return found;\n}\n/**\n * Sets the language.\n *\n * At the moment this does the same as addTranslations. The\n * reason is not to lose translations reference until a better\n * way is figured out.\n *\n * @param {lang} Translations object with the format\n * \t{ key: { _: 'Some string', inner: 'Some other string' } }\n * \tThen, we have the following paths\n * \t- key -> 'Some string'\n * \t- key.inner -> 'Some other string'\n */\n\nfunction setLanguage(lang) {\n  addTranslations(lang);\n}\n/**\n * Appends translations to current translation table\n *\n * @param {object} lang Translations merged into current.\n */\n\nfunction addTranslations(lang) {\n  translations = (0, _utils.deepmerge)(translations, lang);\n}\n/**\n * Sets the translation engine that responds to tr().\n *\n * @param {function} translate Function with signature\n * \ttranslate(id, params).\n */\n\nfunction setTranslator(translate) {\n  exports.tr = tr = translate;\n}\n/**\n * Sets the regex for the variables\n */\n\nfunction setTranslateVariableRegex(newVarRegex) {\n  varRegex = newVarRegex;\n}\n/**\n * Sets the regex for the substitutions\n */\n\nfunction setTranslateReferenceRegex(newRefRegex) {\n  refRegex = newRefRegex;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","addTranslations","setLanguage","setTranslateReferenceRegex","setTranslateVariableRegex","setTranslator","stringExists","tr","_utils","require","translations","varRegex","refRegex","findString","id","part","split","lastIndex","length","reduce","nodeInfo","cur","index","node","found","isLast","isString","_","regexReplace","regex","str","callback","match","result","re","RegExp","exec","replace","vars","lang","deepmerge","translate","newVarRegex","newRefRegex"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/react-hook-form-auto/lib/translate.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addTranslations = addTranslations;\nexports.setLanguage = setLanguage;\nexports.setTranslateReferenceRegex = setTranslateReferenceRegex;\nexports.setTranslateVariableRegex = setTranslateVariableRegex;\nexports.setTranslator = setTranslator;\nexports.stringExists = stringExists;\nexports.tr = tr;\n\nvar _utils = require(\"./utils.js\");\n\nlet translations = {};\nlet varRegex = /__(.*?)__/g;\nlet refRegex = /@@(.*?)@@/g;\n\nfunction findString(id = '') {\n  const part = id.split('.');\n  const lastIndex = part.length - 1;\n  return part.reduce((nodeInfo, cur, index) => {\n    const {\n      node,\n      found\n    } = nodeInfo;\n    const isLast = index == lastIndex;\n    const isString = typeof node == 'string';\n\n    if (isString) {\n      return {\n        found,\n        node\n      };\n    } else {\n      if (node && node[cur]) {\n        if (isLast && node[cur]._) {\n          return {\n            found: true,\n            node: node[cur]._\n          };\n        } else {\n          return {\n            found: isLast,\n            node: node[cur]\n          };\n        }\n      } else {\n        return {\n          found: node && '_' in node,\n          node: node && node._\n        };\n      }\n    }\n  }, {\n    node: translations\n  });\n}\n\nfunction regexReplace(regex, str, callback) {\n  let match;\n  let result = str;\n  const re = new RegExp(regex);\n\n  while ((match = re.exec(str)) !== null) {\n    const value = callback(match[1]);\n    if (typeof value != 'undefined') result = result.replace(match[0], value);\n  }\n\n  return result;\n}\n/**\n * Translates a string given its id.\n *\n * @param {string} id Identifier in the form\n * \t`key1.key2.key3`\n * @param {object} vars Object with substitution variables. It will\n * \tsubstitute ocurrences when string contains this expression:\n * \t`__variable__`. For example the string `\"My name is __name__\"` with\n * \t`vars = { name: 'David' }` will return `\"My name is David\"`.\n *\n * \tKeys will be searched by partitioning the path.\n *\n * \tIt will get the latest found key if any. For example, given the\n * \tstrings `{ \"a\": { \"b\": 'Hello' } }` and looking for `'a.b.c'` it will\n * \treturn `'a.b'` (`\"Hello\"`).\n * @returns Translated string\n */\n\n\nfunction tr(id, vars = {}) {\n  let {\n    node\n  } = findString(id);\n\n  if (node) {\n    // Find variables\n    node = regexReplace(varRegex, node, match => vars[match]); // Find references\n\n    node = regexReplace(refRegex, node, match => tr(match, vars));\n    return node;\n  } else return id;\n}\n/**\n * Returns if the string does exist\n *\n * @param {string} id Identifier\n *\n * @returns { boolean } true if it exists\n */\n\n\nfunction stringExists(id) {\n  const {\n    found\n  } = findString(id);\n  return found;\n}\n/**\n * Sets the language.\n *\n * At the moment this does the same as addTranslations. The\n * reason is not to lose translations reference until a better\n * way is figured out.\n *\n * @param {lang} Translations object with the format\n * \t{ key: { _: 'Some string', inner: 'Some other string' } }\n * \tThen, we have the following paths\n * \t- key -> 'Some string'\n * \t- key.inner -> 'Some other string'\n */\n\n\nfunction setLanguage(lang) {\n  addTranslations(lang);\n}\n/**\n * Appends translations to current translation table\n *\n * @param {object} lang Translations merged into current.\n */\n\n\nfunction addTranslations(lang) {\n  translations = (0, _utils.deepmerge)(translations, lang);\n}\n/**\n * Sets the translation engine that responds to tr().\n *\n * @param {function} translate Function with signature\n * \ttranslate(id, params).\n */\n\n\nfunction setTranslator(translate) {\n  exports.tr = tr = translate;\n}\n/**\n * Sets the regex for the variables\n */\n\n\nfunction setTranslateVariableRegex(newVarRegex) {\n  varRegex = newVarRegex;\n}\n/**\n * Sets the regex for the substitutions\n */\n\n\nfunction setTranslateReferenceRegex(newRefRegex) {\n  refRegex = newRefRegex;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}