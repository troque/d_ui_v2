{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addTranslations = addTranslations;\nexports.setLanguage = setLanguage;\nexports.setTranslateReferenceRegex = setTranslateReferenceRegex;\nexports.setTranslateVariableRegex = setTranslateVariableRegex;\nexports.setTranslator = setTranslator;\nexports.stringExists = stringExists;\nexports.tr = tr;\n\nvar _utils = require(\"./utils.js\");\n\nlet translations = {};\nlet varRegex = /__(.*?)__/g;\nlet refRegex = /@@(.*?)@@/g;\n\nfunction findString() {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  const part = id.split('.');\n  const lastIndex = part.length - 1;\n  return part.reduce((nodeInfo, cur, index) => {\n    const {\n      node,\n      found\n    } = nodeInfo;\n    const isLast = index == lastIndex;\n    const isString = typeof node == 'string';\n\n    if (isString) {\n      return {\n        found,\n        node\n      };\n    } else {\n      if (node && node[cur]) {\n        if (isLast && node[cur]._) {\n          return {\n            found: true,\n            node: node[cur]._\n          };\n        } else {\n          return {\n            found: isLast,\n            node: node[cur]\n          };\n        }\n      } else {\n        return {\n          found: node && '_' in node,\n          node: node && node._\n        };\n      }\n    }\n  }, {\n    node: translations\n  });\n}\n\nfunction regexReplace(regex, str, callback) {\n  let match;\n  let result = str;\n  const re = new RegExp(regex);\n\n  while ((match = re.exec(str)) !== null) {\n    const value = callback(match[1]);\n    if (typeof value != 'undefined') result = result.replace(match[0], value);\n  }\n\n  return result;\n}\n/**\n * Translates a string given its id.\n *\n * @param {string} id Identifier in the form\n * \t`key1.key2.key3`\n * @param {object} vars Object with substitution variables. It will\n * \tsubstitute ocurrences when string contains this expression:\n * \t`__variable__`. For example the string `\"My name is __name__\"` with\n * \t`vars = { name: 'David' }` will return `\"My name is David\"`.\n *\n * \tKeys will be searched by partitioning the path.\n *\n * \tIt will get the latest found key if any. For example, given the\n * \tstrings `{ \"a\": { \"b\": 'Hello' } }` and looking for `'a.b.c'` it will\n * \treturn `'a.b'` (`\"Hello\"`).\n * @returns Translated string\n */\n\n\nfunction tr(id) {\n  let vars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    node\n  } = findString(id);\n\n  if (node) {\n    // Find variables\n    node = regexReplace(varRegex, node, match => vars[match]); // Find references\n\n    node = regexReplace(refRegex, node, match => tr(match, vars));\n    return node;\n  } else return id;\n}\n/**\n * Returns if the string does exist\n *\n * @param {string} id Identifier\n *\n * @returns { boolean } true if it exists\n */\n\n\nfunction stringExists(id) {\n  const {\n    found\n  } = findString(id);\n  return found;\n}\n/**\n * Sets the language.\n *\n * At the moment this does the same as addTranslations. The\n * reason is not to lose translations reference until a better\n * way is figured out.\n *\n * @param {lang} Translations object with the format\n * \t{ key: { _: 'Some string', inner: 'Some other string' } }\n * \tThen, we have the following paths\n * \t- key -> 'Some string'\n * \t- key.inner -> 'Some other string'\n */\n\n\nfunction setLanguage(lang) {\n  addTranslations(lang);\n}\n/**\n * Appends translations to current translation table\n *\n * @param {object} lang Translations merged into current.\n */\n\n\nfunction addTranslations(lang) {\n  translations = (0, _utils.deepmerge)(translations, lang);\n}\n/**\n * Sets the translation engine that responds to tr().\n *\n * @param {function} translate Function with signature\n * \ttranslate(id, params).\n */\n\n\nfunction setTranslator(translate) {\n  exports.tr = tr = translate;\n}\n/**\n * Sets the regex for the variables\n */\n\n\nfunction setTranslateVariableRegex(newVarRegex) {\n  varRegex = newVarRegex;\n}\n/**\n * Sets the regex for the substitutions\n */\n\n\nfunction setTranslateReferenceRegex(newRefRegex) {\n  refRegex = newRefRegex;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","addTranslations","setLanguage","setTranslateReferenceRegex","setTranslateVariableRegex","setTranslator","stringExists","tr","_utils","require","translations","varRegex","refRegex","findString","id","part","split","lastIndex","length","reduce","nodeInfo","cur","index","node","found","isLast","isString","_","regexReplace","regex","str","callback","match","result","re","RegExp","exec","replace","vars","lang","deepmerge","translate","newVarRegex","newRefRegex"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/react-hook-form-auto/lib/translate.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addTranslations = addTranslations;\nexports.setLanguage = setLanguage;\nexports.setTranslateReferenceRegex = setTranslateReferenceRegex;\nexports.setTranslateVariableRegex = setTranslateVariableRegex;\nexports.setTranslator = setTranslator;\nexports.stringExists = stringExists;\nexports.tr = tr;\n\nvar _utils = require(\"./utils.js\");\n\nlet translations = {};\nlet varRegex = /__(.*?)__/g;\nlet refRegex = /@@(.*?)@@/g;\n\nfunction findString(id = '') {\n  const part = id.split('.');\n  const lastIndex = part.length - 1;\n  return part.reduce((nodeInfo, cur, index) => {\n    const {\n      node,\n      found\n    } = nodeInfo;\n    const isLast = index == lastIndex;\n    const isString = typeof node == 'string';\n\n    if (isString) {\n      return {\n        found,\n        node\n      };\n    } else {\n      if (node && node[cur]) {\n        if (isLast && node[cur]._) {\n          return {\n            found: true,\n            node: node[cur]._\n          };\n        } else {\n          return {\n            found: isLast,\n            node: node[cur]\n          };\n        }\n      } else {\n        return {\n          found: node && '_' in node,\n          node: node && node._\n        };\n      }\n    }\n  }, {\n    node: translations\n  });\n}\n\nfunction regexReplace(regex, str, callback) {\n  let match;\n  let result = str;\n  const re = new RegExp(regex);\n\n  while ((match = re.exec(str)) !== null) {\n    const value = callback(match[1]);\n    if (typeof value != 'undefined') result = result.replace(match[0], value);\n  }\n\n  return result;\n}\n/**\n * Translates a string given its id.\n *\n * @param {string} id Identifier in the form\n * \t`key1.key2.key3`\n * @param {object} vars Object with substitution variables. It will\n * \tsubstitute ocurrences when string contains this expression:\n * \t`__variable__`. For example the string `\"My name is __name__\"` with\n * \t`vars = { name: 'David' }` will return `\"My name is David\"`.\n *\n * \tKeys will be searched by partitioning the path.\n *\n * \tIt will get the latest found key if any. For example, given the\n * \tstrings `{ \"a\": { \"b\": 'Hello' } }` and looking for `'a.b.c'` it will\n * \treturn `'a.b'` (`\"Hello\"`).\n * @returns Translated string\n */\n\n\nfunction tr(id, vars = {}) {\n  let {\n    node\n  } = findString(id);\n\n  if (node) {\n    // Find variables\n    node = regexReplace(varRegex, node, match => vars[match]); // Find references\n\n    node = regexReplace(refRegex, node, match => tr(match, vars));\n    return node;\n  } else return id;\n}\n/**\n * Returns if the string does exist\n *\n * @param {string} id Identifier\n *\n * @returns { boolean } true if it exists\n */\n\n\nfunction stringExists(id) {\n  const {\n    found\n  } = findString(id);\n  return found;\n}\n/**\n * Sets the language.\n *\n * At the moment this does the same as addTranslations. The\n * reason is not to lose translations reference until a better\n * way is figured out.\n *\n * @param {lang} Translations object with the format\n * \t{ key: { _: 'Some string', inner: 'Some other string' } }\n * \tThen, we have the following paths\n * \t- key -> 'Some string'\n * \t- key.inner -> 'Some other string'\n */\n\n\nfunction setLanguage(lang) {\n  addTranslations(lang);\n}\n/**\n * Appends translations to current translation table\n *\n * @param {object} lang Translations merged into current.\n */\n\n\nfunction addTranslations(lang) {\n  translations = (0, _utils.deepmerge)(translations, lang);\n}\n/**\n * Sets the translation engine that responds to tr().\n *\n * @param {function} translate Function with signature\n * \ttranslate(id, params).\n */\n\n\nfunction setTranslator(translate) {\n  exports.tr = tr = translate;\n}\n/**\n * Sets the regex for the variables\n */\n\n\nfunction setTranslateVariableRegex(newVarRegex) {\n  varRegex = newVarRegex;\n}\n/**\n * Sets the regex for the substitutions\n */\n\n\nfunction setTranslateReferenceRegex(newRefRegex) {\n  refRegex = newRefRegex;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}