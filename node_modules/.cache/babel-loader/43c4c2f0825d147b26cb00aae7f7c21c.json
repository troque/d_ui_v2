{"ast":null,"code":"\"use strict\";\n\nconst sax = require(\"sax\");\nconst externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nconst allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nclass XmlParser {\n  /**\n   * Parse the XML text into a JSON object.\n   * @param {string} xmlText - The XML text.\n   * @returns {{}} The JSON object.\n   */\n  parseAsync(xmlText) {\n    return new externals.Promise((resolve, reject) => {\n      // Create the SAX parser.\n      const parser = sax.parser(true);\n\n      // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n      // nodes leading to the current one.\n      let parsed, current;\n      const stack = [];\n\n      // On error: Reject the promise.\n      parser.onerror = reject;\n\n      // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n      parser.ontext = text => {\n        if (allWhitespaceRegex.test(text)) {\n          if (current && current.attributes['xml:space'] === 'preserve') {\n            current.children.push(text);\n          }\n        } else {\n          current.children.push(this._covertToNumberIfNumber(text));\n        }\n      };\n\n      // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n      // it as a child to the current node.\n      parser.onopentagstart = node => {\n        const child = {\n          name: node.name,\n          attributes: {},\n          children: []\n        };\n        if (current) {\n          current.children.push(child);\n        } else {\n          parsed = child;\n        }\n        stack.push(child);\n        current = child;\n      };\n\n      // On close tag: Pop the stack.\n      parser.onclosetag = node => {\n        stack.pop();\n        current = stack[stack.length - 1];\n      };\n\n      // On attribute: Try to convert the value to a number and add to the current node.\n      parser.onattribute = attribute => {\n        current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n      };\n\n      // On end: Resolve the promise.\n      parser.onend = () => resolve(parsed);\n\n      // Start parsing the text.\n      parser.write(xmlText).close();\n    });\n  }\n\n  /**\n   * Convert the string to a number if it looks like one.\n   * @param {string} str - The string to convert.\n   * @returns {string|number} The number if converted or the string if not.\n   * @private\n   */\n  _covertToNumberIfNumber(str) {\n    const num = Number(str);\n    return num.toString() === str ? num : str;\n  }\n}\nmodule.exports = XmlParser;","map":{"version":3,"names":["sax","require","externals","allWhitespaceRegex","XmlParser","parseAsync","xmlText","Promise","resolve","reject","parser","parsed","current","stack","onerror","ontext","text","test","attributes","children","push","_covertToNumberIfNumber","onopentagstart","node","child","name","onclosetag","pop","length","onattribute","attribute","value","onend","write","close","str","num","Number","toString","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/XmlParser.js"],"sourcesContent":["\"use strict\";\n\nconst sax = require(\"sax\");\nconst externals = require(\"./externals\");\n\n// Regex to check if string is all whitespace.\nconst allWhitespaceRegex = /^\\s+$/;\n\n/**\n * XML parser.\n * @private\n */\nclass XmlParser {\n    /**\n     * Parse the XML text into a JSON object.\n     * @param {string} xmlText - The XML text.\n     * @returns {{}} The JSON object.\n     */\n    parseAsync(xmlText) {\n        return new externals.Promise((resolve, reject) => {\n            // Create the SAX parser.\n            const parser = sax.parser(true);\n\n            // Parsed is the full parsed object. Current is the current node being parsed. Stack is the current stack of\n            // nodes leading to the current one.\n            let parsed, current;\n            const stack = [];\n\n            // On error: Reject the promise.\n            parser.onerror = reject;\n\n            // On text nodes: If it is all whitespace, do nothing. Otherwise, try to convert to a number and add as a child.\n            parser.ontext = text => {\n                if (allWhitespaceRegex.test(text)) {\n                    if (current && current.attributes['xml:space'] === 'preserve') {\n                        current.children.push(text);\n                    }\n                } else {\n                    current.children.push(this._covertToNumberIfNumber(text));\n                }\n            };\n\n            // On open tag start: Create a child element. If this is the root element, set it as parsed. Otherwise, add\n            // it as a child to the current node.\n            parser.onopentagstart = node => {\n                const child = { name: node.name, attributes: {}, children: [] };\n                if (current) {\n                    current.children.push(child);\n                } else {\n                    parsed = child;\n                }\n\n                stack.push(child);\n                current = child;\n            };\n\n            // On close tag: Pop the stack.\n            parser.onclosetag = node => {\n                stack.pop();\n                current = stack[stack.length - 1];\n            };\n\n            // On attribute: Try to convert the value to a number and add to the current node.\n            parser.onattribute = attribute => {\n                current.attributes[attribute.name] = this._covertToNumberIfNumber(attribute.value);\n            };\n\n            // On end: Resolve the promise.\n            parser.onend = () => resolve(parsed);\n\n            // Start parsing the text.\n            parser.write(xmlText).close();\n        });\n    }\n\n    /**\n     * Convert the string to a number if it looks like one.\n     * @param {string} str - The string to convert.\n     * @returns {string|number} The number if converted or the string if not.\n     * @private\n     */\n    _covertToNumberIfNumber(str) {\n        const num = Number(str);\n        return num.toString() === str ? num : str;\n    }\n}\n\nmodule.exports = XmlParser;\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMC,SAAS,GAAGD,OAAO,CAAC,aAAa,CAAC;;AAExC;AACA,MAAME,kBAAkB,GAAG,OAAO;;AAElC;AACA;AACA;AACA;AACA,MAAMC,SAAS,CAAC;EACZ;AACJ;AACA;AACA;AACA;EACIC,UAAU,CAACC,OAAO,EAAE;IAChB,OAAO,IAAIJ,SAAS,CAACK,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MAC9C;MACA,MAAMC,MAAM,GAAGV,GAAG,CAACU,MAAM,CAAC,IAAI,CAAC;;MAE/B;MACA;MACA,IAAIC,MAAM,EAAEC,OAAO;MACnB,MAAMC,KAAK,GAAG,EAAE;;MAEhB;MACAH,MAAM,CAACI,OAAO,GAAGL,MAAM;;MAEvB;MACAC,MAAM,CAACK,MAAM,GAAGC,IAAI,IAAI;QACpB,IAAIb,kBAAkB,CAACc,IAAI,CAACD,IAAI,CAAC,EAAE;UAC/B,IAAIJ,OAAO,IAAIA,OAAO,CAACM,UAAU,CAAC,WAAW,CAAC,KAAK,UAAU,EAAE;YAC3DN,OAAO,CAACO,QAAQ,CAACC,IAAI,CAACJ,IAAI,CAAC;UAC/B;QACJ,CAAC,MAAM;UACHJ,OAAO,CAACO,QAAQ,CAACC,IAAI,CAAC,IAAI,CAACC,uBAAuB,CAACL,IAAI,CAAC,CAAC;QAC7D;MACJ,CAAC;;MAED;MACA;MACAN,MAAM,CAACY,cAAc,GAAGC,IAAI,IAAI;QAC5B,MAAMC,KAAK,GAAG;UAAEC,IAAI,EAAEF,IAAI,CAACE,IAAI;UAAEP,UAAU,EAAE,CAAC,CAAC;UAAEC,QAAQ,EAAE;QAAG,CAAC;QAC/D,IAAIP,OAAO,EAAE;UACTA,OAAO,CAACO,QAAQ,CAACC,IAAI,CAACI,KAAK,CAAC;QAChC,CAAC,MAAM;UACHb,MAAM,GAAGa,KAAK;QAClB;QAEAX,KAAK,CAACO,IAAI,CAACI,KAAK,CAAC;QACjBZ,OAAO,GAAGY,KAAK;MACnB,CAAC;;MAED;MACAd,MAAM,CAACgB,UAAU,GAAGH,IAAI,IAAI;QACxBV,KAAK,CAACc,GAAG,EAAE;QACXf,OAAO,GAAGC,KAAK,CAACA,KAAK,CAACe,MAAM,GAAG,CAAC,CAAC;MACrC,CAAC;;MAED;MACAlB,MAAM,CAACmB,WAAW,GAAGC,SAAS,IAAI;QAC9BlB,OAAO,CAACM,UAAU,CAACY,SAAS,CAACL,IAAI,CAAC,GAAG,IAAI,CAACJ,uBAAuB,CAACS,SAAS,CAACC,KAAK,CAAC;MACtF,CAAC;;MAED;MACArB,MAAM,CAACsB,KAAK,GAAG,MAAMxB,OAAO,CAACG,MAAM,CAAC;;MAEpC;MACAD,MAAM,CAACuB,KAAK,CAAC3B,OAAO,CAAC,CAAC4B,KAAK,EAAE;IACjC,CAAC,CAAC;EACN;;EAEA;AACJ;AACA;AACA;AACA;AACA;EACIb,uBAAuB,CAACc,GAAG,EAAE;IACzB,MAAMC,GAAG,GAAGC,MAAM,CAACF,GAAG,CAAC;IACvB,OAAOC,GAAG,CAACE,QAAQ,EAAE,KAAKH,GAAG,GAAGC,GAAG,GAAGD,GAAG;EAC7C;AACJ;AAEAI,MAAM,CAACC,OAAO,GAAGpC,SAAS"},"metadata":{},"sourceType":"script"}