{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/w2d/personeria/personeria-ui/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _ = require(\"lodash\");\nvar RichTextFragment = require(\"./RichTextFragment\");\n\n/**\n * A RichText class that contains many {@link RichTextFragment}.\n */\nvar RichText = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of RichText. If you get the instance by calling `Cell.value()`,\n   * adding a text contains line separator will trigger {@link Cell.style}('wrapText', true), which\n   * will make MS Excel show the new line. i.e. In MS Excel, Tap \"alt+Enter\" in a cell, the cell\n   * will set wrap text to true automatically.\n   *\n   * @param {undefined|null|Object} [node] - The node stored in the shared string\n   */\n  function RichText(node) {\n    _classCallCheck(this, RichText);\n    this._node = [];\n    this._cell = null;\n    this._remainingNodes = [];\n    if (node) {\n      for (var i = 0; i < node.length; i++) {\n        var fragment = node[i];\n        if (fragment.name === 'r') {\n          this._node.push(new RichTextFragment(fragment, null, this));\n        } else {\n          // special node, e.g. rPh, phoneticPr in Japanese language.\n          this._remainingNodes.push(fragment);\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets which cell this {@link RichText} instance belongs to.\n   * @return {Cell|undefined} The cell this instance belongs to.\n   */\n  _createClass(RichText, [{\n    key: \"cell\",\n    get: function get() {\n      return this._cell;\n    }\n\n    /**\n     * Gets the how many rich text fragment this {@link RichText} instance contains\n     * @return {number} The number of fragments this {@link RichText} instance has.\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._node.length;\n    }\n\n    /**\n     * Gets concatenated text without styles.\n     * @return {string} concatenated text\n     */\n  }, {\n    key: \"text\",\n    value: function text() {\n      var text = '';\n      for (var i = 0; i < this._node.length; i++) {\n        text += this.get(i).value();\n      }\n      return text;\n    }\n\n    /**\n     * Gets the instance with cell reference defined.\n     * @param {Cell} cell - Cell reference.\n     * @return {RichText} The instance with cell reference defined.\n     */\n  }, {\n    key: \"getInstanceWithCellRef\",\n    value: function getInstanceWithCellRef(cell) {\n      this._cell = cell;\n      return this;\n    }\n\n    /**\n     * Returns a deep copy of this instance.\n     * If cell reference is provided, it checks line separators and calls\n     * `cell.style('wrapText', true)` when needed.\n     * @param {Cell|undefined} [cell] - The cell reference.\n     * @return {RichText} A deep copied instance\n     */\n  }, {\n    key: \"copy\",\n    value: function copy(cell) {\n      var newRichText = new RichText(_.cloneDeep(this.toXml()));\n      if (cell && _.includes(this.text(), '\\n')) {\n        cell.style('wrapText', true);\n      }\n      return newRichText;\n    }\n\n    /**\n     * Gets the ith fragment of this {@link RichText} instance.\n     * @param {number} index - The index\n     * @return {RichTextFragment} A rich text fragment\n     */\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      return this._node[index];\n    }\n\n    /**\n     * Removes a rich text fragment. This instance will be mutated.\n     * @param {number} index - the index of the fragment to remove\n     * @return {RichText} the rich text instance\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(index) {\n      this._node.splice(index, 1);\n      this.removeUnsupportedNodes();\n      return this;\n    }\n\n    /**\n     * Adds a rich text fragment to the last or after the given index. This instance will be mutated.\n     * @param {string} text - the text\n     * @param {{}} [styles] - the styles js object, i.e. {fontSize: 12}\n     * @param {number|undefined|null} [index] - the index of the fragment to add\n     * @return {RichText} the rich text instance\n     */\n  }, {\n    key: \"add\",\n    value: function add(text, styles, index) {\n      if (index === undefined || index === null) {\n        this._node.push(new RichTextFragment(text, styles, this));\n      } else {\n        this._node.splice(index, 0, new RichTextFragment(text, styles, this));\n      }\n      this.removeUnsupportedNodes();\n      return this;\n    }\n\n    /**\n     * Clears this rich text\n     * @return {RichText} the rich text instance\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._node = [];\n      this._remainingNodes = [];\n      this._cell = undefined;\n      return this;\n    }\n\n    /**\n     * Remove all unsupported nodes (phoneticPr, rPh for Japanese language).\n     * @return {undefined}\n     */\n  }, {\n    key: \"removeUnsupportedNodes\",\n    value: function removeUnsupportedNodes() {\n      this._remainingNodes = [];\n    }\n\n    /**\n     * Convert the rich text to an XML object.\n     * @returns {Array.<{}>} The XML form.\n     * @ignore\n     */\n  }, {\n    key: \"toXml\",\n    value: function toXml() {\n      var node = [];\n      for (var i = 0; i < this._node.length; i++) {\n        node.push(this._node[i].toXml());\n      }\n      return node.concat(this._remainingNodes);\n    }\n  }]);\n  return RichText;\n}(); // IE doesn't support function names so explicitly set it.\nif (!RichText.name) RichText.name = \"RichText\";\nmodule.exports = RichText;","map":{"version":3,"names":["_","require","RichTextFragment","RichText","node","_node","_cell","_remainingNodes","i","length","fragment","name","push","text","get","value","cell","newRichText","cloneDeep","toXml","includes","style","index","splice","removeUnsupportedNodes","styles","undefined","concat","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/RichText.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst RichTextFragment = require(\"./RichTextFragment\");\n\n/**\n * A RichText class that contains many {@link RichTextFragment}.\n */\nclass RichText {\n    /**\n     * Creates a new instance of RichText. If you get the instance by calling `Cell.value()`,\n     * adding a text contains line separator will trigger {@link Cell.style}('wrapText', true), which\n     * will make MS Excel show the new line. i.e. In MS Excel, Tap \"alt+Enter\" in a cell, the cell\n     * will set wrap text to true automatically.\n     *\n     * @param {undefined|null|Object} [node] - The node stored in the shared string\n     */\n    constructor(node) {\n        this._node = [];\n        this._cell = null;\n        this._remainingNodes = [];\n        if (node) {\n            for (let i = 0; i < node.length; i++) {\n                const fragment = node[i];\n                if (fragment.name === 'r') {\n                    this._node.push(new RichTextFragment(fragment, null, this));\n                } else {\n                    // special node, e.g. rPh, phoneticPr in Japanese language.\n                    this._remainingNodes.push(fragment);\n                }\n            }\n        }\n    }\n\n    /**\n     * Gets which cell this {@link RichText} instance belongs to.\n     * @return {Cell|undefined} The cell this instance belongs to.\n     */\n    get cell() {\n        return this._cell;\n    }\n\n    /**\n     * Gets the how many rich text fragment this {@link RichText} instance contains\n     * @return {number} The number of fragments this {@link RichText} instance has.\n     */\n    get length() {\n        return this._node.length;\n    }\n\n    /**\n     * Gets concatenated text without styles.\n     * @return {string} concatenated text\n     */\n    text() {\n        let text = '';\n        for (let i = 0; i < this._node.length; i++) {\n            text += this.get(i).value();\n        }\n        return text;\n    }\n\n    /**\n     * Gets the instance with cell reference defined.\n     * @param {Cell} cell - Cell reference.\n     * @return {RichText} The instance with cell reference defined.\n     */\n    getInstanceWithCellRef(cell) {\n        this._cell = cell;\n        return this;\n    }\n\n    /**\n     * Returns a deep copy of this instance.\n     * If cell reference is provided, it checks line separators and calls\n     * `cell.style('wrapText', true)` when needed.\n     * @param {Cell|undefined} [cell] - The cell reference.\n     * @return {RichText} A deep copied instance\n     */\n    copy(cell) {\n        const newRichText = new RichText(_.cloneDeep(this.toXml()));\n        if (cell && _.includes(this.text(), '\\n')) {\n            cell.style('wrapText', true);\n        }\n        return newRichText;\n    }\n\n    /**\n     * Gets the ith fragment of this {@link RichText} instance.\n     * @param {number} index - The index\n     * @return {RichTextFragment} A rich text fragment\n     */\n    get(index) {\n        return this._node[index];\n    }\n\n    /**\n     * Removes a rich text fragment. This instance will be mutated.\n     * @param {number} index - the index of the fragment to remove\n     * @return {RichText} the rich text instance\n     */\n    remove(index) {\n        this._node.splice(index, 1);\n        this.removeUnsupportedNodes();\n        return this;\n    }\n\n    /**\n     * Adds a rich text fragment to the last or after the given index. This instance will be mutated.\n     * @param {string} text - the text\n     * @param {{}} [styles] - the styles js object, i.e. {fontSize: 12}\n     * @param {number|undefined|null} [index] - the index of the fragment to add\n     * @return {RichText} the rich text instance\n     */\n    add(text, styles, index) {\n        if (index === undefined || index === null) {\n            this._node.push(new RichTextFragment(text, styles, this));\n        } else {\n            this._node.splice(index, 0, new RichTextFragment(text, styles, this));\n        }\n        this.removeUnsupportedNodes();\n        return this;\n    }\n\n    /**\n     * Clears this rich text\n     * @return {RichText} the rich text instance\n     */\n    clear() {\n        this._node = [];\n        this._remainingNodes = [];\n        this._cell = undefined;\n        return this;\n    }\n\n    /**\n     * Remove all unsupported nodes (phoneticPr, rPh for Japanese language).\n     * @return {undefined}\n     */\n    removeUnsupportedNodes() {\n        this._remainingNodes = [];\n    }\n\n    /**\n     * Convert the rich text to an XML object.\n     * @returns {Array.<{}>} The XML form.\n     * @ignore\n     */\n    toXml() {\n        const node = [];\n        for (let i = 0; i < this._node.length; i++) {\n            node.push(this._node[i].toXml());\n        }\n        return node.concat(this._remainingNodes);\n    }\n}\n\n// IE doesn't support function names so explicitly set it.\nif (!RichText.name) RichText.name = \"RichText\";\n\nmodule.exports = RichText;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}