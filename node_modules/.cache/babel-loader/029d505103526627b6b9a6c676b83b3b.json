{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst fs = require(\"fs\");\nconst JSZip = require('jszip');\nconst externals = require(\"./externals\");\nconst regexify = require(\"./regexify\");\nconst blank = require(\"./blank\")();\nconst xmlq = require(\"./xmlq\");\nconst Sheet = require(\"./Sheet\");\nconst ContentTypes = require(\"./ContentTypes\");\nconst AppProperties = require(\"./AppProperties\");\nconst CoreProperties = require(\"./CoreProperties\");\nconst Relationships = require(\"./Relationships\");\nconst SharedStrings = require(\"./SharedStrings\");\nconst StyleSheet = require(\"./StyleSheet\");\nconst Encryptor = require(\"./Encryptor\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n// Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\nconst zipFileOpts = {\n  date: new Date(0),\n  createFolders: false\n};\n\n// Initialize the parser and builder.\nconst xmlParser = new XmlParser();\nconst xmlBuilder = new XmlBuilder();\n\n// Initialize the encryptor if present (can be excluded in browser build).\nconst encryptor = typeof Encryptor === \"function\" && new Encryptor();\n\n// Characters not allowed in sheet names.\nconst badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?'];\n\n// Excel limits sheet names to 31 chars.\nconst maxSheetNameLength = 31;\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\", \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\", \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"];\n\n/**\n * A workbook.\n */\nclass Workbook {\n  /**\n   * Create a new blank workbook.\n   * @returns {Promise.<Workbook>} The workbook.\n   * @ignore\n   */\n  static fromBlankAsync() {\n    return Workbook.fromDataAsync(blank);\n  }\n\n  /**\n   * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n   * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n   * @param {{}} [opts] - Options\n   * @returns {Promise.<Workbook>} The workbook.\n   * @ignore\n   */\n  static fromDataAsync(data, opts) {\n    return new Workbook()._initAsync(data, opts);\n  }\n\n  /**\n   * Loads a workbook from file.\n   * @param {string} path - The path to the workbook.\n   * @param {{}} [opts] - Options\n   * @returns {Promise.<Workbook>} The workbook.\n   * @ignore\n   */\n  static fromFileAsync(path, opts) {\n    if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n    return new externals.Promise((resolve, reject) => {\n      fs.readFile(path, (err, data) => {\n        if (err) return reject(err);\n        resolve(data);\n      });\n    }).then(data => Workbook.fromDataAsync(data, opts));\n  }\n\n  /**\n   * Get the active sheet in the workbook.\n   * @returns {Sheet} The active sheet.\n   */ /**\n      * Set the active sheet in the workbook.\n      * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n      * @returns {Workbook} The workbook.\n      */\n  activeSheet() {\n    return new ArgHandler('Workbook.activeSheet').case(() => {\n      return this._activeSheet;\n    }).case('*', sheet => {\n      // Get the sheet from name/index if needed.\n      if (!(sheet instanceof Sheet)) sheet = this.sheet(sheet);\n\n      // Check if the sheet is hidden.\n      if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\");\n\n      // Deselect all sheets except the active one (mirroring ying Excel behavior).\n      _.forEach(this._sheets, current => {\n        current.tabSelected(current === sheet);\n      });\n      this._activeSheet = sheet;\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Add a new sheet to the workbook.\n   * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Sheet} The new sheet.\n   */\n  addSheet(name, indexOrBeforeSheet) {\n    return this._addSheet(name, indexOrBeforeSheet);\n  }\n\n  /**\n   * Gets a defined name scoped to the workbook.\n   * @param {string} name - The defined name.\n   * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n   */ /**\n      * Set a defined name scoped to the workbook.\n      * @param {string} name - The defined name.\n      * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n      * @returns {Workbook} The workbook.\n      */\n  definedName() {\n    return new ArgHandler(\"Workbook.definedName\").case('string', name => {\n      return this.scopedDefinedName(undefined, name);\n    }).case(['string', '*'], (name, refersTo) => {\n      this.scopedDefinedName(undefined, name, refersTo);\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Delete a sheet from the workbook.\n   * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n   * @returns {Workbook} The workbook.\n   */\n  deleteSheet(sheet) {\n    // Get the sheet to move.\n    if (!(sheet instanceof Sheet)) {\n      sheet = this.sheet(sheet);\n      if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n    }\n\n    // Make sure we are not deleting the only visible sheet.\n    const visibleSheets = _.filter(this._sheets, sheet => !sheet.hidden());\n    if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n      throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n    }\n\n    // Remove the sheet.\n    let index = this._sheets.indexOf(sheet);\n    this._sheets.splice(index, 1);\n\n    // Set the new active sheet.\n    if (sheet === this.activeSheet()) {\n      if (index >= this._sheets.length) index--;\n      this.activeSheet(index);\n    }\n    return this;\n  }\n\n  /**\n   * Find the given pattern in the workbook and optionally replace it.\n   * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n   * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n   * @returns {boolean} A flag indicating if the pattern was found.\n   */\n  find(pattern, replacement) {\n    pattern = regexify(pattern);\n    let matches = [];\n    this._sheets.forEach(sheet => {\n      matches = matches.concat(sheet.find(pattern, replacement));\n    });\n    return matches;\n  }\n\n  /**\n   * Move a sheet to a new position.\n   * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Workbook} The workbook.\n   */\n  moveSheet(sheet, indexOrBeforeSheet) {\n    // Get the sheet to move.\n    if (!(sheet instanceof Sheet)) {\n      sheet = this.sheet(sheet);\n      if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n    }\n\n    // Get the to/from indexes.\n    const from = this._sheets.indexOf(sheet);\n    let to;\n    if (_.isNil(indexOrBeforeSheet)) {\n      to = this._sheets.length - 1;\n    } else if (_.isInteger(indexOrBeforeSheet)) {\n      to = indexOrBeforeSheet;\n    } else {\n      if (!(indexOrBeforeSheet instanceof Sheet)) {\n        indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n        if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n      }\n      to = this._sheets.indexOf(indexOrBeforeSheet);\n    }\n\n    // Insert the sheet at the appropriate place.\n    this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n    return this;\n  }\n\n  /**\n   * Generates the workbook output.\n   * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n   * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n   */ /**\n      * Generates the workbook output.\n      * @param {{}} [opts] Options\n      * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n      * @param {string} [opts.password] - The password to use to encrypt the workbook.\n      * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n      */\n  outputAsync(opts) {\n    opts = opts || {};\n    if (typeof opts === 'string') opts = {\n      type: opts\n    };\n    this._setSheetRefs();\n    let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n    this._sheets.forEach((sheet, i) => {\n      if (!sheet._autoFilter) return;\n      if (!definedNamesNode) {\n        definedNamesNode = {\n          name: \"definedNames\",\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n      }\n      xmlq.appendChild(definedNamesNode, {\n        name: \"definedName\",\n        attributes: {\n          name: \"_xlnm._FilterDatabase\",\n          localSheetId: i,\n          hidden: \"1\"\n        },\n        children: [sheet._autoFilter.address({\n          includeSheetName: true,\n          anchored: true\n        })]\n      });\n    });\n    this._sheetsNode.children = [];\n    this._sheets.forEach((sheet, i) => {\n      const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;\n      const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;\n      const sheetXmls = sheet.toXmls();\n      const relationship = this._relationships.findById(sheetXmls.id.attributes['r:id']);\n      relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;\n      this._sheetsNode.children.push(sheetXmls.id);\n      this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n      const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n      if (relationshipsXml) {\n        this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n      } else {\n        this._zip.remove(sheetRelsPath);\n      }\n    });\n\n    // Set the app security to true if a password is set, false if not.\n    // this._appProperties.isSecure(!!opts.password);\n\n    // Convert the various components to XML strings and add them to the zip.\n    this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n    this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n    this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n    this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n    this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n    this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n    this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts);\n\n    // Generate the zip.\n    return this._zip.generateAsync({\n      type: \"nodebuffer\",\n      compression: \"DEFLATE\"\n    }).then(output => {\n      // If a password is set, encrypt the workbook.\n      if (opts.password) output = encryptor.encrypt(output, opts.password);\n\n      // Convert and return\n      return this._convertBufferToOutput(output, opts.type);\n    });\n  }\n\n  /**\n   * Gets the sheet with the provided name or index (0-based).\n   * @param {string|number} sheetNameOrIndex - The sheet name or index.\n   * @returns {Sheet|undefined} The sheet or undefined if not found.\n   */\n  sheet(sheetNameOrIndex) {\n    if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n    return _.find(this._sheets, sheet => sheet.name() === sheetNameOrIndex);\n  }\n\n  /**\n   * Get an array of all the sheets in the workbook.\n   * @returns {Array.<Sheet>} The sheets.\n   */\n  sheets() {\n    return this._sheets.slice();\n  }\n\n  /**\n   * Gets an individual property.\n   * @param {string} name - The name of the property.\n   * @returns {*} The property.\n   */ /**\n      * Gets multiple properties.\n      * @param {Array.<string>} names - The names of the properties.\n      * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n      */ /**\n         * Sets an individual property.\n         * @param {string} name - The name of the property.\n         * @param {*} value - The value to set.\n         * @returns {Workbook} The workbook.\n         */ /**\n            * Sets multiple properties.\n            * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n            * @returns {Workbook} The workbook.\n            */\n  property() {\n    return new ArgHandler(\"Workbook.property\").case('string', name => {\n      // Get single value\n      return this._coreProperties.get(name);\n    }).case('array', names => {\n      // Get list of values\n      const values = {};\n      names.forEach(name => {\n        values[name] = this._coreProperties.get(name);\n      });\n      return values;\n    }).case(['string', '*'], (name, value) => {\n      // Set a single value for all cells to a single value\n      this._coreProperties.set(name, value);\n      return this;\n    }).case('object', nameValues => {\n      // Object of key value pairs to set\n      for (const name in nameValues) {\n        if (!nameValues.hasOwnProperty(name)) continue;\n        const value = nameValues[name];\n        this._coreProperties.set(name, value);\n      }\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Get access to core properties object\n   * @returns {CoreProperties} The core properties.\n   */\n  properties() {\n    return this._coreProperties;\n  }\n\n  /**\n   * Write the workbook to file. (Not supported in browsers.)\n   * @param {string} path - The path of the file to write.\n   * @param {{}} [opts] - Options\n   * @param {string} [opts.password] - The password to encrypt the workbook.\n   * @returns {Promise.<undefined>} A promise.\n   */\n  toFileAsync(path, opts) {\n    if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n    return this.outputAsync(opts).then(data => new externals.Promise((resolve, reject) => {\n      fs.writeFile(path, data, err => {\n        if (err) return reject(err);\n        resolve();\n      });\n    }));\n  }\n\n  /**\n   * Gets a scoped defined name.\n   * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n   * @param {string} name - The defined name.\n   * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n   * @ignore\n   */ /**\n      * Sets a scoped defined name.\n      * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n      * @param {string} name - The defined name.\n      * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n      * @returns {Workbook} The workbook.\n      * @ignore\n      */\n  scopedDefinedName(sheetScope, name, refersTo) {\n    let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n    let definedNameNode = definedNamesNode && _.find(definedNamesNode.children, node => node.attributes.name === name && node.localSheet === sheetScope);\n    return new ArgHandler('Workbook.scopedDefinedName').case(['*', 'string'], () => {\n      // Get the address from the definedNames node.\n      const refersTo = definedNameNode && definedNameNode.children[0];\n      if (!refersTo) return undefined;\n\n      // Try to parse the address.\n      const ref = addressConverter.fromAddress(refersTo);\n      if (!ref) return refersTo;\n\n      // Load the appropriate selection type.\n      const sheet = this.sheet(ref.sheetName);\n      if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n      if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n      if (ref.type === 'row') return sheet.row(ref.rowNumber);\n      if (ref.type === 'column') return sheet.column(ref.columnNumber);\n      return refersTo;\n    }).case(['*', 'string', 'nil'], () => {\n      if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n      if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(this._node, definedNamesNode);\n      return this;\n    }).case(['*', 'string', '*'], () => {\n      if (typeof refersTo !== 'string') {\n        refersTo = refersTo.address({\n          includeSheetName: true,\n          anchored: true\n        });\n      }\n      if (!definedNamesNode) {\n        definedNamesNode = {\n          name: \"definedNames\",\n          attributes: {},\n          children: []\n        };\n        xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n      }\n      if (!definedNameNode) {\n        definedNameNode = {\n          name: \"definedName\",\n          attributes: {\n            name\n          },\n          children: [refersTo]\n        };\n        if (sheetScope) definedNameNode.localSheet = sheetScope;\n        xmlq.appendChild(definedNamesNode, definedNameNode);\n      }\n      definedNameNode.children = [refersTo];\n      return this;\n    }).handle(arguments);\n  }\n\n  /**\n   * Get the shared strings table.\n   * @returns {SharedStrings} The shared strings table.\n   * @ignore\n   */\n  sharedStrings() {\n    return this._sharedStrings;\n  }\n\n  /**\n   * Get the style sheet.\n   * @returns {StyleSheet} The style sheet.\n   * @ignore\n   */\n  styleSheet() {\n    return this._styleSheet;\n  }\n\n  /**\n   * Add a new sheet to the workbook.\n   * \n   * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n   * @param {Sheet} from - The sheet to be cloned.\n   * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @returns {Sheet} The new sheet.\n   */\n  cloneSheet(from, name, indexOrBeforeSheet) {\n    if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n    return this._addSheet(name, indexOrBeforeSheet, () => {\n      const cloneXml = node => {\n        // If the node has a toXml method, call it.\n        if (node && _.isFunction(node.toXml)) node = node.toXml();\n        if (typeof node === 'object') {\n          if (node.name) {\n            const result = {\n              name: node.name,\n              attributes: {},\n              children: []\n            };\n            _.forOwn(node.attributes, (value, name) => {\n              result.attributes[name] = value;\n            });\n            let chld;\n            if (node.children) {\n              node.children.forEach(child => {\n                chld = cloneXml(child);\n                if (child !== null) {\n                  result.children.push(chld);\n                }\n              });\n            }\n            return result;\n          }\n        } else if (node !== null) {\n          return node;\n        }\n        return null;\n      };\n\n      // clone SheetNode & relationshipNode from source\n      const fromXml = from.toXmls();\n      const sheetNode = cloneXml(fromXml.sheet);\n      const relationshipNode = cloneXml(fromXml.relationships);\n      return {\n        sheetNode,\n        relationshipNode\n      };\n    });\n  }\n\n  /**\n   * Add a new sheet to the workbook.\n   * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n   * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n   * @param {callback} [getTemplateNodes] optional callback function for template nodes\n   * @returns {Sheet} The new sheet.\n   * @private\n   */\n  _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n    // Validate the sheet name.\n    if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n    if (_.some(badSheetNameChars, char => name.indexOf(char) >= 0)) throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(\" \")}`);\n    if (name.length > maxSheetNameLength) throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);\n    if (this.sheet(name)) throw new Error(`Sheet with name \"${name}\" already exists.`);\n\n    // Get the destination index of new sheet.\n    let index;\n    if (_.isNil(indexOrBeforeSheet)) {\n      index = this._sheets.length;\n    } else if (_.isInteger(indexOrBeforeSheet)) {\n      index = indexOrBeforeSheet;\n    } else {\n      if (!(indexOrBeforeSheet instanceof Sheet)) {\n        indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n        if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n      }\n      index = this._sheets.indexOf(indexOrBeforeSheet);\n    }\n\n    // Add a new relationship for the new sheet and create the new sheet ID node.\n    const relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n    const sheetIdNode = {\n      name: \"sheet\",\n      attributes: {\n        name,\n        sheetId: ++this._maxSheetId,\n        'r:id': relationship.attributes.Id\n      },\n      children: []\n    };\n\n    // Create the new sheet.\n    let sheet;\n    if (getTemplateNodes) {\n      const {\n        sheetNode,\n        relationshipNode\n      } = getTemplateNodes();\n      sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n    } else {\n      sheet = new Sheet(this, sheetIdNode);\n    }\n\n    // Insert the sheet at the appropriate index.\n    this._sheets.splice(index, 0, sheet);\n    return sheet;\n  }\n\n  /**\n   * Initialize the workbook. (This is separated from the constructor to ease testing.)\n   * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n   * @param {{}} [opts] - Options\n   * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n   * @returns {Promise.<Workbook>} The workbook.\n   * @private\n   */\n  _initAsync(data, opts) {\n    opts = opts || {};\n    this._maxSheetId = 0;\n    this._sheets = [];\n    return externals.Promise.resolve().then(() => {\n      // Make sure the input is a Buffer\n      return this._convertInputToBufferAsync(data, opts.base64).then(buffer => {\n        data = buffer;\n      });\n    }).then(() => {\n      if (!opts.password) return;\n      return encryptor.decryptAsync(data, opts.password).then(decrypted => {\n        data = decrypted;\n      });\n    }).then(() => JSZip.loadAsync(data)).then(zip => {\n      this._zip = zip;\n      return this._parseNodesAsync([\"[Content_Types].xml\", \"docProps/app.xml\", \"docProps/core.xml\", \"xl/_rels/workbook.xml.rels\", \"xl/sharedStrings.xml\", \"xl/styles.xml\", \"xl/workbook.xml\"]);\n    }).then(nodes => {\n      const contentTypesNode = nodes[0];\n      const appPropertiesNode = nodes[1];\n      const corePropertiesNode = nodes[2];\n      const relationshipsNode = nodes[3];\n      const sharedStringsNode = nodes[4];\n      const styleSheetNode = nodes[5];\n      const workbookNode = nodes[6];\n\n      // Load the various components.\n      this._contentTypes = new ContentTypes(contentTypesNode);\n      this._appProperties = new AppProperties(appPropertiesNode);\n      this._coreProperties = new CoreProperties(corePropertiesNode);\n      this._relationships = new Relationships(relationshipsNode);\n      this._sharedStrings = new SharedStrings(sharedStringsNode);\n      this._styleSheet = new StyleSheet(styleSheetNode);\n      this._node = workbookNode;\n\n      // Add the shared strings relationship if it doesn't exist.\n      if (!this._relationships.findByType(\"sharedStrings\")) {\n        this._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n      }\n\n      // Add the shared string content type if it doesn't exist.\n      if (!this._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n        this._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n      }\n\n      // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n      this._zip.remove(\"xl/calcChain.xml\");\n\n      // Load each sheet.\n      this._sheetsNode = xmlq.findChild(this._node, \"sheets\");\n      return externals.Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {\n        if (sheetIdNode.attributes.sheetId > this._maxSheetId) this._maxSheetId = sheetIdNode.attributes.sheetId;\n        return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`]).then(nodes => {\n          const sheetNode = nodes[0];\n          const sheetRelationshipsNode = nodes[1];\n\n          // Insert at position i as the promises will resolve at different times.\n          this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);\n        });\n      }));\n    }).then(() => this._parseSheetRefs()).then(() => this);\n  }\n\n  /**\n   * Parse files out of zip into XML node objects.\n   * @param {Array.<string>} names - The file names to parse.\n   * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n   * @private\n   */\n  _parseNodesAsync(names) {\n    return externals.Promise.all(_.map(names, name => this._zip.file(name))).then(files => externals.Promise.all(_.map(files, file => file && file.async(\"string\")))).then(texts => externals.Promise.all(_.map(texts, text => text && xmlParser.parseAsync(text))));\n  }\n\n  /**\n   * Parse the sheet references out so we can reorder freely.\n   * @returns {undefined}\n   * @private\n   */\n  _parseSheetRefs() {\n    // Parse the active sheet.\n    const bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n    const workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n    const activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n    this._activeSheet = this._sheets[activeTabId];\n\n    // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n    // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n    const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n    if (definedNamesNode) {\n      _.forEach(definedNamesNode.children, definedNameNode => {\n        if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n          definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];\n        }\n      });\n    }\n  }\n\n  /**\n   * Set the proper sheet references in the XML.\n   * @returns {undefined}\n   * @private\n   */\n  _setSheetRefs() {\n    // Set the active sheet.\n    let bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n    if (!bookViewsNode) {\n      bookViewsNode = {\n        name: 'bookViews',\n        attributes: {},\n        children: []\n      };\n      xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n    }\n    let workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n    if (!workbookViewNode) {\n      workbookViewNode = {\n        name: 'workbookView',\n        attributes: {},\n        children: []\n      };\n      xmlq.appendChild(bookViewsNode, workbookViewNode);\n    }\n    workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);\n\n    // Set the defined names local sheet indexes.\n    const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n    if (definedNamesNode) {\n      _.forEach(definedNamesNode.children, definedNameNode => {\n        if (definedNameNode.localSheet) {\n          definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);\n        }\n      });\n    }\n  }\n\n  /**\n   * Convert buffer to desired output format\n   * @param {Buffer} buffer - The buffer\n   * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n   * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n   * @private\n   */\n  _convertBufferToOutput(buffer, type) {\n    if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n    if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n    if (process.browser && type === \"blob\") return new Blob([buffer], {\n      type: Workbook.MIME_TYPE\n    });\n    if (type === \"base64\") return buffer.toString(\"base64\");\n    if (type === \"binarystring\") return buffer.toString(\"utf8\");\n    if (type === \"uint8array\") return new Uint8Array(buffer);\n    if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n    throw new Error(`Output type '${type}' not supported.`);\n  }\n\n  /**\n   * Convert input to buffer\n   * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n   * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n   * @returns {Promise.<Buffer>} The buffer.\n   * @private\n   */\n  _convertInputToBufferAsync(input, base64) {\n    return externals.Promise.resolve().then(() => {\n      if (Buffer.isBuffer(input)) return input;\n      if (process.browser && input instanceof Blob) {\n        return new externals.Promise(resolve => {\n          const fileReader = new FileReader();\n          fileReader.onload = event => {\n            resolve(Buffer.from(event.target.result));\n          };\n          fileReader.readAsArrayBuffer(input);\n        });\n      }\n      if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n      if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n      if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n      throw new Error(`Input type unknown.`);\n    });\n  }\n}\n\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\nmodule.exports = Workbook;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */","map":{"version":3,"names":["_","require","fs","JSZip","externals","regexify","blank","xmlq","Sheet","ContentTypes","AppProperties","CoreProperties","Relationships","SharedStrings","StyleSheet","Encryptor","XmlParser","XmlBuilder","ArgHandler","addressConverter","zipFileOpts","date","Date","createFolders","xmlParser","xmlBuilder","encryptor","badSheetNameChars","maxSheetNameLength","nodeOrder","Workbook","fromBlankAsync","fromDataAsync","data","opts","_initAsync","fromFileAsync","path","process","browser","Error","Promise","resolve","reject","readFile","err","then","activeSheet","case","_activeSheet","sheet","hidden","forEach","_sheets","current","tabSelected","handle","arguments","addSheet","name","indexOrBeforeSheet","_addSheet","definedName","scopedDefinedName","undefined","refersTo","deleteSheet","visibleSheets","filter","length","index","indexOf","splice","find","pattern","replacement","matches","concat","moveSheet","from","to","isNil","isInteger","outputAsync","type","_setSheetRefs","definedNamesNode","findChild","_node","i","_autoFilter","attributes","children","insertInOrder","appendChild","localSheetId","address","includeSheetName","anchored","_sheetsNode","sheetPath","sheetRelsPath","sheetXmls","toXmls","relationship","_relationships","findById","id","Target","push","_zip","file","build","relationshipsXml","relationships","remove","_contentTypes","_appProperties","_coreProperties","_sharedStrings","_styleSheet","generateAsync","compression","output","password","encrypt","_convertBufferToOutput","sheetNameOrIndex","sheets","slice","property","get","names","values","value","set","nameValues","hasOwnProperty","properties","toFileAsync","writeFile","sheetScope","definedNameNode","node","localSheet","ref","fromAddress","sheetName","cell","rowNumber","columnNumber","range","startRowNumber","startColumnNumber","endRowNumber","endColumnNumber","row","column","removeChild","sharedStrings","styleSheet","cloneSheet","cloneXml","isFunction","toXml","result","forOwn","chld","child","fromXml","sheetNode","relationshipNode","getTemplateNodes","some","char","join","add","sheetIdNode","sheetId","_maxSheetId","Id","_convertInputToBufferAsync","base64","buffer","decryptAsync","decrypted","loadAsync","zip","_parseNodesAsync","nodes","contentTypesNode","appPropertiesNode","corePropertiesNode","relationshipsNode","sharedStringsNode","styleSheetNode","workbookNode","findByType","findByPartName","all","map","sheetRelationshipsNode","_parseSheetRefs","files","async","texts","text","parseAsync","bookViewsNode","workbookViewNode","activeTabId","activeTab","Blob","MIME_TYPE","toString","Uint8Array","input","Buffer","isBuffer","fileReader","FileReader","onload","event","target","readAsArrayBuffer","ArrayBuffer","module","exports"],"sources":["C:/w2d/personeria/personeria-ui/node_modules/xlsx-populate/lib/Workbook.js"],"sourcesContent":["\"use strict\";\n\nconst _ = require(\"lodash\");\nconst fs = require(\"fs\");\nconst JSZip = require('jszip');\n\nconst externals = require(\"./externals\");\nconst regexify = require(\"./regexify\");\nconst blank = require(\"./blank\")();\nconst xmlq = require(\"./xmlq\");\nconst Sheet = require(\"./Sheet\");\nconst ContentTypes = require(\"./ContentTypes\");\nconst AppProperties = require(\"./AppProperties\");\nconst CoreProperties = require(\"./CoreProperties\");\nconst Relationships = require(\"./Relationships\");\nconst SharedStrings = require(\"./SharedStrings\");\nconst StyleSheet = require(\"./StyleSheet\");\nconst Encryptor = require(\"./Encryptor\");\nconst XmlParser = require(\"./XmlParser\");\nconst XmlBuilder = require(\"./XmlBuilder\");\nconst ArgHandler = require(\"./ArgHandler\");\nconst addressConverter = require(\"./addressConverter\");\n\n// Options for adding files to zip. Do not create folders and use a fixed time at epoch.\n// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.\nconst zipFileOpts = {\n    date: new Date(0),\n    createFolders: false\n};\n\n// Initialize the parser and builder.\nconst xmlParser = new XmlParser();\nconst xmlBuilder = new XmlBuilder();\n\n// Initialize the encryptor if present (can be excluded in browser build).\nconst encryptor = typeof Encryptor === \"function\" && new Encryptor();\n\n// Characters not allowed in sheet names.\nconst badSheetNameChars = ['\\\\', '/', '*', '[', ']', ':', '?'];\n\n// Excel limits sheet names to 31 chars.\nconst maxSheetNameLength = 31;\n\n// Order of the nodes as defined by the spec.\nconst nodeOrder = [\n    \"fileVersion\", \"fileSharing\", \"workbookPr\", \"workbookProtection\", \"bookViews\", \"sheets\", \"functionGroups\",\n    \"externalReferences\", \"definedNames\", \"calcPr\", \"oleSize\", \"customWorkbookViews\", \"pivotCaches\", \"smartTagPr\",\n    \"smartTagTypes\", \"webPublishing\", \"fileRecoveryPr\", \"webPublishObjects\", \"extLst\"\n];\n\n/**\n * A workbook.\n */\nclass Workbook {\n    /**\n     * Create a new blank workbook.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromBlankAsync() {\n        return Workbook.fromDataAsync(blank);\n    }\n\n    /**\n     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)\n     * @param {string|Array.<number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.<*>} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromDataAsync(data, opts) {\n        return new Workbook()._initAsync(data, opts);\n    }\n\n    /**\n     * Loads a workbook from file.\n     * @param {string} path - The path to the workbook.\n     * @param {{}} [opts] - Options\n     * @returns {Promise.<Workbook>} The workbook.\n     * @ignore\n     */\n    static fromFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.fromFileAsync is not supported in the browser\");\n        return new externals.Promise((resolve, reject) => {\n            fs.readFile(path, (err, data) => {\n                if (err) return reject(err);\n                resolve(data);\n            });\n        }).then(data => Workbook.fromDataAsync(data, opts));\n    }\n\n    /**\n     * Get the active sheet in the workbook.\n     * @returns {Sheet} The active sheet.\n     *//**\n     * Set the active sheet in the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.\n     * @returns {Workbook} The workbook.\n     */\n    activeSheet() {\n        return new ArgHandler('Workbook.activeSheet')\n            .case(() => {\n                return this._activeSheet;\n            })\n            .case('*', sheet => {\n                // Get the sheet from name/index if needed.\n                if (!(sheet instanceof Sheet)) sheet = this.sheet(sheet);\n\n                // Check if the sheet is hidden.\n                if (sheet.hidden()) throw new Error(\"You may not activate a hidden sheet.\");\n\n                // Deselect all sheets except the active one (mirroring ying Excel behavior).\n                _.forEach(this._sheets, current => {\n                    current.tabSelected(current === sheet);\n                });\n\n                this._activeSheet = sheet;\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    addSheet(name, indexOrBeforeSheet) {\n        return this._addSheet(name, indexOrBeforeSheet);\n    }\n    \n    /**\n     * Gets a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.\n     *//**\n     * Set a defined name scoped to the workbook.\n     * @param {string} name - The defined name.\n     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.\n     * @returns {Workbook} The workbook.\n     */\n    definedName() {\n        return new ArgHandler(\"Workbook.definedName\")\n            .case('string', name => {\n                return this.scopedDefinedName(undefined, name);\n            })\n            .case(['string', '*'], (name, refersTo) => {\n                this.scopedDefinedName(undefined, name, refersTo);\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Delete a sheet from the workbook.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @returns {Workbook} The workbook.\n     */\n    deleteSheet(sheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Make sure we are not deleting the only visible sheet.\n        const visibleSheets = _.filter(this._sheets, sheet => !sheet.hidden());\n        if (visibleSheets.length === 1 && visibleSheets[0] === sheet) {\n            throw new Error(\"This sheet may not be deleted as a workbook must contain at least one visible sheet.\");\n        }\n\n        // Remove the sheet.\n        let index = this._sheets.indexOf(sheet);\n        this._sheets.splice(index, 1);\n\n        // Set the new active sheet.\n        if (sheet === this.activeSheet()) {\n            if (index >= this._sheets.length) index--;\n            this.activeSheet(index);\n        }\n\n        return this;\n    }\n\n    /**\n     * Find the given pattern in the workbook and optionally replace it.\n     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.\n     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.\n     * @returns {boolean} A flag indicating if the pattern was found.\n     */\n    find(pattern, replacement) {\n        pattern = regexify(pattern);\n\n        let matches = [];\n        this._sheets.forEach(sheet => {\n            matches = matches.concat(sheet.find(pattern, replacement));\n        });\n\n        return matches;\n    }\n\n    /**\n     * Move a sheet to a new position.\n     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Workbook} The workbook.\n     */\n    moveSheet(sheet, indexOrBeforeSheet) {\n        // Get the sheet to move.\n        if (!(sheet instanceof Sheet)) {\n            sheet = this.sheet(sheet);\n            if (!sheet) throw new Error(\"Invalid move sheet reference.\");\n        }\n\n        // Get the to/from indexes.\n        const from = this._sheets.indexOf(sheet);\n        let to;\n        if (_.isNil(indexOrBeforeSheet)) {\n            to = this._sheets.length - 1;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            to = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            to = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Insert the sheet at the appropriate place.\n        this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);\n\n        return this;\n    }\n\n    /**\n     * Generates the workbook output.\n     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     *//**\n     * Generates the workbook output.\n     * @param {{}} [opts] Options\n     * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.\n     * @param {string} [opts.password] - The password to use to encrypt the workbook.\n     * @returns {Promise<string|Uint8Array|ArrayBuffer|Blob|Buffer>} The data.\n     */\n    outputAsync(opts) {\n        opts = opts || {};\n        if (typeof opts === 'string') opts = { type: opts };\n\n        this._setSheetRefs();\n\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n\n        this._sheets.forEach((sheet, i) => {\n            if (!sheet._autoFilter) return;\n\n            if (!definedNamesNode) {\n                definedNamesNode = {\n                    name: \"definedNames\",\n                    attributes: {},\n                    children: []\n                };\n\n                xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n            }\n\n            xmlq.appendChild(definedNamesNode, {\n                name: \"definedName\",\n                attributes: {\n                    name: \"_xlnm._FilterDatabase\",\n                    localSheetId: i,\n                    hidden: \"1\"\n                },\n                children: [sheet._autoFilter.address({ includeSheetName: true, anchored: true })]\n            });\n        });\n\n        this._sheetsNode.children = [];\n        this._sheets.forEach((sheet, i) => {\n            const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;\n            const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;\n            const sheetXmls = sheet.toXmls();\n            const relationship = this._relationships.findById(sheetXmls.id.attributes['r:id']);\n            relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;\n            this._sheetsNode.children.push(sheetXmls.id);\n            this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);\n\n            const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);\n            if (relationshipsXml) {\n                this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);\n            } else {\n                this._zip.remove(sheetRelsPath);\n            }\n        });\n\n        // Set the app security to true if a password is set, false if not.\n        // this._appProperties.isSecure(!!opts.password);\n\n        // Convert the various components to XML strings and add them to the zip.\n        this._zip.file(\"[Content_Types].xml\", xmlBuilder.build(this._contentTypes), zipFileOpts);\n        this._zip.file(\"docProps/app.xml\", xmlBuilder.build(this._appProperties), zipFileOpts);\n        this._zip.file(\"docProps/core.xml\", xmlBuilder.build(this._coreProperties), zipFileOpts);\n        this._zip.file(\"xl/_rels/workbook.xml.rels\", xmlBuilder.build(this._relationships), zipFileOpts);\n        this._zip.file(\"xl/sharedStrings.xml\", xmlBuilder.build(this._sharedStrings), zipFileOpts);\n        this._zip.file(\"xl/styles.xml\", xmlBuilder.build(this._styleSheet), zipFileOpts);\n        this._zip.file(\"xl/workbook.xml\", xmlBuilder.build(this._node), zipFileOpts);\n\n        // Generate the zip.\n        return this._zip.generateAsync({\n            type: \"nodebuffer\",\n            compression: \"DEFLATE\"\n        }).then(output => {\n            // If a password is set, encrypt the workbook.\n            if (opts.password) output = encryptor.encrypt(output, opts.password);\n\n            // Convert and return\n            return this._convertBufferToOutput(output, opts.type);\n        });\n    }\n\n    /**\n     * Gets the sheet with the provided name or index (0-based).\n     * @param {string|number} sheetNameOrIndex - The sheet name or index.\n     * @returns {Sheet|undefined} The sheet or undefined if not found.\n     */\n    sheet(sheetNameOrIndex) {\n        if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];\n        return _.find(this._sheets, sheet => sheet.name() === sheetNameOrIndex);\n    }\n\n    /**\n     * Get an array of all the sheets in the workbook.\n     * @returns {Array.<Sheet>} The sheets.\n     */\n    sheets() {\n        return this._sheets.slice();\n    }\n\n    /**\n     * Gets an individual property.\n     * @param {string} name - The name of the property.\n     * @returns {*} The property.\n     *//**\n     * Gets multiple properties.\n     * @param {Array.<string>} names - The names of the properties.\n     * @returns {object.<string, *>} Object whose keys are the property names and values are the properties.\n     *//**\n     * Sets an individual property.\n     * @param {string} name - The name of the property.\n     * @param {*} value - The value to set.\n     * @returns {Workbook} The workbook.\n     *//**\n     * Sets multiple properties.\n     * @param {object.<string, *>} properties - Object whose keys are the property names and values are the values to set.\n     * @returns {Workbook} The workbook.\n     */\n    property() {\n        return new ArgHandler(\"Workbook.property\")\n            .case('string', name => {\n                // Get single value\n                return this._coreProperties.get(name);\n            })\n            .case('array', names => {\n                // Get list of values\n                const values = {};\n                names.forEach(name => {\n                    values[name] = this._coreProperties.get(name);\n                });\n\n                return values;\n            })\n            .case(['string', '*'], (name, value) => {\n                // Set a single value for all cells to a single value\n                this._coreProperties.set(name, value);\n                return this;\n            })\n            .case('object', nameValues => {\n                // Object of key value pairs to set\n                for (const name in nameValues) {\n                    if (!nameValues.hasOwnProperty(name)) continue;\n                    const value = nameValues[name];\n                    this._coreProperties.set(name, value);\n                }\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get access to core properties object\n     * @returns {CoreProperties} The core properties.\n     */\n    properties() {\n        return this._coreProperties;\n    }\n\n    /**\n     * Write the workbook to file. (Not supported in browsers.)\n     * @param {string} path - The path of the file to write.\n     * @param {{}} [opts] - Options\n     * @param {string} [opts.password] - The password to encrypt the workbook.\n     * @returns {Promise.<undefined>} A promise.\n     */\n    toFileAsync(path, opts) {\n        if (process.browser) throw new Error(\"Workbook.toFileAsync is not supported in the browser.\");\n        return this.outputAsync(opts)\n            .then(data => new externals.Promise((resolve, reject) => {\n                fs.writeFile(path, data, err => {\n                    if (err) return reject(err);\n                    resolve();\n                });\n            }));\n    }\n\n    /**\n     * Gets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @returns {undefined|Cell|Range|Row|Column} What the defined name refers to.\n     * @ignore\n     *//**\n     * Sets a scoped defined name.\n     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.\n     * @param {string} name - The defined name.\n     * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.\n     * @returns {Workbook} The workbook.\n     * @ignore\n     */\n    scopedDefinedName(sheetScope, name, refersTo) {\n        let definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        let definedNameNode = definedNamesNode && _.find(definedNamesNode.children, node => node.attributes.name === name && node.localSheet === sheetScope);\n\n        return new ArgHandler('Workbook.scopedDefinedName')\n            .case(['*', 'string'], () => {\n                // Get the address from the definedNames node.\n                const refersTo = definedNameNode && definedNameNode.children[0];\n                if (!refersTo) return undefined;\n\n                // Try to parse the address.\n                const ref = addressConverter.fromAddress(refersTo);\n                if (!ref) return refersTo;\n\n                // Load the appropriate selection type.\n                const sheet = this.sheet(ref.sheetName);\n                if (ref.type === 'cell') return sheet.cell(ref.rowNumber, ref.columnNumber);\n                if (ref.type === 'range') return sheet.range(ref.startRowNumber, ref.startColumnNumber, ref.endRowNumber, ref.endColumnNumber);\n                if (ref.type === 'row') return sheet.row(ref.rowNumber);\n                if (ref.type === 'column') return sheet.column(ref.columnNumber);\n                return refersTo;\n            })\n            .case(['*', 'string', 'nil'], () => {\n                if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);\n                if (definedNamesNode && !definedNamesNode.children.length) xmlq.removeChild(this._node, definedNamesNode);\n                return this;\n            })\n            .case(['*', 'string', '*'], () => {\n                if (typeof refersTo !== 'string') {\n                    refersTo = refersTo.address({\n                        includeSheetName: true,\n                        anchored: true\n                    });\n                }\n\n                if (!definedNamesNode) {\n                    definedNamesNode = {\n                        name: \"definedNames\",\n                        attributes: {},\n                        children: []\n                    };\n\n                    xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);\n                }\n\n                if (!definedNameNode) {\n                    definedNameNode = {\n                        name: \"definedName\",\n                        attributes: { name },\n                        children: [refersTo]\n                    };\n\n                    if (sheetScope) definedNameNode.localSheet = sheetScope;\n\n                    xmlq.appendChild(definedNamesNode, definedNameNode);\n                }\n\n                definedNameNode.children = [refersTo];\n\n                return this;\n            })\n            .handle(arguments);\n    }\n\n    /**\n     * Get the shared strings table.\n     * @returns {SharedStrings} The shared strings table.\n     * @ignore\n     */\n    sharedStrings() {\n        return this._sharedStrings;\n    }\n\n    /**\n     * Get the style sheet.\n     * @returns {StyleSheet} The style sheet.\n     * @ignore\n     */\n    styleSheet() {\n        return this._styleSheet;\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * \n     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.\n     * @param {Sheet} from - The sheet to be cloned.\n     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @returns {Sheet} The new sheet.\n     */\n    cloneSheet(from, name, indexOrBeforeSheet) {\n        if (!from || !(from instanceof Sheet)) throw new Error(\"Invalid clone from.\");\n\n        return this._addSheet(name, indexOrBeforeSheet, () => {\n            const cloneXml = node => {\n                // If the node has a toXml method, call it.\n                if (node && _.isFunction(node.toXml)) node = node.toXml();\n        \n                if (typeof node === 'object') {\n                    if (node.name) {\n                        const result = {\n                            name: node.name,\n                            attributes: {},\n                            children: []\n                        };\n                        \n                        _.forOwn(node.attributes, (value, name) => {\n                            result.attributes[name] = value;\n                        }); \n                    \n                        let chld;\n                        if (node.children) { \n                            node.children.forEach(child => {\n                                chld = cloneXml(child);\n                                if (child !== null) {\n                                    result.children.push(chld);\n                                }\n                            });\n                        }\n                        return result;\n                    }\n                } else if (node !== null) {\n                    return node;\n                } \n                return null;\n            };\n\n            // clone SheetNode & relationshipNode from source\n            const fromXml = from.toXmls();\n            const sheetNode = cloneXml(fromXml.sheet);\n            const relationshipNode = cloneXml(fromXml.relationships);\n            return { sheetNode, relationshipNode };\n        });\n    }\n\n    /**\n     * Add a new sheet to the workbook.\n     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \\ / * [ ] : ?\n     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.\n     * @param {callback} [getTemplateNodes] optional callback function for template nodes\n     * @returns {Sheet} The new sheet.\n     * @private\n     */\n    _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {\n        // Validate the sheet name.\n        if (!name || typeof name !== \"string\") throw new Error(\"Invalid sheet name.\");\n        if (_.some(badSheetNameChars, char => name.indexOf(char) >= 0)) throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(\" \")}`);\n        if (name.length > maxSheetNameLength) throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);\n        if (this.sheet(name)) throw new Error(`Sheet with name \"${name}\" already exists.`);\n\n        // Get the destination index of new sheet.\n        let index;\n        if (_.isNil(indexOrBeforeSheet)) {\n            index = this._sheets.length;\n        } else if (_.isInteger(indexOrBeforeSheet)) {\n            index = indexOrBeforeSheet;\n        } else {\n            if (!(indexOrBeforeSheet instanceof Sheet)) {\n                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);\n                if (!indexOrBeforeSheet) throw new Error(\"Invalid before sheet reference.\");\n            }\n\n            index = this._sheets.indexOf(indexOrBeforeSheet);\n        }\n\n        // Add a new relationship for the new sheet and create the new sheet ID node.\n        const relationship = this._relationships.add(\"worksheet\"); // Leave target blank as it will be filled later.\n        const sheetIdNode = {\n            name: \"sheet\",\n            attributes: {\n                name,\n                sheetId: ++this._maxSheetId,\n                'r:id': relationship.attributes.Id\n            },\n            children: []\n        };\n\n        // Create the new sheet.\n        let sheet;\n        if (getTemplateNodes) {\n            const { sheetNode, relationshipNode } = getTemplateNodes();\n            sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);\n        } else {\n            sheet = new Sheet(this, sheetIdNode);\n        }\n\n        // Insert the sheet at the appropriate index.\n        this._sheets.splice(index, 0, sheet);\n\n        return sheet;\n    }\n\n    /**\n     * Initialize the workbook. (This is separated from the constructor to ease testing.)\n     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.\n     * @param {{}} [opts] - Options\n     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.\n     * @returns {Promise.<Workbook>} The workbook.\n     * @private\n     */\n    _initAsync(data, opts) {\n        opts = opts || {};\n\n        this._maxSheetId = 0;\n        this._sheets = [];\n\n        return externals.Promise.resolve()\n            .then(() => {\n                // Make sure the input is a Buffer\n                return this._convertInputToBufferAsync(data, opts.base64)\n                    .then(buffer => {\n                        data = buffer;\n                    });\n            })\n            .then(() => {\n                if (!opts.password) return;\n                return encryptor.decryptAsync(data, opts.password)\n                    .then(decrypted => {\n                        data = decrypted;\n                    });\n            })\n            .then(() => JSZip.loadAsync(data))\n            .then(zip => {\n                this._zip = zip;\n                return this._parseNodesAsync([\n                    \"[Content_Types].xml\",\n                    \"docProps/app.xml\",\n                    \"docProps/core.xml\",\n                    \"xl/_rels/workbook.xml.rels\",\n                    \"xl/sharedStrings.xml\",\n                    \"xl/styles.xml\",\n                    \"xl/workbook.xml\"\n                ]);\n            })\n            .then(nodes => {\n                const contentTypesNode = nodes[0];\n                const appPropertiesNode = nodes[1];\n                const corePropertiesNode = nodes[2];\n                const relationshipsNode = nodes[3];\n                const sharedStringsNode = nodes[4];\n                const styleSheetNode = nodes[5];\n                const workbookNode = nodes[6];\n\n                // Load the various components.\n                this._contentTypes = new ContentTypes(contentTypesNode);\n                this._appProperties = new AppProperties(appPropertiesNode);\n                this._coreProperties = new CoreProperties(corePropertiesNode);\n                this._relationships = new Relationships(relationshipsNode);\n                this._sharedStrings = new SharedStrings(sharedStringsNode);\n                this._styleSheet = new StyleSheet(styleSheetNode);\n                this._node = workbookNode;\n\n                // Add the shared strings relationship if it doesn't exist.\n                if (!this._relationships.findByType(\"sharedStrings\")) {\n                    this._relationships.add(\"sharedStrings\", \"sharedStrings.xml\");\n                }\n\n                // Add the shared string content type if it doesn't exist.\n                if (!this._contentTypes.findByPartName(\"/xl/sharedStrings.xml\")) {\n                    this._contentTypes.add(\"/xl/sharedStrings.xml\", \"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\");\n                }\n\n                // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.\n                this._zip.remove(\"xl/calcChain.xml\");\n\n                // Load each sheet.\n                this._sheetsNode = xmlq.findChild(this._node, \"sheets\");\n                return externals.Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {\n                    if (sheetIdNode.attributes.sheetId > this._maxSheetId) this._maxSheetId = sheetIdNode.attributes.sheetId;\n\n                    return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`])\n                        .then(nodes => {\n                            const sheetNode = nodes[0];\n                            const sheetRelationshipsNode = nodes[1];\n\n                            // Insert at position i as the promises will resolve at different times.\n                            this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);\n                        });\n                }));\n            })\n            .then(() => this._parseSheetRefs())\n            .then(() => this);\n    }\n\n    /**\n     * Parse files out of zip into XML node objects.\n     * @param {Array.<string>} names - The file names to parse.\n     * @returns {Promise.<Array.<{}>>} An array of the parsed objects.\n     * @private\n     */\n    _parseNodesAsync(names) {\n        return externals.Promise.all(_.map(names, name => this._zip.file(name)))\n            .then(files => externals.Promise.all(_.map(files, file => file && file.async(\"string\"))))\n            .then(texts => externals.Promise.all(_.map(texts, text => text && xmlParser.parseAsync(text))));\n    }\n\n    /**\n     * Parse the sheet references out so we can reorder freely.\n     * @returns {undefined}\n     * @private\n     */\n    _parseSheetRefs() {\n        // Parse the active sheet.\n        const bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        const workbookViewNode = bookViewsNode && xmlq.findChild(bookViewsNode, \"workbookView\");\n        const activeTabId = workbookViewNode && workbookViewNode.attributes.activeTab || 0;\n        this._activeSheet = this._sheets[activeTabId];\n\n        // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet\n        // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.attributes.hasOwnProperty(\"localSheetId\")) {\n                    definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];\n                }\n            });\n        }\n    }\n\n    /**\n     * Set the proper sheet references in the XML.\n     * @returns {undefined}\n     * @private\n     */\n    _setSheetRefs() {\n        // Set the active sheet.\n        let bookViewsNode = xmlq.findChild(this._node, \"bookViews\");\n        if (!bookViewsNode) {\n            bookViewsNode = { name: 'bookViews', attributes: {}, children: [] };\n            xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);\n        }\n\n        let workbookViewNode = xmlq.findChild(bookViewsNode, \"workbookView\");\n        if (!workbookViewNode) {\n            workbookViewNode = { name: 'workbookView', attributes: {}, children: [] };\n            xmlq.appendChild(bookViewsNode, workbookViewNode);\n        }\n\n        workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);\n\n        // Set the defined names local sheet indexes.\n        const definedNamesNode = xmlq.findChild(this._node, \"definedNames\");\n        if (definedNamesNode) {\n            _.forEach(definedNamesNode.children, definedNameNode => {\n                if (definedNameNode.localSheet) {\n                    definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);\n                }\n            });\n        }\n    }\n\n    /**\n     * Convert buffer to desired output format\n     * @param {Buffer} buffer - The buffer\n     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer\n     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output\n     * @private\n     */\n    _convertBufferToOutput(buffer, type) {\n        if (!type) type = process.browser ? \"blob\" : \"nodebuffer\";\n\n        if (type === \"buffer\" || type === \"nodebuffer\") return buffer;\n        if (process.browser && type === \"blob\") return new Blob([buffer], { type: Workbook.MIME_TYPE });\n        if (type === \"base64\") return buffer.toString(\"base64\");\n        if (type === \"binarystring\") return buffer.toString(\"utf8\");\n        if (type === \"uint8array\") return new Uint8Array(buffer);\n        if (type === \"arraybuffer\") return new Uint8Array(buffer).buffer;\n\n        throw new Error(`Output type '${type}' not supported.`);\n    }\n\n    /**\n     * Convert input to buffer\n     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input\n     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary\n     * @returns {Promise.<Buffer>} The buffer.\n     * @private\n     */\n    _convertInputToBufferAsync(input, base64) {\n        return externals.Promise.resolve()\n            .then(() => {\n                if (Buffer.isBuffer(input)) return input;\n\n                if (process.browser && input instanceof Blob) {\n                    return new externals.Promise(resolve => {\n                        const fileReader = new FileReader();\n                        fileReader.onload = event => {\n                            resolve(Buffer.from(event.target.result));\n                        };\n                        fileReader.readAsArrayBuffer(input);\n                    });\n                }\n\n                if (typeof input === \"string\" && base64) return Buffer.from(input, \"base64\");\n                if (typeof input === \"string\" && !base64) return Buffer.from(input, \"utf8\");\n                if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);\n\n                throw new Error(`Input type unknown.`);\n            });\n    }\n}\n\n/**\n * The XLSX mime type.\n * @type {string}\n * @ignore\n */\nWorkbook.MIME_TYPE = \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n\nmodule.exports = Workbook;\n\n/*\nxl/workbook.xml\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x15\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t<fileVersion appName=\"xl\" lastEdited=\"7\" lowestEdited=\"7\" rupBuild=\"16925\"/>\n\t<workbookPr defaultThemeVersion=\"164011\"/>\n\t<mc:AlternateContent xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\">\n\t\t<mc:Choice Requires=\"x15\">\n\t\t\t<x15ac:absPath url=\"\\path\\to\\file\" xmlns:x15ac=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac\"/>\n\t\t</mc:Choice>\n\t</mc:AlternateContent>\n\t<bookViews>\n\t\t<workbookView xWindow=\"3720\" yWindow=\"0\" windowWidth=\"27870\" windowHeight=\"12795\"/>\n\t</bookViews>\n\t<sheets>\n\t\t<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>\n\t</sheets>\n\t<calcPr calcId=\"171027\"/>\n\t<extLst>\n\t\t<ext uri=\"{140A7094-0E35-4892-8432-C4D2E57EDEB5}\" xmlns:x15=\"http://schemas.microsoft.com/office/spreadsheetml/2010/11/main\">\n\t\t\t<x15:workbookPr chartTrackingRefBase=\"1\"/>\n\t\t</ext>\n\t</extLst>\n</workbook>\n// */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}