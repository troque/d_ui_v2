"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useAutoformState = exports.useAutofieldState = void 0;

var _react = _interopRequireWildcard(require("react"));

var _utils = require("./utils");

var _coercing = require("./coercing");

var _pubsub = require("./pubsub");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const useAutoformState = ({
  initialValues,
  onSubmit,
  onChange,
  schema,
  skin,
  formHook,
  skipManualReset
}) => {
  const stateRef = (0, _react.useRef)({
    stateControl: new _pubsub.PubSub(),
    fields: {}
  });
  const {
    stateControl
  } = stateRef.current;
  const coercersBase = {
    initialValues,
    stateRef,
    skin,
    onSubmit,
    schema
  };
  const coercedSubmit = (0, _coercing.createCoercers)(_objectSpread(_objectSpread({}, coercersBase), {}, {
    notify: onSubmit
  }));
  let coercedChange;

  if (onChange) {
    const coercedChangeDoc = onChange && (0, _coercing.createCoercers)(_objectSpread(_objectSpread({}, coercersBase), {}, {
      notify: onChange
    }));

    coercedChange = () => {
      const doc = formHook.getValues();
      return coercedChangeDoc(doc);
    };
  } else {
    coercedChange = null;
  }

  const schemaDef = schema.getSchema();

  const findOrInitState = name => {
    return (0, _utils.valueOrCreate)(stateRef.current.fields, name, () => {
      const nameForVisible = `${name}.initiallyVisible`;
      const initiallyVisible = (0, _utils.objectTraverse)(schemaDef, nameForVisible, {
        returnValue: true
      });
      return {
        visible: initiallyVisible === null ? true : initiallyVisible,
        helperText: null
      };
    });
  };

  const setValue = (name, value, options = {}) => {
    const fieldState = findOrInitState(name);

    const newState = _objectSpread(_objectSpread({}, fieldState), {}, {
      value,
      changed: true
    });

    if (!options.skipSetInput) formHook.setValue(name, value, options);
  };

  stateControl.findOrInitState = findOrInitState;
  stateControl.setValue = setValue;
  /**
   * Sets values in the stateRef. Doesn't trigger.
   */

  const setValues = (values, {
    parent = null,
    field
  }) => {
    const fields = Object.keys(values);
    fields.forEach(field => {
      const cur = values[field];

      if (typeof cur == 'object') {
        return setValues(cur, {
          parent: field,
          field
        });
      } else {
        const name = inputName({
          parent,
          field
        });
        findOrInitState(fieldName);
      }
    });
  };

  const resetState = (values, omit) => {
    stateRef.current.fields = {};
    setValues(values || {}, {});
    const currentValues = formHook.getValues();

    if (!skipManualReset) {
      // Reset by setting everything to initialValues or null.
      function resetValues(obj, initials = {}, path = '', isArray = false) {
        const fields = Object.keys(obj);
        fields.forEach((field, idx) => {
          const value = obj[field];
          const elPath = isArray ? `${path}.${idx}` : path ? `${path}.${field}` : field;
          const initial = initials[field];
          if (typeof value == 'object') resetValues(value, initial, elPath, Array.isArray(value));else {
            const initialOrNull = typeof initial == 'undefined' ? null : initial;
            formHook.setValue(elPath, initialOrNull);
          }
        });
      }

      resetValues(currentValues, initialValues);
    }

    formHook.reset(values, omit);
  };

  const changeAndPublish = (name, attr, value) => {
    const state = findOrInitState(name);
    stateControl.publish(name, _objectSpread(_objectSpread({}, state), {}, {
      [attr]: value
    }));
    state[attr] = value;
  };

  const setVisible = (name, visible) => {
    changeAndPublish(name, 'visible', visible);
  };

  const setHelperText = (name, text) => {
    changeAndPublish(name, 'helperText', text);
  };

  const getValues = () => {
    let values = {};
    const coercedGetValues = (0, _coercing.createCoercers)(_objectSpread(_objectSpread({}, coercersBase), {}, {
      notify: coerced => {
        (0, _utils.deepmerge)(values, coerced);
      }
    }));
    const doc = formHook.getValues();
    coercedGetValues(doc);
    return values;
  };

  return {
    coercedSubmit,
    coercedChange,
    setValue,
    setVisible,
    setHelperText,
    resetState,
    stateControl,
    getValues
  };
}; // Subscribes to visible, helperText and potential future additions


exports.useAutoformState = useAutoformState;

const useAutofieldState = ({
  name,
  stateControl
}) => {
  const initialState = stateControl.findOrInitState(name);
  const [state, setState] = (0, _react.useState)(_objectSpread({}, initialState));
  (0, _react.useEffect)(() => {
    stateControl.subscribe(name, setState);
    return () => {
      stateControl.unsubscribe(name, setState);
    };
  }, []);
  return state;
};

exports.useAutofieldState = useAutofieldState;