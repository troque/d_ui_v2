"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCoercers = createCoercers;

var _utils = require("./utils");

function createCoercers({
  initialValues,
  stateRef,
  skin,
  notify,
  schema
}) {
  return function coercedSubmit(doc) {
    const coerceObject = ({
      object,
      schemaDef
    }) => {
      const fields = Object.keys(schemaDef);
      const result = (0, _utils.deepmerge)({}, object);
      fields.forEach(fieldName => {
        const fieldSchema = schemaDef[fieldName];
        const {
          type
        } = fieldSchema;
        const typeKey = (0, _utils.schemaTypeEx)(type);
        const {
          coerce
        } = fieldSchema.coerce ? fieldSchema : skin[typeKey];
        const value = object[fieldName];

        if (coerce) {
          result[fieldName] = coerce(value, {
            coerceObject,
            schemaDef,
            fieldName
          });
        }
      });
      return result;
    };

    const coerceWithSchema = ({
      doc,
      schema
    }) => {
      const schemaDef = schema.getSchema();
      return coerceObject({
        object: doc,
        schemaDef
      });
    };

    const fields = Object.keys(stateRef.current.fields);
    const values = fields.reduce((values, field) => {
      const state = stateRef.current.fields[field];

      if (state.visible) {
        const [container, attr] = (0, _utils.objectTraverse)(values, field, {
          createIfMissing: true
        });
        const [docContainer] = (0, _utils.objectTraverse)(doc, field);

        if (container && attr) {
          if (state.changed) container[attr] = state.value;else if (docContainer) container[attr] = docContainer[attr];
        }
      }

      return values;
    }, {});
    const wholeObj = (0, _utils.deepmerge)({}, initialValues, values);
    const coerced = coerceWithSchema({
      doc: wholeObj,
      schema
    });
    notify(coerced, doc);
  };
}