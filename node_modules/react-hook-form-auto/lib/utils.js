"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createNumberedArray = createNumberedArray;
exports.deepmerge = deepmerge;
exports.getPropsTransform = getPropsTransform;
exports.getSkinComponent = getSkinComponent;
exports.inputName = inputName;
exports.isObject = isObject;
exports.objectTraverse = objectTraverse;
exports.pathToArray = pathToArray;
exports.processOptions = processOptions;
exports.schemaType = void 0;
exports.schemaTypeEx = schemaTypeEx;
exports.valueFromEvent = valueFromEvent;
exports.valueOrCreate = valueOrCreate;

var _translation_utils = require("./translation_utils");

const _excluded = ["fieldSchema", "schemaTypeName", "field", "options", "addDefault"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }

/**
 * Translates schema specification type. Types can
 * be specified with a string or a constructor like
 * String.
 *
 * @param {string|function} type Type specification.
 *
 * @returns {string} Type as string.
 */
const schemaType = type => {
  if (typeof type == 'function') return typeof type();else return type;
};
/**
 * Translates the schema's type specification. Type
 * can be specified as with schemaType and also can
 * be a subschema or an array of other schema.
 *
 * @param {any} type Can be:
 *    - String like 'number'
 *    - Constructor like Number
 *    - Schema instance
 *    - Array with schema instance in the first element.
 *        Example: [client]
 */


exports.schemaType = schemaType;

function schemaTypeEx(type) {
  if (typeof type == 'object' && type._type == 'schema') return 'schema';else {
    const isArray = Array.isArray(type);
    const first = type && type[0];
    const isSchema = isArray && type.length > 0 && first._type && first._type == 'schema';
    if (isSchema) return 'array';else return schemaType(type);
  }
} // Thanks Mariuzzo
// https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge

/**
 * Simple object check.
 * @param item
 * @returns {boolean}
 */


function isObject(item) {
  return typeof item == 'object' && !(item instanceof Date);
}
/**
 * Deep merge two objects.
 * @param target
 * @param ...sources
 */


function deepmerge(target, ...sources) {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        const sourceIsArray = Array.isArray(source[key]);

        if (!target[key]) {
          if (sourceIsArray) Object.assign(target, {
            [key]: []
          });else Object.assign(target, {
            [key]: {}
          });
        } // Arrays are overwritten


        if (sourceIsArray) target[key] = _toConsumableArray(source[key]);else deepmerge(target[key], source[key]);
      } else {
        Object.assign(target, {
          [key]: source[key]
        });
      }
    }
  }

  return deepmerge.apply(void 0, [target].concat(sources));
}

function createNumberedArray(length) {
  return Array.from({
    length
  }, (_, k) => k);
}
/**
 * Converts options from different formats to
 * [ { label, value } ]
 *
 * You can usually pass control props here. Options will
 * be acquired from fieldSchema.
 *
 * @param {string} schemaTypeName Model name
 * @param {string} field Field name
 * @param {function|array} options Array with options. If
 *  it's a function it will be called with props.
 *  Array (or resulting one after calling) will be processed
 *  to populate label and value.
 */


function processOptions(_ref) {
  let {
    fieldSchema,
    schemaTypeName,
    field,
    options,
    addDefault
  } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded);

  if (fieldSchema && !options) options = fieldSchema.options;
  const extracted = typeof options == 'function' ? options(_objectSpread({
    name,
    field,
    schemaTypeName
  }, rest)) : options;

  const getLabel = option => (0, _translation_utils.trModel)(schemaTypeName, field, option);

  const processed = extracted.map(option => {
    if (typeof option == 'string') {
      return {
        value: option,
        label: getLabel(option)
      };
    } else {
      if ('key' in option) {
        return _objectSpread(_objectSpread({}, option), {}, {
          label: option.label || getLabel(option.key)
        });
      } else return option;
    }
  });

  if (addDefault) {
    return [{
      label: (0, _translation_utils.trModel)(schemaTypeName, field, '_default'),
      value: ''
    }].concat(_toConsumableArray(processed));
  } else {
    return processed;
  }
}
/**
 * Transforms typical form path to array. Example:
 *
 * `pathToArray("pets[4].name") --> ['pets', '4', 'name']`
 * `pathToArray("pets.4.name") --> ['pets', '4', 'name']`
 */


function pathToArray(path) {
  const unsquared = path.replace(/[[.](.*?)[\].]/g, '.$1.');
  return unsquared.split('.');
}
/**
 * Traverses an object using an array of keys.
 *
 * @param {object} object Object to traverse
 * @param {string|array} path Path in the form `"pets.4.name"`,
 *  `"pets[4].name"` or `['pets', '4', 'name']`
 * @param {object} options Optional options:
 *  {
 *    createIfMissing: false, // Creates missing entities with objects,
 *    returnValue: false,     // Ultimate value if you are not interested
 *                            // in context
 *  }
 *
 * @returns {array} Array in the form `[ object, attribute ]`
 *  (or empty if subobject is not found).
 *
 *  This allows you to mutate original object like this:
 *
 *  const [ container, attribute ] = objectTraverse(obj, path)
 *  container[attribute] = newValue
 *
 * TODO When createIfMissing, use path brackets as a
 * hint to when to create arrays or objects
 */


function objectTraverse(object, pathOrArray, options = {}) {
  const {
    createIfMissing,
    returnValue
  } = options;
  const arrayed = Array.isArray(pathOrArray) ? pathOrArray : pathToArray(pathOrArray);
  const [next, ...rest] = arrayed;

  if (next in object) {
    if (rest.length == 0) {
      if (returnValue) return object[next];else return [object, next];
    } else {
      if (createIfMissing && typeof object[next] == 'undefined') object[next] = {};
      return objectTraverse(object[next], rest, options);
    }
  } else {
    if (createIfMissing) {
      object[next] = {}; // Repeat

      return objectTraverse(object, arrayed, options);
    } else {
      if (returnValue) return null;else return [];
    }
  }
}
/**
 * Returns input name in the form 'parent.index.field'
 *
 * @param {string} parent Optional parent
 * @param {number|string} index Optional index
 * @param {string} field Field
 *
 * @returns {string} Depends:
 *      - If you passed index, then '<parent>.<index>.<field>'
 *      - Else if you passed parent, then '<parent>.<field>'
 *      - Else field
 */


function inputName({
  parent,
  index,
  field
}) {
  if (typeof index == 'undefined') return parent ? `${parent}.${field}` : field;else return `${parent || ''}.${index}.${field}`;
}
/**
 * If attr is not found in object, we create it in the form
 * object[attr] = defaultObject
 *
 * @param {object} object Object
 * @param {string} attr Key
 * @param {function} create Function that returns a brand new
 *    object to assign if it didn't exist. Important: It must be
 *    a new object.
 *
 * @returns New or existing object[attr]
 *
 * @example
 *  const obj = { existing: { count: 42 } }
 *
 *  valueOrCreate(obj, 'existing', () => ({ count: 0 }))
 *    // -> { count: 42 }
 *  valueOrCreate(obj, 'invented', () => ({ count: 0 }))
 *    // -> { count: 0 }
 */


function valueOrCreate(object, attr, create) {
  if (!(attr in object)) object[attr] = create();
  return object[attr];
}
/**
 * @param {any} thing If thing is an event, value
 *  will be extracted. I consider event anything
 *  that has target with type
 * @returns {any} value
 */


function valueFromEvent(thing) {
  if ('target' in thing) {
    const {
      target,
      target: {
        type,
        value
      }
    } = thing;

    switch (type) {
      case 'checkbox':
        return target.checked;

      default:
        return value;
    }
  } else {
    return thing;
  }
}
/**
 * Gets props transform from skin element (formelly `render`)
 */


function getPropsTransform(skinElement) {
  return skinElement.props || skinElement.render;
}
/**
 * Gets component from skin element
 */


function getSkinComponent(skinElement) {
  return skinElement.component || skinElement.render;
}