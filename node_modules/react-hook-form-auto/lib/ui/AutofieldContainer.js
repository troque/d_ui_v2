"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AutofieldContainer = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactHookForm = require("react-hook-form");

var _Autofield = require("./Autofield");

var _utils = require("../utils");

var _autoform_state = require("../autoform_state");

var _jsxRuntime = require("react/jsx-runtime");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const AutofieldContainer = props => {
  const {
    id,
    name,
    fieldSchema,
    defaultValue,
    schemaTypeName,
    skinElement,
    formHook: {
      control
    },
    formHook,
    register,
    rules,
    overrides,
    skin,
    stateControl,
    setVisible,
    setHelperText,
    setValue,
    arrayControl
  } = props;
  const {
    visible,
    helperText
  } = (0, _autoform_state.useAutofieldState)({
    name,
    stateControl
  });
  let baseProps = Object.assign({}, props, {
    helperText
  });
  const {
    controlled
  } = skinElement;

  if (controlled) {
    const {
      field
    } = (0, _reactHookForm.useController)({
      name,
      control: control,
      rules
    });
    baseProps.onChange = field.onChange;
    baseProps.onBlur = field.onBlur;
    baseProps.value = field.value;
  } else {
    if (!skinElement.skipRegister) {
      const registerProps = register(name, rules);
      baseProps.onBlur = registerProps.onBlur;
      baseProps.onChange = registerProps.onChange;
      baseProps.inputRef = registerProps.ref;
    }
  } // Allow field schema or overrides onChange


  if ('onChange' in fieldSchema || 'onChange' in overrides) {
    const baseOnChange = baseProps.onChange;
    const overrideOnChange = overrides.onChange;
    if (overrideOnChange) delete overrides.onChange;
    const onChangeArguments = {
      name,
      setVisible,
      setHelperText,
      formHook,
      setValue,
      arrayControl
    };

    const fireOnChange = value => {
      if (fieldSchema.onChange) fieldSchema.onChange(value, onChangeArguments);
      if (overrideOnChange) overrideOnChange(value, onChangeArguments);
    };

    baseProps.onChange = event => {
      const value = (0, _utils.valueFromEvent)(event);
      baseOnChange(event);
      fireOnChange(value);
    };

    baseProps.setValue = (name, value) => {
      setValue(name, value);
      fireOnChange(value);
    };
  } // Allow general onChange, passed to <Autoform />


  if (props.onChange) {
    const oldOnChange = baseProps.onChange;

    baseProps.onChange = event => {
      oldOnChange(event);
      props.onChange();
    };
  }

  const propsTransform = (0, _utils.getPropsTransform)(skinElement);
  let transformedProps;
  if (typeof propsTransform == 'function') transformedProps = propsTransform ? propsTransform(baseProps) : baseProps;else transformedProps = _objectSpread(_objectSpread({}, baseProps), propsTransform);
  transformedProps = _objectSpread(_objectSpread({}, transformedProps), overrides);
  const component = transformedProps.component || skinElement.component;

  if (visible && component) {
    return /*#__PURE__*/(0, _jsxRuntime.jsx)(_Autofield.Autofield, _objectSpread(_objectSpread({}, transformedProps), {}, {
      component: component
    }));
  } else {
    return null;
  }
};

exports.AutofieldContainer = AutofieldContainer;