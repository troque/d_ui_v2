"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderInput = renderInput;
exports.renderInputs = renderInputs;
exports.validationRules = validationRules;

var _react = _interopRequireWildcard(require("react"));

var _utils = require("../utils");

var _translate = require("../translate");

var _translation_utils = require("../translation_utils");

var _FieldPropsOverride = require("./components/FieldPropsOverride");

var _AutofieldContainer = require("./AutofieldContainer");

const _excluded = ["field", "fieldSchema", "fieldSchema", "initialValue", "parent", "children", "propOverrides", "schemaTypeName", "config", "index", "skin", "styles"],
      _excluded2 = ["schema", "config", "children", "propOverrides", "initialValues", "styles"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const validations = {
  required: ({
    value,
    message
  }) => message,
  maxLength: 'maxLength',
  minLength: 'minLength',
  max: 'max',
  min: 'min',
  pattern: 'pattern',
  validate: 'validate'
};
/**
 * Creates validation rules after schema
 *
 * @param {object} fieldSchema
 */

function validationRules(fieldSchema) {
  const validationKeys = Object.keys(validations);
  return validationKeys.reduce((result, key) => {
    if (key in fieldSchema) {
      const validation = fieldSchema[key];
      let data;

      if (typeof validation == 'object') {
        if (validation.message && typeof validation.message == 'function') validation.message = validation.message(fieldSchema);
        data = validation;
      } else if (key == 'validate') {
        data = value => {
          const erroring = validation(value);
          return erroring === false || erroring;
        };
      } else {
        data = {
          value: fieldSchema[key],
          message: (0, _translation_utils.trError)(key, fieldSchema)
        };
      }

      result[key] = typeof validations[key] == 'function' ? validations[key](data) : data;
    }

    return result;
  }, {});
}
/**
 * Searches in children to find overrides.
 */


function searchForOverrides(parent, name, children = []) {
  const childrenArr = _react.Children.map(children, child => child);

  return childrenArr.reduce((override, child) => {
    const childName = child.props.name;
    const dottedChild = childName && childName.replace(/(\[|\]\.)/g, '.');
    const isOverride = child.type == _FieldPropsOverride.FieldPropsOverride;

    if (isOverride && dottedChild == name) {
      const cloned = Object.assign({}, child.props);
      delete cloned.name;
      return cloned;
    } else {
      return override;
    }
  }, {});
}
/**
 * Renders a single field.
 *
 * @param {object} params
 * @param {string} params.field Name of the field
 * @param {object} params.fieldSchema Schema specification
 *    for the field
 * @param {string} params.parent Prefix of the field name
 * @param {string} params.schemaTypeName Name of the schema
 *    (first argument while instantiating a schema)
 * @param {object} params.config Form configuration
 * @param {...object} params.rest props passed to the component
 */


function renderInput(_ref) {
  let {
    field,
    fieldSchema,
    fieldSchema: {
      type,
      required,
      defaultValue
    },
    initialValue,
    parent,
    children,
    propOverrides,
    schemaTypeName,
    config = {},
    index,
    skin,
    styles
  } = _ref,
      rest = _objectWithoutProperties(_ref, _excluded);

  const strType = (0, _utils.schemaTypeEx)(type);

  function describePlace() {
    return `Schema "${schemaTypeName}" has field "${field}"`;
  }

  if (!strType) {
    throw `${describePlace()} that lacks type description.`;
  }

  const skinElement = skin[strType];

  if (!skinElement) {
    throw `${describePlace()} with type "${strType}" ` + 'that doesn\'t exist in skin.';
  }

  const rules = validationRules(fieldSchema);
  const fullField = (0, _utils.inputName)({
    parent,
    index,
    field
  });
  const id = `${schemaTypeName}-${fullField}`;
  const overrides = searchForOverrides(parent, fullField, propOverrides);
  defaultValue = typeof initialValue == 'undefined' ? defaultValue : initialValue;
  return /*#__PURE__*/(0, _react.createElement)(_AutofieldContainer.AutofieldContainer, _objectSpread(_objectSpread({}, rest), {}, {
    id: id,
    key: fullField,
    name: fullField,
    field: field,
    fieldSchema: fieldSchema,
    schemaTypeName: schemaTypeName,
    config: config,
    parent: parent,
    propOverrides: propOverrides,
    rules: rules,
    styles: styles,
    skin: skin,
    skinElement: skinElement,
    defaultValue: defaultValue,
    overrides: overrides
  }));
}
/**
 * Renders the inputs to make the schema work.
 *
 * @param {object} params
 * @param {Schema} params.schema Schema instance
 * @param {object} params.config Rendering configuration
 * @param {string} params.config.arrayMode 'panels' or 'table'
 * @param {...object} params.rest Props passed to every input
 *
 * @returns {array} React elements with the form and inputs.
 */


function renderInputs(_ref2) {
  let {
    schema,
    config = {},
    children,
    propOverrides,
    initialValues = {},
    styles = {}
  } = _ref2,
      rest = _objectWithoutProperties(_ref2, _excluded2);

  const schemaDef = schema.getSchema();
  const schemaKeys = Object.keys(schemaDef);
  return schemaKeys.map(field => renderInput(_objectSpread(_objectSpread({}, rest), {}, {
    field,
    config,
    propOverrides: propOverrides || children,
    fieldSchema: schemaDef[field],
    schemaTypeName: schema.getType(),
    initialValue: initialValues[field],
    styles
  })));
}