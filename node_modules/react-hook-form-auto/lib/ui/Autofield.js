"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Autofield = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactHookForm = require("react-hook-form");

var _utils = require("../utils");

var _translate = require("../translate");

var _translation_utils = require("../translation_utils");

var _classnames = _interopRequireDefault(require("classnames"));

var _jsxRuntime = require("react/jsx-runtime");

const _excluded = ["id", "name", "wrapper", "component", "field", "formHook", "formHook", "defaultValue", "fieldSchema", "helperText", "inputRef", "forceErrors", "type", "option", "inline", "styles", "skinElement", "noRef", "noAutocomplete", "onChange", "onBlur"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

const Autofield = props => {
  const {
    id,
    name,
    wrapper = props.skin.defaultWrap,
    component,
    field,
    formHook: {
      control
    },
    formHook,
    defaultValue,
    fieldSchema,
    helperText,
    inputRef,
    forceErrors,
    type,
    option,
    inline,
    styles,
    skinElement,
    noRef,
    noAutocomplete,
    onChange,
    onBlur
  } = props,
        rest = _objectWithoutProperties(props, _excluded);

  const nameForErrors = skinElement.nameForErrors ? skinElement.nameForErrors(name) : name;
  const {
    errors
  } = (0, _reactHookForm.useFormState)({
    control,
    name: nameForErrors
  });
  const fieldErrors = forceErrors && forceErrors[nameForErrors] || (0, _utils.objectTraverse)(errors, nameForErrors, {
    returnValue: true
  });
  const errorText = fieldErrors && fieldErrors.message;
  const actualKey = option ? `${name}.${option}` : name;
  const $wrapper = wrapper;
  const $component = component;
  const isComponent = typeof component != 'string';

  let componentBaseProps = _objectSpread({
    id,
    key: actualKey,
    name,
    type,
    defaultValue,
    onChange,
    onBlur,
    className: (0, _classnames.default)(styles.input, styles.standard, {
      [styles.errored]: fieldErrors
    })
  }, fieldSchema.addInputProps);

  if (option) componentBaseProps.value = option;
  let finalHelperText = helperText || fieldSchema.helperText;

  if (!finalHelperText) {
    const helperId = (0, _translation_utils.trPath)(props.schemaTypeName, field, '_helper');
    if ((0, _translate.stringExists)(helperId)) finalHelperText = (0, _translate.tr)(helperId);
  }

  let componentProps;

  if (isComponent) {
    componentProps = _objectSpread(_objectSpread(_objectSpread({}, rest), componentBaseProps), {}, {
      field,
      forceErrors,
      errorText,
      fieldSchema,
      formHook,
      styles,
      skinElement,
      inputRef,
      helperText: finalHelperText
    });
  } else {
    componentProps = _objectSpread(_objectSpread({}, componentBaseProps), {}, {
      ref: inputRef
    });
  }

  if (noAutocomplete || fieldSchema.noAutocomplete) componentProps.autoComplete = 'off';
  return /*#__PURE__*/(0, _react.createElement)($wrapper, _objectSpread(_objectSpread({}, rest), {}, {
    id: id,
    key: actualKey,
    name: name,
    field: field,
    styles: styles,
    fieldSchema: fieldSchema,
    errorText: errorText,
    helperText: finalHelperText,
    inline: inline,
    addWrapperProps: fieldSchema.addWrapperProps
  }), /*#__PURE__*/(0, _jsxRuntime.jsx)($component, _objectSpread({}, componentProps)));
};

exports.Autofield = Autofield;