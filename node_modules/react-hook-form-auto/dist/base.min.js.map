{"version":3,"file":"base.min.js","mappings":";CAAA,SAA2CA,EAAMC,GAChD,GAAsB,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,SAAUA,QAAQ,yBAC/C,GAAqB,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,QAAS,mBAAoBJ,OACjC,CACJ,IAAIM,EAAuB,iBAAZL,QAAuBD,EAAQG,QAAQ,SAAUA,QAAQ,oBAAsBH,EAAQD,EAAY,MAAGA,EAAK,oBAC1H,IAAI,IAAIQ,KAAKD,GAAuB,iBAAZL,QAAuBA,QAAUF,GAAMQ,GAAKD,EAAEC,IAPxE,CASGC,MAAM,CAACC,EAAkCC,6BCT5C,OAOC,WACA,aAEA,IAAIC,EAAS,GAAGC,eAEhB,SAASC,IAGR,IAFA,IAAIC,EAAU,GAELP,EAAI,EAAGA,EAAIQ,UAAUC,OAAQT,IAAK,CAC1C,IAAIU,EAAMF,UAAUR,GACpB,GAAKU,EAAL,CAEA,IAAIC,SAAiBD,EAErB,GAAgB,WAAZC,GAAoC,WAAZA,EAC3BJ,EAAQK,KAAKF,QACP,GAAIG,MAAMC,QAAQJ,IACxB,GAAIA,EAAID,OAAQ,CACf,IAAIM,EAAQT,EAAWU,MAAM,KAAMN,GAC/BK,GACHR,EAAQK,KAAKG,SAGT,GAAgB,WAAZJ,EACV,GAAID,EAAIO,WAAaC,OAAOC,UAAUF,SACrC,IAAK,IAAIG,KAAOV,EACXN,EAAOiB,KAAKX,EAAKU,IAAQV,EAAIU,IAChCb,EAAQK,KAAKQ,QAIfb,EAAQK,KAAKF,EAAIO,aAKpB,OAAOV,EAAQe,KAAK,KAGgB3B,EAAOD,SAC3CY,EAAWiB,QAAUjB,EACrBX,EAAOD,QAAUY,QAGX,kBACL,OAAOA,GADF,QAAe,OAAf,aA5CP,yBCCD,IAAIkB,EAAwBN,OAAOM,sBAC/BnB,EAAiBa,OAAOC,UAAUd,eAClCoB,EAAmBP,OAAOC,UAAUO,qBAExC,SAASC,EAASC,GACjB,GAAIA,MAAAA,EACH,MAAM,IAAIC,UAAU,yDAGrB,OAAOX,OAAOU,GA+CfjC,EAAOD,QA5CP,WACC,IACC,IAAKwB,OAAOY,OACX,OAAO,EAMR,IAAIC,EAAQ,IAAIC,OAAO,OAEvB,GADAD,EAAM,GAAK,KACkC,MAAzCb,OAAOe,oBAAoBF,GAAO,GACrC,OAAO,EAKR,IADA,IAAIG,EAAQ,GACHlC,EAAI,EAAGA,EAAI,GAAIA,IACvBkC,EAAM,IAAMF,OAAOG,aAAanC,IAAMA,EAKvC,GAAwB,eAHXkB,OAAOe,oBAAoBC,GAAOE,KAAI,SAAUC,GAC5D,OAAOH,EAAMG,MAEHf,KAAK,IACf,OAAO,EAIR,IAAIgB,EAAQ,GAIZ,MAHA,uBAAuBC,MAAM,IAAIC,SAAQ,SAAUC,GAClDH,EAAMG,GAAUA,KAGf,yBADEvB,OAAOwB,KAAKxB,OAAOY,OAAO,GAAIQ,IAAQhB,KAAK,IAM9C,MAAOqB,GAER,OAAO,GAIQC,GAAoB1B,OAAOY,OAAS,SAAUe,EAAQC,GAKtE,IAJA,IAAIC,EAEAC,EADAC,EAAKtB,EAASkB,GAGTK,EAAI,EAAGA,EAAI1C,UAAUC,OAAQyC,IAAK,CAG1C,IAAK,IAAI9B,KAFT2B,EAAO7B,OAAOV,UAAU0C,IAGnB7C,EAAegB,KAAK0B,EAAM3B,KAC7B6B,EAAG7B,GAAO2B,EAAK3B,IAIjB,GAAII,EAAuB,CAC1BwB,EAAUxB,EAAsBuB,GAChC,IAAK,IAAI/C,EAAI,EAAGA,EAAIgD,EAAQvC,OAAQT,IAC/ByB,EAAiBJ,KAAK0B,EAAMC,EAAQhD,MACvCiD,EAAGD,EAAQhD,IAAM+C,EAAKC,EAAQhD,MAMlC,OAAOiD,8BChFKrD,EAAQ,KAAiB,IAAIuD,EAAEvD,EAAQ,KAASwD,EAAE,MAA6B,GAAG,mBAAoBC,QAAQA,OAAOC,IAAI,CAAC,IAAIC,EAAEF,OAAOC,IAAIF,EAAEG,EAAE,iBAAkCA,EAAE,kBAAkB,IAAIC,EAAEL,EAAEM,mDAAmDC,kBAAkBrB,EAAEnB,OAAOC,UAAUd,eAAesD,EAAE,CAACvC,KAAI,EAAGwC,KAAI,EAAGC,QAAO,EAAGC,UAAS,GACrW,SAASC,EAAEC,EAAEjE,EAAEkE,GAAG,IAAIC,EAAEC,EAAE,GAAGC,EAAE,KAAKC,EAAE,KAAiF,IAAIH,UAAhF,IAASD,IAAIG,EAAE,GAAGH,QAAG,IAASlE,EAAEqB,MAAMgD,EAAE,GAAGrE,EAAEqB,UAAK,IAASrB,EAAE6D,MAAMS,EAAEtE,EAAE6D,KAAc7D,EAAEsC,EAAEhB,KAAKtB,EAAEmE,KAAKP,EAAEtD,eAAe6D,KAAKC,EAAED,GAAGnE,EAAEmE,IAAI,GAAGF,GAAGA,EAAEM,aAAa,IAAIJ,KAAKnE,EAAEiE,EAAEM,kBAAe,IAASH,EAAED,KAAKC,EAAED,GAAGnE,EAAEmE,IAAI,MAAM,CAACK,SAASnB,EAAEoB,KAAKR,EAAE5C,IAAIgD,EAAER,IAAIS,EAAEI,MAAMN,EAAEO,OAAOlB,EAAEmB,SAASjF,EAAQkF,IAAIb,EAAErE,EAAQmF,KAAKd,8BCNrVpE,EAAOD,QAAU,EAAjBC,0BCHFA,EAAOD,QAAUQ,wBCAjBP,EAAOD,QAAUS,ICCb2E,EAA2B,GAG/B,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAavF,QAGrB,IAAIC,EAASmF,EAAyBE,GAAY,CAGjDtF,QAAS,IAOV,OAHAyF,EAAoBH,GAAUrF,EAAQA,EAAOD,QAASqF,GAG/CpF,EAAOD,QCpBfqF,EAAoB1C,EAAK1C,IACxB,IAAIyF,EAASzF,GAAUA,EAAO0F,WAC7B,IAAO1F,EAAiB,QACxB,IAAM,EAEP,OADAoF,EAAoBZ,EAAEiB,EAAQ,CAAErF,EAAGqF,IAC5BA,GCLRL,EAAoBZ,EAAI,CAACzE,EAAS4F,KACjC,IAAI,IAAIlE,KAAOkE,EACXP,EAAoBQ,EAAED,EAAYlE,KAAS2D,EAAoBQ,EAAE7F,EAAS0B,IAC5EF,OAAOsE,eAAe9F,EAAS0B,EAAK,CAAEqE,YAAY,EAAMC,IAAKJ,EAAWlE,MCJ3E2D,EAAoBQ,EAAI,CAACI,EAAKC,IAAU1E,OAAOC,UAAUd,eAAegB,KAAKsE,EAAKC,GCClFb,EAAoBc,EAAKnG,IACH,oBAAX2D,QAA0BA,OAAOyC,aAC1C5E,OAAOsE,eAAe9F,EAAS2D,OAAOyC,YAAa,CAAEC,MAAO,WAE7D7E,OAAOsE,eAAe9F,EAAS,aAAc,CAAEqG,OAAO,8cCLhD,MCSDC,EAAW,CAAEC,GDTD,CAChBC,IAAK,MACLC,OAAQ,SACTC,MAAO,CACNC,EAAG,QACH7B,KAAM,wCACN8B,IAAK,kCACLC,IAAK,kCACLC,UAAW,wDACXC,UAAW,wDACXC,SAAU,WACVC,YAAa,4CACbC,YAAa,kCCHQC,GCTL,CAChBX,IAAK,SACLC,OAAQ,SACRC,MAAO,CACLC,EAAG,QACH7B,KAAM,uCACN8B,IAAK,uCACLC,IAAK,uCACPC,UAAW,2DACXC,UAAW,2DACTC,SAAU,YACVC,YAAa,6BACbC,YAAa,sCDDjB,IAAIE,EAAgB,SAOb,SAASC,EAAkBC,GAC5BA,KAAQhB,GEgGZiB,EF/FcjB,EAASgB,IAMlB,SAASE,EAAwBC,EAAMC,GAC5CpB,EAASmB,GAAQE,EAAUrB,EAASmB,GAAOC,GAatC,SAASE,EAAQC,EAAWC,EAAOC,GACxC,OAAOC,EAAGC,EAAOJ,EAAWC,EAAOC,IAY9B,SAASG,EAAQL,EAAWC,GAMjC,MALwB,iBAAbD,IACTC,EAAQD,EAAUC,MAClBD,EAAYA,EAAUM,gBAGjBH,EAAGC,EAAOJ,EAAWC,EAAO,WAU9B,SAASM,EAAQ1B,EAAO2B,GAC7B,OAAOL,EAAI,SAAQtB,IAAS2B,GAYvB,SAASJ,EAAOK,EAAOR,EAAOC,GACnC,YAAiB,IAANA,EACF,CAACX,EAAekB,EAAOR,GAAOlG,KAAK,KAEnC,CAACwF,EAAekB,EAAOR,EAAOC,GAAInG,KAAK,KAW3C,SAAS2G,EAAcC,GAC5BpB,EAAgBoB,i/CGpEX,SAASC,EAAa3D,GAC3B,GAAmB,iBAARA,GAAkC,UAAdA,EAAK4D,MAClC,MAAO,SACJ,CACH,MAAMtH,EAAUD,MAAMC,QAAQ0D,GACxB6D,EAAQ7D,GAAQA,EAAK,GAM3B,OALiB1D,GACZ0D,EAAK/D,OAAS,GACd4H,EAAMD,OACS,UAAfC,EAAMD,MAGF,QA/Ba5D,CAAAA,GACL,mBAARA,SACKA,IAEPA,EA6BE8D,CAAW9D,IAYjB,SAAS+D,EAASC,GACvB,MAAsB,iBAARA,KAAsBA,aAAgBC,MAQ/C,SAASpB,EAAUxE,KAAW6F,GACnC,IAAKA,EAAQjI,OACX,OAAOoC,EACT,MAAMC,EAAS4F,EAAQC,QAEvB,GAAIJ,EAAS1F,IAAW0F,EAASzF,GAC/B,IAAK,MAAM1B,KAAO0B,EAChB,GAAIyF,EAASzF,EAAO1B,IAAO,CACzB,MAAMwH,EAAgB/H,MAAMC,QAAQgC,EAAO1B,IACtCyB,EAAOzB,KACNwH,EACF1H,OAAOY,OAAOe,EAAQ,CAAE,CAACzB,GAAM,KAE/BF,OAAOY,OAAOe,EAAQ,CAAE,CAACzB,GAAM,MAG/BwH,EACF/F,EAAOzB,GAAP,EAAmB0B,EAAO1B,IAE1BiG,EAAUxE,EAAOzB,GAAM0B,EAAO1B,SAEhCF,OAAOY,OAAOe,EAAQ,CAAE,CAACzB,GAAM0B,EAAO1B,KAK5C,OAAOiG,EAAS,WAAT,GAAUxE,GAAV,OAAqB6F,IAqBvB,SAASG,EAAT,GAOJ,IAP4B,YAC7BC,EAD6B,eAE7BjB,EAF6B,MAG7BL,EAH6B,QAI7BuB,EAJ6B,WAK7BC,GAEC,EADEC,oXACF,MACGH,IAAgBC,IAClBA,EAAUD,EAAYC,SAExB,MAAMG,EAA8B,mBAAXH,EACvBA,EAAQ,EAAD,CAAG/B,KAAMQ,MAAAA,EAAOK,eAAAA,GAAmBoB,IAAUF,EAEhDI,EAAWC,GAAU9B,EAAQO,EAAgBL,EAAO4B,GAEpDC,EAAYH,EAAU9G,KAAIgH,GACT,iBAAVA,EACF,CACLrD,MAAOqD,EACPE,MAAOH,EAASC,IAGd,QAASA,EACJ,EAAP,KACKA,GADL,IAEEE,MAAOF,EAAOE,OAASH,EAASC,EAAOhI,OAGlCgI,IAIb,OAAIJ,EACK,CAAC,CACNM,MAAOhC,EAAQO,EAAgBL,EAAO,YACtCzB,MAAO,KAFT,SAGMsD,IAECA,EAuCJ,SAASE,EAAeC,EAAQC,EAAaV,EAAU,IAC5D,MAAM,gBACJW,EADI,YAEJC,GACEZ,EAEEa,EAAU/I,MAAMC,QAAQ2I,GAC5BA,EAA0BA,EAnCLI,QAAQ,kBAAmB,QACjCtH,MAAM,MAmCfuH,KAASb,GAASW,EAE1B,OAAIE,KAAQN,EACS,GAAfP,EAAKxI,OACHkJ,EACKH,EAAOM,GAEP,CAAEN,EAAQM,IAEfJ,QAA0C,IAAhBF,EAAOM,KACnCN,EAAOM,GAAQ,IAEVP,EAAeC,EAAOM,GAAOb,EAAMF,IAGxCW,GACFF,EAAOM,GAAQ,GAGRP,EAAeC,EAAQI,EAASb,IAEnCY,EACK,KAEA,GAiBR,SAASI,GAAU,OAAEC,EAAF,MAAUC,EAAV,MAAiBzC,IACvC,YAAoB,IAATyC,EACFD,EAAU,GAAEA,KAAUxC,IAAUA,EAE/B,GAAEwC,GAAU,MAAMC,KAASzC,IAuBlC,SAAS0C,EAAcV,EAAQW,EAAMC,GAI1C,OAHMD,KAAQX,IACZA,EAAOW,GAAQC,KAEVZ,EAAOW,GAwCT,SAASE,EAAiBC,GAC/B,OAAOA,EAAYC,WAAaD,EAAYE,ODrT9C,IAAIC,EAAe,GAEfC,EAAW,aACXC,EAAW,aAEf,SAASC,EAAWC,EAAK,IACvB,MAAMC,EAAOD,EAAGtI,MAAM,KAEhBwI,EAAYD,EAAKrK,OAAS,EAChC,OAAOqK,EAAKE,QAAO,CAACC,EAAUC,EAAKjB,KACjC,MAAM,KAAEkB,EAAF,MAAQC,GAAUH,EAClBI,EAASpB,GAASc,EAGxB,MAFgC,iBAARI,EAGf,CACLC,MAAAA,EACAD,KAAAA,GAGEA,GAAQA,EAAKD,GACXG,GAAUF,EAAKD,GAAK7E,EACf,CACL+E,OAAO,EACPD,KAAMA,EAAKD,GAAK7E,GAGX,CACL+E,MAAOC,EACPF,KAAMA,EAAKD,IAIR,CACLE,MAAOD,GAAQ,MAAOA,EACtBA,KAAMA,GAAQA,EAAK9E,KAIxB,CAAE8E,KAAMV,IAGb,SAASa,EAAaC,EAAOC,EAAKC,GAChC,IAAIC,EACAC,EAASH,EAEb,MAAMI,EAAK,IAAIC,OAAON,GACtB,KAAkC,QAA1BG,EAAQE,EAAGE,KAAKN,KAAgB,CACtC,MAAMzF,EAAQ0F,EAASC,EAAM,SACT,IAAT3F,IACT4F,EAASA,EAAO9B,QAAQ6B,EAAM,GAAI3F,IAGtC,OAAO4F,EAoBF,SAASjE,EAAGmD,EAAIkB,EAAO,IAC5B,IAAI,KAAEZ,GAASP,EAAWC,GAC1B,OAAIM,GAEFA,EAAOG,EAAaZ,EAAUS,GAAMO,GAASK,EAAKL,KAGlDP,EAAOG,EAAaX,EAAUQ,GAAMO,GAAShE,EAAGgE,EAAOK,KAEhDZ,GAEAN,EAUJ,SAASmB,EAAanB,GAC3B,MAAM,MAAEO,GAAUR,EAAWC,GAC7B,OAAOO,EAyBF,SAASnE,EAAgBE,GAC9BsD,EAAepD,EAAUoD,EAActD,GASlC,SAAS8E,EAAcC,GAC5BxE,EAAKwE,EAMA,SAASC,EAA0BC,GACxC1B,EAAW0B,EAMN,SAASC,EAA2BC,GACzC3B,EAAW2B,EE5IN,SAASC,EAAaC,EAAUC,GACrC,MAAO,CACLrE,MAAO,SAOPsE,UAAW,IAAMD,EAOjBE,eAAiB3F,GAASyF,EAAOzF,GAOjC4F,QAAS,IAAMJ,EAKfK,cAAe,IAAM3L,OAAOwB,KAAK+J,0BC/B9B,MAAMK,EAAqB,IAAM,q8BCEjC,MAAMC,EAAatI,IACxB,MAAM,GACJoG,EADI,KAEJ7D,EAFI,QAGJgG,EAAUvI,EAAMwI,KAAKC,YAHjB,UAIJ3C,EAJI,MAKJ/C,EACA2F,UAAU,QAAEC,GANR,SAOJD,EAPI,aAQJE,EARI,YASJvE,EATI,WAUJwE,EAVI,SAWJC,EAXI,YAYJC,EAZI,KAaJhJ,EAbI,OAcJ4E,EAdI,OAeJqE,EAfI,OAgBJC,EAhBI,YAiBJpD,EAjBI,MAkBJqD,EAlBI,eAmBJC,EAnBI,SAoBJC,EApBI,OAqBJC,GAEErJ,EADCwE,oXAtBL,CAuBIxE,EAvBJ,GAyBMsJ,EAAgBzD,EAAYyD,cAChCzD,EAAYyD,cAAc/G,GAAQA,GAE9B,OAAEgH,IAAWC,EAAAA,EAAAA,cAAa,CAAEb,QAAAA,EAASpG,KAAM+G,IAC3CG,EAAcV,GAAeA,EAAYO,IAC1CxE,EAAeyE,EAAQD,EAAe,CAAEpE,aAAa,IACpDwE,EAAYD,GAAeA,EAAYE,QAEvCC,EAAYjF,EAAU,GAAEpC,KAAQoC,IAAWpC,EAC3CsH,EAAWtB,EACXuB,EAAahE,EACbiE,EAAkC,iBAAbjE,EAC3B,IAAIkE,EAAqB,GACvB5D,GAAAA,EACAzJ,IAAKiN,EACLrH,KAAAA,EACAxC,KAAAA,EACA6I,aAAAA,EACAQ,SAAAA,EACAC,OAAAA,EACAY,UAAWC,GAAAA,CAAWjB,EAAOkB,MAAOlB,EAAOmB,SAAU,CACnD,CAACnB,EAAOoB,SAAUZ,KAEjBpF,EAAYiG,eAGb3F,IACFqF,EAAmB1I,MAAQqD,GAE7B,IAOI4F,EAPAC,EAAkB3B,GAAcxE,EAAYwE,WAChD,IAAK2B,EAAiB,CACpB,MAAMC,EAAWvH,EAAOlD,EAAMoD,eAAgBL,EAAO,WACjDwE,EAAakD,KACfD,EAAkBvH,EAAGwH,IA4BzB,OAvBEF,EADER,EACe,SACZvF,GACAwF,GAFS,IAGZjH,MAAAA,EACAgG,YAAAA,EACAW,UAAAA,EACArF,YAAAA,EACAqE,SAAAA,EACAO,OAAAA,EACApD,YAAAA,EACAiD,SAAAA,EACAD,WAAY2B,IAGG,OACZR,GADS,IAEZ7K,IAAK2J,KAILK,GAAkB9E,EAAY8E,kBAChCoB,EAAeG,aAAe,QAG9B,mBAACb,EAAD,OACMrF,GADN,IAEE4B,GAAIA,EACJzJ,IAAKiN,EACLrH,KAAMA,EACNQ,MAAOA,EACPkG,OAAQA,EACR5E,YAAaA,EACbqF,UAAWA,EACXb,WAAY2B,EACZxB,OAAQA,EACR2B,gBAAiBtG,EAAYsG,mBAE7B,SAACb,EAAD,KACMS,MCvGL,SAASK,GAAe,cAC7BC,EAD6B,SAE7BC,EAF6B,KAG7BtC,EAH6B,OAI7BuC,EAJ6B,OAK7B/C,IAEA,OAAO,SAAuBgD,GAC5B,MAAMC,EAAe,EAAGlG,OAAAA,EAAQmG,UAAAA,MAC9B,MAAMC,EAAS1O,OAAOwB,KAAKiN,GACrBhE,EAAStE,EAAU,GAAImC,GAmB7B,OAjBAoG,EAAOpN,SAAQqN,IACb,MAAM/G,EAAc6G,EAAUE,IACxB,KAAErL,GAASsE,EACXgH,EAAU3H,EAAa3D,IACvB,OAAEuL,GAAWjH,EAAYiH,OAC7BjH,EAAcmE,EAAK6C,GACf/J,EAAQyD,EAAOqG,GAEjBE,IACFpE,EAAOkE,GAAaE,EAAOhK,EAAO,CAChC2J,aAAAA,EACAC,UAAAA,EACAE,UAAAA,QAKClE,GAaHqE,EADS9O,OAAOwB,KAAK6M,EAAS5K,QAAQiL,QACtB5E,QAAO,CAACgF,EAAQxI,KACpC,MAAMyI,EAAQV,EAAS5K,QAAQiL,OAAOpI,GAEtC,GAAIyI,EAAMC,QAAS,CACjB,MAAQC,EAAWhG,GAASZ,EAAeyG,EAAQxI,EAAO,CACxDkC,iBAAiB,KAEX0G,GAAiB7G,EAAekG,EAAKjI,GACzC2I,GAAahG,IACX8F,EAAMI,QACRF,EAAUhG,GAAQ8F,EAAMlK,MACjBqK,IACPD,EAAUhG,GAAQiG,EAAajG,KAIrC,OAAO6F,IACN,IAGGM,EA9BmB,GAAGb,IAAAA,EAAKhD,OAAAA,MAC/B,MAAMkD,EAAYlD,EAAOC,YAEzB,OAAOgD,EAAa,CAClBlG,OAAQiG,EACRE,UAAAA,KAyBYY,CAAiB,CAAEd,IADlBpI,EAAU,GAAIiI,EAAeU,GACIvD,OAAAA,IAElD+C,EAAOc,EAASb,ICpEb,MAAMe,EACXC,cACEC,KAAKC,SAAW,GAGlBC,UAAU5J,EAAMyE,GACd,MAAMkF,EAAWzG,EAAcwG,KAAKC,SAAU3J,GAAM,IAAM,MAEtC,GADA2J,EAASE,QAAQpF,IAEnCkF,EAAS/P,KAAK6K,GAGlBqF,YAAY9J,EAAMyE,GAChB,MAAMkF,EAAWD,KAAKC,SAAS3J,GAC/B,GAAI2J,EAAU,CACZ,MAAM1G,EAAQ0G,EAASE,QAAQpF,IACjB,GAAVxB,GACF0G,EAASI,OAAO9G,EAAO,IAI7B+G,QAAQhK,EAAMe,GACZ,MAAM4I,EAAWD,KAAKC,SAAS3J,GAC3B2J,GACFA,EAASnO,SAAQyO,IACfA,EAAQlJ,w3CCjBT,MAAMmJ,GAAsBzM,IACjC,MAAM,GACJoG,EADI,KAEJ7D,EAFI,YAGJ8B,EAHI,aAIJuE,EAJI,eAKJxF,EALI,YAMJyC,EACA6C,UAAU,QAAEC,GAPR,SAQJD,EARI,SASJgE,EATI,MAUJC,EAVI,UAWJC,EAXI,KAYJpE,EAZI,aAaJqE,EAbI,WAcJC,EAdI,cAeJC,EAfI,SAgBJC,EAhBI,aAiBJC,GACEjN,GAEE,QACJyL,EADI,WAEJ5C,GCmJ6B,GAAGtG,KAAAA,EAAMsK,aAAAA,MACxC,MAAMK,EAAeL,EAAaM,gBAAgB5K,IAC1CiJ,EAAO4B,IAAaC,EAAAA,EAAAA,UAAS,KAAKH,IAS1C,OAPAI,EAAAA,EAAAA,YAAU,KACRT,EAAaV,UAAU5J,EAAM6K,GACtB,KACLP,EAAaR,YAAY9J,EAAM6K,MAEhC,IAEI5B,GD7JH+B,CAAkB,CAAEhL,KAAAA,EAAMsK,aAAAA,IAE9B,IAAIW,EAAY/Q,OAAOY,OAAO,GAAI2C,EAAO,CAAE6I,WAAAA,IAE3C,MAAM,WAAE4E,GAAe5H,EAEvB,GAAI4H,EAAY,CACd,MAAM,MAAE1K,IAAU2K,EAAAA,EAAAA,eAAc,CAC9BnL,KAAAA,EACAoG,QAASA,EACTgE,MAAAA,IAGFa,EAAUpE,SAAWrG,EAAMqG,SAC3BoE,EAAUnE,OAAStG,EAAMsG,OACzBmE,EAAUlM,MAAQyB,EAAMzB,WAExB,IAAKuE,EAAY8H,aAAc,CAC7B,MAAMC,EAAgBlB,EAASnK,EAAMoK,GACrCa,EAAUnE,OAASuE,EAAcvE,OACjCmE,EAAUpE,SAAWwE,EAAcxE,SACnCoE,EAAU1E,SAAW8E,EAAczO,IAKvC,GAAI,aAAckF,GAAe,aAAcuI,EAAW,CACxD,MAAMiB,EAAeL,EAAUpE,SACzB0E,EAAmBlB,EAAUxD,SAC/B0E,UACKlB,EAAUxD,SAEnB,MAAM2E,EAAoB,CACxBxL,KAAAA,EACAuK,WAAAA,EACAC,cAAAA,EACArE,SAAAA,EACAsE,SAAAA,EACAC,aAAAA,GAGIe,EAAgB1M,IAChB+C,EAAY+E,UACd/E,EAAY+E,SAAS9H,EAAOyM,GAC1BD,GACFA,EAAiBxM,EAAOyM,IAG5BP,EAAUpE,SAAY6E,IACpB,MAAM3M,ENoML,SAAwB4M,GAC7B,GAAI,WAAYA,EAAO,CACrB,MAAM,OACJ9P,EACAA,QAAQ,KACN2B,EADM,MAENuB,IAEA4M,EAEJ,MACK,aADGnO,EAEC3B,EAAO+P,QAEP7M,EAGT,OAAO4M,EMrNSE,CAAeH,GAC7BJ,EAAaI,GACbD,EAAa1M,IAGfkM,EAAUR,SAAW,CAACzK,EAAMjB,KAC1B0L,EAASzK,EAAMjB,GACf0M,EAAa1M,IAKjB,GAAItB,EAAMoJ,SAAU,CAClB,MAAMiF,EAAcb,EAAUpE,SAC9BoE,EAAUpE,SAAY6E,IACpBI,EAAYJ,GACZjO,EAAMoJ,YAIV,MAAMkF,ENwMD,SAA2BzI,GAChC,OAAOA,EAAY7F,OAAS6F,EAAYE,OMzMjBwI,CAAkB1I,GAEzC,IAAI2I,EAEFA,EAD2B,mBAAlBF,EACUA,EAAiBA,EAAed,GAAaA,EAE7C,SAAKA,GAAcc,GACxCE,EAAmB,SAAKA,GAAqB5B,GAE7C,MAAM9G,EAAY0I,EAAiB1I,WAAaD,EAAYC,UAC5D,OAAI2F,GAAW3F,GAEX,SAACwC,EAAD,SACMkG,GADN,IAEE1I,UAAWA,KAIR,ixCE9GX,MAAM2I,GAAc,CAClBxM,SAAU,EAAGX,MAAAA,EAAOqI,QAAAA,KAAcA,EAClC3H,UAAW,YACXD,UAAW,YACXD,IAAK,MACLD,IAAK,MACL6M,QAAS,UACTC,SAAU,YAQL,SAASC,GAAgBvK,GAE9B,OADuB5H,OAAOwB,KAAKwQ,IACblI,QAAO,CAACW,EAAQvK,KACpC,GAAIA,KAAO0H,EAAa,CACtB,MAAMwK,EAAaxK,EAAY1H,GAC/B,IAAI2G,EACqB,iBAAduL,GACLA,EAAWlF,SAAwC,mBAAtBkF,EAAWlF,UAC1CkF,EAAWlF,QAAUkF,EAAWlF,QAAQtF,IAC1Cf,EAAOuL,GAEPvL,EADgB,YAAP3G,EACF2E,IACL,MAAMwN,EAAWD,EAAWvN,GAC5B,OAAoB,IAAbwN,GAAsBA,GAGxB,CACLxN,MAAO+C,EAAY1H,GACnBgN,QAAStG,EAAQ1G,EAAK0H,IAI1B6C,EAAOvK,GAAkC,mBAApB8R,GAAY9R,GAC/B8R,GAAY9R,GAAK2G,GAAQA,EAG7B,OAAO4D,IACN,IAqCE,SAAS6H,GAAT,GAkBJ,IAlByB,MAC1BhM,EAD0B,YAE1BsB,EACAA,aAAa,KACXtE,EADW,SAEXkC,EAFW,aAGX2G,GANwB,aAQ1BoG,EAR0B,OAS1BzJ,EAT0B,SAU1B0J,EAV0B,cAW1BC,EAX0B,eAY1B9L,EAZ0B,OAa1B+L,EAAS,GAbiB,MAc1B3J,EAd0B,KAe1BgD,EAf0B,OAgB1BS,GAEC,EADEzE,EACF,SACD,MAAM4K,EAAU1L,EAAa3D,GAE7B,SAASsP,IACP,MAAQ,WAAUjM,iBAA8BL,KAGlD,IAAKqM,EACH,KAAO,GAAEC,mCAGX,MAAMxJ,EAAc2C,EAAK4G,GAEzB,IAAKvJ,EACH,KAAO,GAAEwJ,kBAA8BD,iCAIzC,MAAMzC,EAAQiC,GAAgBvK,GACxBiL,EAAYhK,EAAU,CAAEC,OAAAA,EAAQC,MAAAA,EAAOzC,MAAAA,IACvCqD,EAAM,GAAEhD,KAAkBkM,IAE1B1C,EAvER,SAA4BrH,EAAQhD,EAAM0M,EAAW,IAGnD,OAFoBM,EAAAA,SAAAA,IAAaN,GAAUO,GAASA,IAEjCjJ,QAAO,CAACkJ,EAAUD,KACnC,MAAME,EAAYF,EAAMxP,MAAMuC,KACxBoN,EAAcD,GAAaA,EAAUtK,QAAQ,aAAc,KAEjE,GADmBoK,EAAMzP,MAAQsI,GACfsH,GAAepN,EAAM,CACrC,MAAMqN,EAASnT,OAAOY,OAAO,GAAImS,EAAMxP,OAGvC,cAFO4P,EAAOrN,KAEPqN,EAEP,OAAOH,IAER,IAwDeI,CAAmBtK,EAAQ+J,EAAWJ,GAKxD,OAHAtG,OAAsC,IAAhBoG,EACpBpG,EAAeoG,GAGf,mBAACvC,GAAD,SACMjI,GADN,IAEE4B,GAAIA,EACJzJ,IAAK2S,EACL/M,KAAM+M,EACNvM,MAAOA,EACPsB,YAAaA,EACbjB,eAAgBA,EAChB+L,OAAQA,EACR5J,OAAQA,EACR2J,cAAeA,EACfvC,MAAOA,EACP1D,OAAQA,EACRT,KAAMA,EACN3C,YAAaA,EACb+C,aAAcA,EACdgE,UAAWA,KAgBV,SAASkD,GAAT,GAQJ,IAR0B,OAC3B9H,EAD2B,OAE3BmH,EAAS,GAFkB,SAG3BF,EAH2B,cAI3BC,EAJ2B,cAK3BrE,EAAgB,GALW,OAM3B5B,EAAS,IAER,EADEzE,EACF,SACD,MAAM0G,EAAYlD,EAAOC,YAGzB,OAFmBxL,OAAOwB,KAAKiN,GAEbvN,KAAIoF,GACpBgM,GAAY,SACPvK,GADM,IAETzB,MAAAA,EACAoM,OAAAA,EACAD,cAAeA,GAAiBD,EAChC5K,YAAa6G,EAAUnI,GACvBK,eAAgB4E,EAAOG,UACvB6G,aAAcnE,EAAc9H,GAC5BkG,OAAAA,4vBC7LC,MAAM8G,GAAS,SAYTC,GAAe,CAAEC,KAAM,EAAGC,IAAK,EAAGjS,KAAM,IACxCkS,GAAU,CAAEF,KAAM,EAAGC,IAAK,EAAGjS,KAAM,CAAC,IAcpCmS,GAAU,CAAC5E,EAAQ2E,GAASE,KACvC,OAAQA,EAAOtQ,MACf,KAAKgQ,GACH,MAAM,KAAE9R,GAASuN,EAEjB,MAAO,CACLyE,KAAMzE,EAAMyE,KACZC,IAAK1E,EAAM0E,IAAM,EACjBjS,KAAM,GAAF,UACCA,EAAKqS,MAAM,EAAGD,EAAOE,MADtB,CAEF,MAFE,GAGCtS,EAAKqS,MAAMD,EAAOE,IAAM,MAGjC,IAxCiB,MAyCf,MAAO,CACLN,KAAMzE,EAAMyE,KAAO,EACnBC,IAAK1E,EAAM0E,IAAM,EACjBjS,KAAM,GAAF,UAAOuN,EAAMvN,MAAb,CAAmBuN,EAAMyE,QAEjC,QACE,OAAOzE,26BClCX,MAwCMgF,GAAoB,EACxBC,MAAAA,EACArN,eAAAA,EACAsN,WAAAA,EACAnO,KAAAA,EACA0G,OAAAA,EACA0H,OAAAA,EACAC,SAAAA,EACAC,IAAAA,EACAC,KAAAA,MAEA,MAAMC,EAnDgB,GAAGN,MAAAA,EAAOxH,OAAAA,EAAQ0H,OAAAA,EAAQC,SAAAA,MAO9C,SAACD,EAAD,CACEK,QAParR,IACfA,EAAEsR,iBACFR,KAMExH,OAAQA,EACRiI,OAAO,MAHT,UAKE,SAACN,EAAD,CAAU3H,OAAQA,MAuCJkI,CAAgB,CAChCV,MAAAA,EACAxH,OAAAA,EACA0H,OAAAA,EACAC,SAAAA,IAGF,OACE,UAACC,EAAD,CAAK5G,UAAWhB,EAAOmI,eAAvB,WACE,SAACN,EAAD,CAAM7G,UAAWhB,EAAOoI,iBAAxB,SACGxO,EAAQO,EAAgBb,EAAM,UAAY,MAE5CwO,MAUA,IAAIO,GAAiB,IAqBtB,IArBuB,KAC3B/O,EAD2B,UAE3BgP,EAF2B,aAG3BC,EAH2B,SAI3B9E,EAJ2B,WAK3B+E,EAL2B,UAM3B/H,EAAY,GANe,YAO3BrF,EACAA,aAAa,KAAEtE,GARY,eAS3BqD,EAT2B,SAU3BsF,EAV2B,aAW3BE,EAX2B,eAY3B8I,EAZ2B,SAa3BC,EAb2B,OAc3BxC,EAd2B,OAe3BlG,EAf2B,QAgB3B2I,EAhB2B,SAiB3B5E,EAjB2B,KAkB3BxE,EAlB2B,YAmB3B3C,GAEI,EADDrB,oXACC,OACJ,MAAQqN,EAAOC,IAAaC,EAAAA,EAAAA,YAC1BC,GD/F8B,EAACpJ,EAAc8I,IAC3C9I,GAAgBxM,MAAMC,QAAQuM,GACzB,CACLqH,KAAMrH,EAAa5M,OACnBkU,IAAKtH,EAAa5M,OAClBiC,KAAM2K,EAAajL,KAAI,CAACiE,EAAG2O,IAAQA,KAG9BmB,EAAiB1B,GAAeG,GCwFvC6B,CAA8BpJ,EAAc8I,IAGxC1J,EAASjI,EAAK,GACdkS,EAAgBT,EAEhBb,EAAS/K,EAAiB4C,EAAK0J,aAC/BtB,EAAWhL,EAAiB4C,EAAK2J,UACjCC,EAAcxM,EAAiB4C,EAAK6J,aACpCC,EAAQ1M,EAAiB4C,EAAK+J,OAC9B1B,EAAMjL,EAAiB4C,EAAKgK,KAC5B1B,EAAOlL,EAAiB4C,EAAKiK,MAE7B/B,EAAamB,EAAM5T,KAAKyU,QAAOnC,GAAe,OAARA,IACtCoC,EAAe9M,EAAYyD,cAAc/G,GAiBzCqQ,EAAwB1C,IAC5B,MAAMvG,EAhBiBuG,CAAAA,IACvB,GAAI,gBAAiB7L,EAAa,CAChC,MAAM,YAAEnC,GAAgBmC,EAExB,GAAI6L,EAAMhO,EACR,OAAOe,EAAG,oBAAqB,CAAEf,YAAAA,IAGrC,GAAI,gBAAiBmC,EAAa,CAChC,MAAM,YAAElC,GAAgBkC,EACxB,GAAI6L,EAAM/N,EACR,OAAOc,EAAG,oBAAqB,CAAEd,YAAAA,MAKrB0Q,CAAgB3C,GAC5BvG,EACFjB,EAASoK,SAASH,EAAc,CAC9B5S,KAAM,SACN4J,QAAAA,IAGFjB,EAASqK,YAAYJ,IAInBK,EAAY,KAChBlB,EDnJqB,CACvB/R,KARiB,QC2Jf6S,EAAqBf,EAAM3B,IAAM,IAG7B+C,EAAcvC,EAAW/S,KAAI4S,IACjC,MAAM2C,EAAgBC,IACpBrB,ED9JiBvB,CAAAA,IAAD,CACpBxQ,KAAMgQ,GACNQ,IAAAA,IC4JayB,CAAkBmB,IAC3BP,EAAqBf,EAAM3B,IAAM,GAGjClD,EADe,GAAEzK,KAAQ4Q,oBACT,GAEGnL,EAAOI,gBACfrK,SAAQqN,IACjB,MAAMgI,EAAe9N,EAAU,CAC7BC,OAAQhD,EACRiD,MAAO2N,EACPpQ,MAAOqI,IAETqG,EAAW2B,OAITC,EAnJgB,GACxB1B,SAAAA,EACApB,IAAAA,EACAtH,OAAAA,EACA0H,OAAAA,EACAyB,YAAAA,MAQE,SAACzB,EAAD,CACEK,QAPgBrR,IAClBA,EAAEsR,iBACFU,EAASpB,IAMPtH,OAAQA,EACRiI,OAAO,SAHT,UAKE,SAACkB,EAAD,CAAanJ,OAAQA,MAiIHqK,CAAkB,CACpC3B,SAAUuB,EACV3C,IAAAA,EACAtH,OAAAA,EACA0H,OAAAA,EACAyB,YAAAA,IAGF,IAAImB,EAMJ,OAJEA,EADE3K,GAAgBxM,MAAMC,QAAQuM,GAClBA,EAAa2H,GAEb3H,EAET,CACL2H,IAAAA,EACA8C,YAAAA,EACAG,OAAQ1D,GAAa,SAChBtL,GADe,IAElBwE,OAAQ4I,EACR5J,OAAAA,EACA5E,eAAAA,EACA4J,SAAAA,EACAzH,OAAQhD,EACRiD,MAAO+K,EACP1F,cAAe0I,EACf7K,SAAAA,EACAO,OAAAA,EACAyD,SAAAA,EACA+E,WAAAA,EACAgC,SAAUlD,EACVmD,mBAAoBH,EACpB/K,KAAAA,EACAyE,aAAc,CACZ4E,MAAAA,EACArM,MAAO+K,EACP7O,OAAQwR,EACRzR,IAAKuR,UAMPW,EAAa,CACjBlD,MAAOuC,EACP5P,eAAAA,EACA0O,SAAAA,EACAvP,KAAAA,EACA0G,OAAAA,EACA0H,OAAAA,EACAC,SAAAA,EACAC,IAAAA,EACAC,KAAAA,GAGI8C,EAAe1J,GAAAA,CAAW,CAC9B,CAACjB,EAAOoB,SAAUX,IAGpB,OACE,SAAC4I,EAAD,CACErI,UAAW2J,EACXC,OAAQrD,GAAkBmD,GAC1B1K,OAAQA,EAHV,UAKE,SAACgJ,EAAD,IACEjK,OAAQA,EACRmH,OAAQA,EACR5M,KAAMA,EACNmH,UAAWA,EACX5D,UAAW0L,EACXf,MAAOuC,EACPzB,UAAWA,EACXM,MAAOoB,EACPrK,aAAcA,EACdxF,eAAgBA,EAChB6F,OAAQA,EACRT,KAAMA,GACFhE,oxBC1PL,IAAIsP,GAAW,CAAC,EASpB3U,KAAQ,IATY,OACrBgQ,EAAS,GADY,KAErB5M,EAFqB,MAGrBQ,EACAsB,aAAa,KAAEtE,GAJM,aAKrB6I,EALqB,OAMrBK,EANqB,KAOrBT,GAES,EACT,MAAMuL,EAAa,2XADV,QACO,IAEd/L,OAAQjI,EACRoP,OAAAA,EACA5J,OAAQhD,EACRsI,cAAejC,EACfK,OAAAA,EACAT,KAAAA,IAEIpF,EAAiBrD,EAAKoI,UACtBmK,EAAQ1M,EAAiB4C,EAAK+J,OAEpC,OACE,SAACD,EAAD,CACErJ,OAAQA,EACR4K,OAAQhR,EAAQO,EAAgBL,GAFlC,SAIG+M,GAAaiE,MAKpBD,IAAWE,EAAAA,EAAAA,YAAWF,0uBCjCtB,SAASG,GAAe/I,EAAWE,GAAW,QAAE/O,IAC9C,MAAM0G,EAAQmI,EAAUE,IAClB,KAAErL,GAASgD,EAEjB,OADc1G,EAAU0D,EAAK,GAAKA,GACrBkI,YAKf,UACEiM,MAAO,CACLvG,cAAc,EACdrE,cAAe/G,GAAS,GAAEA,WAC1B+I,OAAQ,CAAC6I,EAAM,IAAMlJ,aAAAA,EAAcC,UAAAA,EAAWE,UAAAA,MAC5C,MAAMgJ,EAAcH,GAAe/I,EAAWE,EAAW,CACvD/O,SAAS,IAGX,OAAID,MAAMC,QAAQ8X,GACTA,EAAIxW,KAAI0W,GACTA,EAAK,eACA,KAEApJ,EAAa,CAAElG,OAAQsP,EAAOnJ,UAAWkJ,MACjD1B,QAAO2B,GAAmB,OAAVA,IAEZ,IAGXrU,MAAOA,IACL,MAAM,OACJmP,EAAS,GADL,YAEJ9K,EAFI,KAGJmE,GAEExI,EADCwE,oXAJL,CAKIxE,EALJ,KAOM,UAAEsU,GAAcnF,EAEhByC,EAA4B,UADXvN,EAAYiQ,WAAaA,GAE1CC,EAAa3O,EAAiB4C,EAAKgM,YACnCC,EAAa7O,EAAiB4C,EAAKkM,YACnClD,EAAeI,EAAU2C,EAAaE,EAE5C,OAAO,SACFjQ,GADL,IAEE2K,OAAAA,EACArJ,UAAWwL,GACXI,eAAgBrN,EAAYqN,eAC5BrN,YAAAA,EACAmN,aAAAA,EACAxI,QAAQ,EACRE,OAAO,EACP0I,QAAAA,EACApJ,KAAAA,MAINR,OAAQ,CACN2F,cAAc,EACdrC,OAAQ,CAACpK,EAAM,IAAM+J,aAAAA,EAAcC,UAAAA,EAAWE,UAAAA,KAGrCH,EAAa,CAAElG,OAAQ7D,EAAKgK,UAFf+I,GAAe/I,EAAWE,EAAW,CAAE/O,SAAS,MAItEyJ,UAAWgO,m2BCpDR,IAAIa,GAAe,CAAC3U,EAAOb,KAChC,MAAM,OACJ6I,EADI,aAEJ4M,EAFI,cAGJ/J,EAAgB,GAHZ,SAIJoE,EAJI,SAKJ4F,EALI,SAMJC,EANI,OAOJ7L,EAPI,aAQJ8L,EARI,iBASJC,EATI,KAUJxM,EAVI,aAWJyM,EAXI,gBAYJC,GAEElV,EADCwE,oXAbL,CAcIxE,EAdJ,IAgBA,IAAKgI,EACH,MAAM,IAAImN,MAAM,6CAGlB,MAAMzM,GAAW0M,EAAAA,EAAAA,SAAQ,CACvBC,KAAM,MACNC,cAAezK,KAEX,QACJlC,EADI,UAEJ4M,EAFI,SAGJ7I,EAHI,WAIJ+E,EAJI,aAKJ+D,EALI,MAMJC,GACE/M,EAEEgN,EAAY,YAAKC,IAAanN,GAASyM,IAEvC,cACJW,EADI,cAEJC,EAFI,SAGJ7I,EAHI,WAIJF,EAJI,cAKJC,EALI,WAMJ+I,EANI,aAOJjJ,EAPI,UAQJkJ,GNpD4B,GAC9BlL,cAAAA,EACAgK,SAAAA,EACAzL,SAAAA,EACApB,OAAAA,EACAQ,KAAAA,EACAE,SAAAA,EACAwM,gBAAAA,MAEA,MAAMpK,GAAWkL,EAAAA,EAAAA,QAAO,CACtBnJ,aAAc,IAAId,EAClBZ,OAAQ,MAGJ,aAAE0B,GAAiB/B,EAAS5K,QAE5B+V,EAAe,CACnBpL,cAAAA,EACAC,SAAAA,EACAtC,KAAAA,EACAqM,SAAAA,EACA7M,OAAAA,GAGI4N,EAAgBhL,EAAe,OAChCqL,GAD+B,IAElClL,OAAQ8J,KAGV,IAAIgB,EACJ,GAAIzM,EAAU,CACZ,MAAM8M,EAAmB9M,GAAYwB,EAAe,OAC/CqL,GAD8C,IAEjDlL,OAAQ3B,KAGVyM,EAAgB,KACd,MAAM7K,EAAMtC,EAASqN,YACrB,OAAOG,EAAiBlL,SAG1B6K,EAAgB,KAGlB,MAAM3K,EAAYlD,EAAOC,YACnBkF,EAAmB5K,GAChBkD,EAAcqF,EAAS5K,QAAQiL,OAAQ5I,GAAM,KAClD,MACM4T,EAAmBrR,EAAeoG,EADhB,GAAE3I,qBACyC,CACjE2C,aAAa,IAGf,MAAO,CACLuG,QAA8B,OAArB0K,GAAmCA,EAC5CtN,WAAY,SAKZmE,EAAW,CAACzK,EAAMjB,EAAOgD,EAAU,MAGtB,OAFE6I,EAAgB5K,IAErB,IAEZjB,MAAAA,EACAsK,SAAS,IAGNtH,EAAQ8R,cACX1N,EAASsE,SAASzK,EAAMjB,EAAOgD,IAGnCuI,EAAaM,gBAAkBA,EAC/BN,EAAaG,SAAWA,EAKxB,MAAMqJ,EAAY,CAAC9K,GAAUhG,OAAAA,EAAS,KAAMxC,MAAAA,MAC3BtG,OAAOwB,KAAKsN,GACpBxN,SAAQgF,IACb,MAAM0D,EAAM8E,EAAOxI,GACnB,GAAkB,iBAAP0D,EACT,OAAO4P,EAAU5P,EAAK,CAAElB,OAAQxC,EAAOA,MAAAA,IAE1BuC,UAAU,CAAEC,OAAAA,EAAQxC,MAAAA,IACjCoK,EAAgB/B,eAoChBkL,EAAmB,CAAC/T,EAAMmD,EAAMpE,KACpC,MAAMkK,EAAQ2B,EAAgB5K,GAE9BsK,EAAaN,QAAQhK,EAArB,OACKiJ,GADL,IAEE,CAAC9F,GAAOpE,KAGVkK,EAAM9F,GAAQpE,GA2BhB,MAAO,CACLsU,cAAAA,EACAC,cAAAA,EACA7I,SAAAA,EACAF,WA5BiB,CAACvK,EAAMkJ,KACxB6K,EAAiB/T,EAAM,UAAWkJ,IA4BlCsB,cAzBoB,CAACxK,EAAMkQ,KAC3B6D,EAAiB/T,EAAM,aAAckQ,IAyBrCqD,WAxEiB,CAACvK,EAAQgL,KAC1BzL,EAAS5K,QAAQiL,OAAS,GAE1BkL,EAAU9K,GAAU,GAAI,IAExB,MAAMiL,EAAgB9N,EAASqN,YAE/B,IAAKb,EAAiB,CAEpB,SAASuB,EAAYvV,EAAKwV,EAAW,GAAIC,EAAO,GAAIta,GAAU,GAC7CI,OAAOwB,KAAKiD,GACpBnD,SAAQ,CAACgF,EAAOwN,KACrB,MAAMjP,EAAQJ,EAAI6B,GACZ6T,EAASva,EACZ,GAAEsa,KAAQpG,IAASoG,EAAQ,GAAEA,KAAQ5T,IAAUA,EAC5CoN,EAAUuG,EAAS3T,GACzB,GAAoB,iBAATzB,EACTmV,EAAYnV,EAAO6O,EAASyG,EAAQxa,MAAMC,QAAQiF,QAC/C,CACH,MAAMuV,OAAkC,IAAX1G,EAAyB,KAAOA,EAC7DzH,EAASsE,SAAS4J,EAAQC,OAKhCJ,EAAYD,EAAe3L,GAG7BnC,EAAS+M,MAAMlK,EAAQgL,IA6CvB1J,aAAAA,EACAkJ,UAxBgB,KAChB,IAAIxK,EAAS,GAYb,OAVyBX,EAAe,OACnCqL,GADkC,IAErClL,OAASc,IACPjJ,EAAU2I,EAAQM,MAKtBiL,CADYpO,EAASqN,aAGdxK,KMrGLwL,CAAiB,CACnBlM,cAAAA,EACAgK,SAAAA,EACAzL,SAAUpJ,EAAMoJ,SAChBpB,OAAAA,EACAQ,KAAMkN,EACNhN,SAAAA,EACAwM,gBAAAA,IAGI8B,EAASxB,EAAaI,EAAed,IAE3CmC,EAAAA,EAAAA,qBAAoB9X,GAAK,KAAM,CAC7B6X,OAAAA,EACAtO,SAAU,IAAMA,EAChBsE,SAAAA,EACAF,WAAAA,EACAiJ,UAAAA,EACAN,MAAOK,MAGT,MAAMoB,EAAa,YACd1S,GACAoQ,GAFW,IAGda,MAAAA,EACAxG,SAAAA,EACApE,cAAAA,EACA7C,OAAAA,EACA0E,SAAAA,EACA+E,WAAAA,EACAxI,OAAAA,EACAT,KAAMkN,EACNhN,SAAAA,EACAyO,cAAenX,EACf6M,aAAAA,EACAG,SAAAA,EACAF,WAAAA,EACAC,cAAAA,EACA3D,SAAUyM,IAGNlF,EAAS/K,EAAiB8P,EAAU0B,QACpCC,EAAOzR,EAAiB8P,EAAU4B,MAExC,OACE,UAACD,EAAD,CAAMxC,SAAUmC,EAAhB,UACGlH,GAAaoH,GAEZnC,IACE,SAACpE,EAAD,CACE1H,OAAQA,EACR+H,QAASgG,EACTjX,KAAK,SAHP,SAKGiV,IAGN/F,MAKP0F,IAAeX,EAAAA,EAAAA,YAAWW","sources":["webpack://react-hook-form-auto/webpack/universalModuleDefinition","webpack://react-hook-form-auto/./node_modules/classnames/index.js","webpack://react-hook-form-auto/./node_modules/object-assign/index.js","webpack://react-hook-form-auto/./node_modules/react/cjs/react-jsx-runtime.production.min.js","webpack://react-hook-form-auto/./node_modules/react/jsx-runtime.js","webpack://react-hook-form-auto/external umd \"react\"","webpack://react-hook-form-auto/external umd \"react-hook-form\"","webpack://react-hook-form-auto/webpack/bootstrap","webpack://react-hook-form-auto/webpack/runtime/compat get default export","webpack://react-hook-form-auto/webpack/runtime/define property getters","webpack://react-hook-form-auto/webpack/runtime/hasOwnProperty shorthand","webpack://react-hook-form-auto/webpack/runtime/make namespace object","webpack://react-hook-form-auto/./src/translations/en.js","webpack://react-hook-form-auto/./src/translation_utils.js","webpack://react-hook-form-auto/./src/translations/es.js","webpack://react-hook-form-auto/./src/translate.js","webpack://react-hook-form-auto/./src/utils.js","webpack://react-hook-form-auto/./src/createSchema.js","webpack://react-hook-form-auto/./src/ui/components/FieldPropsOverride.jsx","webpack://react-hook-form-auto/./src/ui/Autofield.jsx","webpack://react-hook-form-auto/./src/coercing.js","webpack://react-hook-form-auto/./src/pubsub.js","webpack://react-hook-form-auto/./src/ui/AutofieldContainer.jsx","webpack://react-hook-form-auto/./src/autoform_state.js","webpack://react-hook-form-auto/./src/ui/componentRender.jsx","webpack://react-hook-form-auto/./src/ui/ducks/inputArray.js","webpack://react-hook-form-auto/./src/ui/components/InputArrayWrap.jsx","webpack://react-hook-form-auto/./src/ui/components/Submodel.jsx","webpack://react-hook-form-auto/./src/ui/baseSkin.js","webpack://react-hook-form-auto/./src/ui/AutoformBase.jsx"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"react-hook-form\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"react-hook-form\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"react\"), require(\"react-hook-form\")) : factory(root[\"react\"], root[\"react-hook-form\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, (__WEBPACK_EXTERNAL_MODULE__156__, __WEBPACK_EXTERNAL_MODULE__369__) => {\nreturn ","/*!\n  Copyright (c) 2018 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString === Object.prototype.toString) {\n\t\t\t\t\tfor (var key in arg) {\n\t\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","/** @license React v17.0.2\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';require(\"object-assign\");var f=require(\"react\"),g=60103;exports.Fragment=60107;if(\"function\"===typeof Symbol&&Symbol.for){var h=Symbol.for;g=h(\"react.element\");exports.Fragment=h(\"react.fragment\")}var m=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,n=Object.prototype.hasOwnProperty,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,k){var b,d={},e=null,l=null;void 0!==k&&(e=\"\"+k);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(l=a.ref);for(b in a)n.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:g,type:c,key:e,ref:l,props:d,_owner:m.current}}exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__156__;","module.exports = __WEBPACK_EXTERNAL_MODULE__369__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export const en = {\n  add: 'Add',\n  remove: 'Remove',\n\terror: {\n\t\t_: 'Error',\n\t\ttype: 'Incorrect value, expecting a __type__',\n\t\tmin: 'Value must be more than __min__',\n\t\tmax: 'Value must be less than __max__',\n\t\tminLength: 'Value must be more than __minLength__ characters long',\n\t\tmaxLength: 'Value must be less than __maxLength__ characters long',\n\t\trequired: 'Required',\n\t\tminChildren: 'Expected to have at least __minChildren__',\n\t\tmaxChildren: 'Can only have __maxChildren__',\n\t}\n}\n","import { en, es } from './translations'\nimport { deepmerge } from './utils.js'\nimport {\n  tr,\n  setLanguage\n} from './translate'\n\nexport { tr, setLanguage }\n\nconst defLangs = { en, es }\n\nlet modelBasePath = 'models'\n\n/**\n * Loads a language from the languages table.\n *\n * @param {string} name Language code as in `'en'` or `'fr'`.\n */\nexport function setLanguageByName(name) {\n  if (name in defLangs)\n    setLanguage(defLangs[name])\n}\n\n/**\n * Allows to add a bunch of strings to a language\n */\nexport function addLanguageTranslations(lang, strings) {\n  defLangs[lang] = deepmerge(defLangs[lang], strings)\n}\n\n/**\n * Multipurpose semantic-ish translation.\n *\n * @param {string} modelName Object name, usually what\n *    you pass as the first parameter when you create\n *    the schema.\n * @param {string} field Field name\n * @param {string} op Thing that varies based on\n *    the type.\n */\nexport function trModel(modelName, field, op) {\n  return tr(trPath(modelName, field, op))\n}\n\n/**\n * Translate field name\n *\n * @param {string|object} modelName Object name, usually what\n *    you pass as the first parameter when you create\n *    the schema. It can also be an object with component\n *    props so it will figure out the values\n * @param {string} field Field name\n */\nexport function trField(modelName, field) {\n  if (typeof modelName == 'object') {\n    field = modelName.field\n    modelName = modelName.schemaTypeName\n  }\n\n  return tr(trPath(modelName, field, '_field'))\n}\n\n/**\n * Translates error message.\n *\n * @param {string} error Code of the error (usually the\n *    validation code-name)\n * @param {object} data Field configuration from `createSchema()`.\n */\nexport function trError(error, data) {\n  return tr(`error.${error}`, data)\n}\n\n/**\n * Generates a model translation path.\n *\n * @param {string} model Name of the model (ie: 'client')\n * @param {string} field Name of the field\n * @param {string} op Name of the option or any subthing.\n *\n * @returns {string} id for the translation string\n */\nexport function trPath(model, field, op) {\n  if (typeof op == 'undefined')\n    return [modelBasePath, model, field].join('.')\n  else\n    return [modelBasePath, model, field, op].join('.')\n}\n\n/**\n * Sets the base for the semantich(ish) translation, so\n * instead of 'models.<model>.<field>' can be\n * 'my.base.<model>.<field>'\n *\n * @param {string} newBasePath New path prepended to all\n *    string paths.\n */\nexport function trPathSetBase(newBasePath) {\n  modelBasePath = newBasePath\n}\n","export const es = {\n  add: 'Añadir',\n  remove: 'Quitar',\n  error: {\n    _: 'Error',\n    type: 'Valor incorrecto, esperando __type__',\n    min: 'El valor debe ser superior a __min__',\n    max: 'El valor debe ser inferior a __max__',\n\t\tminLength: 'El valor debe tener como mínimo __minLength__ caracteres',\n\t\tmaxLength: 'El valor debe tener como máximo __maxLength__ caracteres',\n    required: 'Requerido',\n    minChildren: 'Se esperan __minChildren__',\n    maxChildren: 'Sólo puede haber __maxChildren__',\n  }\n}\n\n","import { deepmerge } from './utils.js'\n\nlet translations = {}\n\nlet varRegex = /__(.*?)__/g\nlet refRegex = /@@(.*?)@@/g\n\nfunction findString(id = '') {\n  const part = id.split('.')\n\n  const lastIndex = part.length - 1\n  return part.reduce((nodeInfo, cur, index) => {\n    const { node, found } = nodeInfo\n    const isLast = index == lastIndex\n    const isString = typeof node == 'string'\n\n    if (isString) {\n      return {\n        found,\n        node\n      }\n    } else {\n      if (node && node[cur]) {\n        if (isLast && node[cur]._) {\n          return {\n            found: true,\n            node: node[cur]._\n          }\n        } else {\n          return {\n            found: isLast,\n            node: node[cur]\n          }\n        }\n      } else {\n        return {\n          found: node && '_' in node,\n          node: node && node._\n        }\n      }\n    }\n  }, { node: translations })\n}\n\nfunction regexReplace(regex, str, callback) {\n  let match\n  let result = str\n\n  const re = new RegExp(regex)\n  while ((match = re.exec(str)) !== null) {\n    const value = callback(match[1])\n    if (typeof value != 'undefined')\n      result = result.replace(match[0], value)\n  }\n\n  return result\n}\n\n/**\n * Translates a string given its id.\n *\n * @param {string} id Identifier in the form\n * \t`key1.key2.key3`\n * @param {object} vars Object with substitution variables. It will\n * \tsubstitute ocurrences when string contains this expression:\n * \t`__variable__`. For example the string `\"My name is __name__\"` with\n * \t`vars = { name: 'David' }` will return `\"My name is David\"`.\n *\n * \tKeys will be searched by partitioning the path.\n *\n * \tIt will get the latest found key if any. For example, given the\n * \tstrings `{ \"a\": { \"b\": 'Hello' } }` and looking for `'a.b.c'` it will\n * \treturn `'a.b'` (`\"Hello\"`).\n * @returns Translated string\n */\nexport function tr(id, vars = {}) {\n  let { node } = findString(id)\n  if (node) {\n    // Find variables\n    node = regexReplace(varRegex, node, match => vars[match])\n\n    // Find references\n    node = regexReplace(refRegex, node, match => tr(match, vars))\n\n    return node\n  } else\n    return id\n}\n\n/**\n * Returns if the string does exist\n *\n * @param {string} id Identifier\n *\n * @returns { boolean } true if it exists\n */\nexport function stringExists(id) {\n  const { found } = findString(id)\n  return found\n}\n\n/**\n * Sets the language.\n *\n * At the moment this does the same as addTranslations. The\n * reason is not to lose translations reference until a better\n * way is figured out.\n *\n * @param {lang} Translations object with the format\n * \t{ key: { _: 'Some string', inner: 'Some other string' } }\n * \tThen, we have the following paths\n * \t- key -> 'Some string'\n * \t- key.inner -> 'Some other string'\n */\nexport function setLanguage(lang) {\n  addTranslations(lang)\n}\n\n/**\n * Appends translations to current translation table\n *\n * @param {object} lang Translations merged into current.\n */\nexport function addTranslations(lang) {\n  translations = deepmerge(translations, lang)\n}\n\n/**\n * Sets the translation engine that responds to tr().\n *\n * @param {function} translate Function with signature\n * \ttranslate(id, params).\n */\nexport function setTranslator(translate) {\n  tr = translate\n}\n\n/**\n * Sets the regex for the variables\n */\nexport function setTranslateVariableRegex(newVarRegex) {\n  varRegex = newVarRegex\n}\n\n/**\n * Sets the regex for the substitutions\n */\nexport function setTranslateReferenceRegex(newRefRegex) {\n  refRegex = newRefRegex\n}\n","import { trModel } from './translation_utils'\n\n/**\n * Translates schema specification type. Types can\n * be specified with a string or a constructor like\n * String.\n *\n * @param {string|function} type Type specification.\n *\n * @returns {string} Type as string.\n */\nexport const schemaType = type => {\n  if (typeof type == 'function')\n    return typeof type()\n  else\n    return type\n}\n\n/**\n * Translates the schema's type specification. Type\n * can be specified as with schemaType and also can\n * be a subschema or an array of other schema.\n *\n * @param {any} type Can be:\n *    - String like 'number'\n *    - Constructor like Number\n *    - Schema instance\n *    - Array with schema instance in the first element.\n *        Example: [client]\n */\nexport function schemaTypeEx(type) {\n  if (typeof type == 'object' && type._type == 'schema')\n    return 'schema'\n  else {\n    const isArray = Array.isArray(type)\n    const first = type && type[0]\n    const isSchema = isArray\n      && type.length > 0\n      && first._type\n      && first._type == 'schema'\n\n    if (isSchema)\n      return 'array'\n    else\n      return schemaType(type)\n  }\n}\n\n// Thanks Mariuzzo\n// https://stackoverflow.com/questions/27936772/how-to-deep-merge-instead-of-shallow-merge\n\n/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nexport function isObject(item) {\n  return typeof item == 'object' && !(item instanceof Date)\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\nexport function deepmerge(target, ...sources) {\n  if (!sources.length)\n    return target\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        const sourceIsArray = Array.isArray(source[key])\n        if (!target[key]) {\n          if (sourceIsArray)\n            Object.assign(target, { [key]: [] })\n          else\n            Object.assign(target, { [key]: {} })\n        }\n        // Arrays are overwritten\n        if (sourceIsArray)\n          target[key] = [ ...source[key] ]\n        else\n          deepmerge(target[key], source[key])\n      } else {\n        Object.assign(target, { [key]: source[key] })\n      }\n    }\n  }\n\n  return deepmerge(target, ...sources)\n}\n\nexport function createNumberedArray(length) {\n  return Array.from({ length }, (_, k) => k)\n}\n\n/**\n * Converts options from different formats to\n * [ { label, value } ]\n *\n * You can usually pass control props here. Options will\n * be acquired from fieldSchema.\n *\n * @param {string} schemaTypeName Model name\n * @param {string} field Field name\n * @param {function|array} options Array with options. If\n *  it's a function it will be called with props.\n *  Array (or resulting one after calling) will be processed\n *  to populate label and value.\n */\nexport function processOptions({\n  fieldSchema,\n  schemaTypeName,\n  field,\n  options,\n  addDefault,\n  ...rest\n}) {\n  if (fieldSchema && !options)\n    options = fieldSchema.options\n\n  const extracted = typeof options == 'function' ?\n    options({ name, field, schemaTypeName, ...rest }) : options\n\n  const getLabel = option => trModel(schemaTypeName, field, option)\n\n  const processed = extracted.map(option => {\n    if (typeof option == 'string') {\n      return {\n        value: option,\n        label: getLabel(option)\n      }\n    } else {\n      if ('key' in option) {\n        return {\n          ...option,\n          label: option.label || getLabel(option.key)\n        }\n      } else\n        return option\n    }\n  })\n\n  if (addDefault) {\n    return [{\n      label: trModel(schemaTypeName, field, '_default'),\n      value: ''\n    }, ...processed]\n  } else {\n    return processed\n  }\n}\n\n/**\n * Transforms typical form path to array. Example:\n *\n * `pathToArray(\"pets[4].name\") --> ['pets', '4', 'name']`\n * `pathToArray(\"pets.4.name\") --> ['pets', '4', 'name']`\n */\nexport function pathToArray(path) {\n  const unsquared = path.replace(/[[.](.*?)[\\].]/g, '.$1.')\n  return unsquared.split('.')\n}\n\n/**\n * Traverses an object using an array of keys.\n *\n * @param {object} object Object to traverse\n * @param {string|array} path Path in the form `\"pets.4.name\"`,\n *  `\"pets[4].name\"` or `['pets', '4', 'name']`\n * @param {object} options Optional options:\n *  {\n *    createIfMissing: false, // Creates missing entities with objects,\n *    returnValue: false,     // Ultimate value if you are not interested\n *                            // in context\n *  }\n *\n * @returns {array} Array in the form `[ object, attribute ]`\n *  (or empty if subobject is not found).\n *\n *  This allows you to mutate original object like this:\n *\n *  const [ container, attribute ] = objectTraverse(obj, path)\n *  container[attribute] = newValue\n *\n * TODO When createIfMissing, use path brackets as a\n * hint to when to create arrays or objects\n */\nexport function objectTraverse(object, pathOrArray, options = {}) {\n  const {\n    createIfMissing,\n    returnValue\n  } = options\n\n  const arrayed = Array.isArray(pathOrArray) ?\n    pathOrArray : pathToArray(pathOrArray)\n  const [ next, ...rest ] = arrayed\n\n  if (next in object) {\n    if (rest.length == 0) {\n      if (returnValue)\n        return object[next]\n      else\n        return [ object, next ]\n    } else {\n      if (createIfMissing && typeof object[next] == 'undefined')\n        object[next] = {}\n\n      return objectTraverse(object[next], rest, options)\n    }\n  } else {\n    if (createIfMissing) {\n      object[next] = {}\n\n      // Repeat\n      return objectTraverse(object, arrayed, options)\n    } else {\n      if (returnValue)\n        return null\n      else\n        return []\n    }\n  }\n}\n\n/**\n * Returns input name in the form 'parent.index.field'\n *\n * @param {string} parent Optional parent\n * @param {number|string} index Optional index\n * @param {string} field Field\n *\n * @returns {string} Depends:\n *      - If you passed index, then '<parent>.<index>.<field>'\n *      - Else if you passed parent, then '<parent>.<field>'\n *      - Else field\n */\nexport function inputName({ parent, index, field }) {\n    if (typeof index == 'undefined')\n      return parent ? `${parent}.${field}` : field\n    else\n      return `${parent || ''}.${index}.${field}`\n}\n\n/**\n * If attr is not found in object, we create it in the form\n * object[attr] = defaultObject\n *\n * @param {object} object Object\n * @param {string} attr Key\n * @param {function} create Function that returns a brand new\n *    object to assign if it didn't exist. Important: It must be\n *    a new object.\n *\n * @returns New or existing object[attr]\n *\n * @example\n *  const obj = { existing: { count: 42 } }\n *\n *  valueOrCreate(obj, 'existing', () => ({ count: 0 }))\n *    // -> { count: 42 }\n *  valueOrCreate(obj, 'invented', () => ({ count: 0 }))\n *    // -> { count: 0 }\n */\nexport function valueOrCreate(object, attr, create) {\n  if (!(attr in object))\n    object[attr] = create()\n\n  return object[attr]\n}\n\n/**\n * @param {any} thing If thing is an event, value\n *  will be extracted. I consider event anything\n *  that has target with type\n * @returns {any} value\n */\nexport function valueFromEvent(thing) {\n  if ('target' in thing) {\n    const {\n      target,\n      target: {\n        type,\n        value\n      }\n    } = thing\n\n    switch (type) {\n    case 'checkbox':\n      return target.checked\n    default:\n      return value\n    }\n  } else {\n    return thing\n  }\n}\n\n/**\n * Gets props transform from skin element (formelly `render`)\n */\nexport function getPropsTransform(skinElement) {\n  return skinElement.props || skinElement.render\n}\n\n/**\n * Gets component from skin element\n */\nexport function getSkinComponent(skinElement) {\n  return skinElement.component || skinElement.render\n}\n","/**\n * Creates a Schema from the specification.\n *\n * @function\n * @param {string} typeName Name of the model being created.\n *    It can be chosen freely.\n * @param {object} schema Schema specification.\n */\nexport function createSchema(typeName, schema) {\n  return {\n    _type: 'schema',\n\n    /**\n     * Returns the schema specification.\n     *\n     * @returns {object} Schema specification.\n     */\n    getSchema: () => schema,\n\n    /**\n     * Returns the schema specification.\n     *\n     * @returns {object} Schema specification.\n     */\n    getFieldSchema: (name) => schema[name],\n\n    /**\n     * Returns the schema name.\n     *\n     * @returns {string} Schema name (also called ``typeName``).\n     */\n    getType: () => typeName,\n\n    /**\n     * Returns the name of the fields.\n     */\n    getFieldNames: () => Object.keys(schema)\n  }\n}\n","import React from 'react'\n\n/**\n * Allows to specify extra props for a field in runtime.\n */\nexport const FieldPropsOverride = () => null\n","import React from 'react'\nimport { useFormState } from 'react-hook-form'\nimport { objectTraverse } from '../utils'\nimport { tr, stringExists } from '../translate'\nimport { trPath } from '../translation_utils'\nimport classnames from 'classnames'\n\nexport const Autofield = (props) => {\n  const {\n    id,\n    name,\n    wrapper = props.skin.defaultWrap,\n    component,\n    field,\n    formHook: { control },\n    formHook,\n    defaultValue,\n    fieldSchema,\n    helperText,\n    inputRef,\n    forceErrors,\n    type,\n    option,\n    inline,\n    styles,\n    skinElement,\n    noRef,\n    noAutocomplete,\n    onChange,\n    onBlur,\n    ...rest\n  } = props\n\n  const nameForErrors = skinElement.nameForErrors ?\n    skinElement.nameForErrors(name) : name\n\n  const { errors } = useFormState({ control, name: nameForErrors })\n  const fieldErrors = forceErrors && forceErrors[nameForErrors]\n    || objectTraverse(errors, nameForErrors, { returnValue: true })\n  const errorText = fieldErrors && fieldErrors.message\n\n  const actualKey = option ? `${name}.${option}` : name\n  const $wrapper = wrapper\n  const $component = component\n  const isComponent = typeof component != 'string'\n  let componentBaseProps = {\n    id,\n    key: actualKey,\n    name,\n    type,\n    defaultValue,\n    onChange,\n    onBlur,\n    className: classnames(styles.input, styles.standard, {\n      [styles.errored]: fieldErrors\n    }),\n    ...fieldSchema.addInputProps\n  }\n\n  if (option)\n    componentBaseProps.value = option\n  \n  let finalHelperText = helperText || fieldSchema.helperText\n  if (!finalHelperText) {\n    const helperId = trPath(props.schemaTypeName, field, '_helper')\n    if (stringExists(helperId))\n      finalHelperText = tr(helperId)\n  }\n\n  let componentProps\n  if (isComponent) {\n    componentProps = {\n      ...rest,\n      ...componentBaseProps,\n      field,\n      forceErrors,\n      errorText,\n      fieldSchema,\n      formHook,\n      styles,\n      skinElement,\n      inputRef,\n      helperText: finalHelperText\n    }\n  } else {\n    componentProps = {\n      ...componentBaseProps,\n      ref: inputRef\n    }\n  }\n\n  if (noAutocomplete || fieldSchema.noAutocomplete)\n    componentProps.autoComplete = 'off'\n\n  return (\n    <$wrapper\n      {...rest}\n      id={id}\n      key={actualKey}\n      name={name}\n      field={field}\n      styles={styles}\n      fieldSchema={fieldSchema}\n      errorText={errorText}\n      helperText={finalHelperText}\n      inline={inline}\n      addWrapperProps={fieldSchema.addWrapperProps}\n    >\n      <$component\n        {...componentProps}\n      />\n    </$wrapper>\n  )\n}\n","import {\n  deepmerge,\n  schemaTypeEx,\n  objectTraverse\n} from './utils'\n\nexport function createCoercers({\n  initialValues,\n  stateRef,\n  skin,\n  notify,\n  schema\n}) {\n  return function coercedSubmit(doc) {\n    const coerceObject = ({ object, schemaDef }) => {\n      const fields = Object.keys(schemaDef)\n      const result = deepmerge({}, object)\n\n      fields.forEach(fieldName => {\n        const fieldSchema = schemaDef[fieldName]\n        const { type } = fieldSchema\n        const typeKey = schemaTypeEx(type)\n        const { coerce } = fieldSchema.coerce ?\n          fieldSchema : skin[typeKey]\n        const value = object[fieldName]\n\n        if (coerce) {\n          result[fieldName] = coerce(value, {\n            coerceObject,\n            schemaDef,\n            fieldName\n          })\n        }\n      })\n\n      return result\n    }\n\n    const coerceWithSchema = ({ doc, schema }) => {\n      const schemaDef = schema.getSchema()\n\n      return coerceObject({\n        object: doc,\n        schemaDef\n      })\n    }\n\n    const fields = Object.keys(stateRef.current.fields)\n    const values = fields.reduce((values, field) => {\n      const state = stateRef.current.fields[field]\n\n      if (state.visible) {\n        const [ container, attr ] = objectTraverse(values, field, {\n          createIfMissing: true\n        })\n        const [ docContainer ] = objectTraverse(doc, field)\n        if (container && attr) {\n          if (state.changed)\n            container[attr] = state.value\n          else if (docContainer)\n            container[attr] = docContainer[attr]\n        }\n      }\n\n      return values\n    }, {})\n\n    const wholeObj = deepmerge({}, initialValues, values)\n    const coerced = coerceWithSchema({ doc: wholeObj, schema })\n\n    notify(coerced, doc)\n  }\n}\n","import { valueOrCreate } from './utils'\n\nexport class PubSub {\n  constructor() {\n    this.handlers = {}\n  }\n\n  subscribe(name, callback) {\n    const handlers = valueOrCreate(this.handlers, name, () => [])\n    const formerIndex = handlers.indexOf(callback)\n    if (formerIndex == -1)\n      handlers.push(callback)\n  }\n\n  unsubscribe(name, callback) {\n    const handlers = this.handlers[name]\n    if (handlers) {\n      const index = handlers.indexOf(callback)\n      if (index != -1)\n        handlers.splice(index, 1)\n    }\n  }\n\n  publish(name, data) {\n    const handlers = this.handlers[name]\n    if (handlers) {\n      handlers.forEach(handler => {\n        handler(data)\n      })\n    }\n  }\n}\n","import React from 'react'\nimport { useController } from 'react-hook-form'\nimport { Autofield } from './Autofield'\nimport {\n  objectTraverse,\n  valueFromEvent,\n  getPropsTransform\n} from '../utils'\nimport { useAutofieldState } from '../autoform_state'\n\nexport const AutofieldContainer = (props) => {\n  const {\n    id,\n    name,\n    fieldSchema,\n    defaultValue,\n    schemaTypeName,\n    skinElement,\n    formHook: { control },\n    formHook,\n    register,\n    rules,\n    overrides,\n    skin,\n    stateControl,\n    setVisible,\n    setHelperText,\n    setValue,\n    arrayControl\n  } = props\n\n  const {\n    visible,\n    helperText\n  } = useAutofieldState({ name, stateControl })\n\n  let baseProps = Object.assign({}, props, { helperText })\n\n  const { controlled } = skinElement\n\n  if (controlled) {\n    const { field } = useController({\n      name, \n      control: control,\n      rules\n    })\n\n    baseProps.onChange = field.onChange\n    baseProps.onBlur = field.onBlur\n    baseProps.value = field.value\n  } else {\n    if (!skinElement.skipRegister) {\n      const registerProps = register(name, rules)\n      baseProps.onBlur = registerProps.onBlur\n      baseProps.onChange = registerProps.onChange\n      baseProps.inputRef = registerProps.ref\n    }\n  }\n\n  // Allow field schema or overrides onChange\n  if ('onChange' in fieldSchema || 'onChange' in overrides) {\n    const baseOnChange = baseProps.onChange\n    const overrideOnChange = overrides.onChange\n    if (overrideOnChange)\n      delete overrides.onChange\n\n    const onChangeArguments = {\n      name,\n      setVisible,\n      setHelperText,\n      formHook,\n      setValue,\n      arrayControl\n    }\n\n    const fireOnChange = (value) => {\n      if (fieldSchema.onChange)\n        fieldSchema.onChange(value, onChangeArguments)\n      if (overrideOnChange)\n        overrideOnChange(value, onChangeArguments)\n    }\n\n    baseProps.onChange = (event) => {\n      const value = valueFromEvent(event)\n      baseOnChange(event)\n      fireOnChange(value)\n    }\n\n    baseProps.setValue = (name, value) => {\n      setValue(name, value)\n      fireOnChange(value)\n    }\n  }\n\n  // Allow general onChange, passed to <Autoform />\n  if (props.onChange) {\n    const oldOnChange = baseProps.onChange\n    baseProps.onChange = (event) => {\n      oldOnChange(event)\n      props.onChange()\n    }\n  }\n\n  const propsTransform = getPropsTransform(skinElement)\n  \n  let transformedProps\n  if (typeof propsTransform == 'function')\n    transformedProps = propsTransform ? propsTransform(baseProps) : baseProps\n  else\n    transformedProps = { ...baseProps, ...propsTransform }\n  transformedProps = { ...transformedProps, ...overrides }\n\n  const component = transformedProps.component || skinElement.component\n  if (visible && component) {\n    return (\n      <Autofield\n        {...transformedProps}\n        component={component}\n      />\n    )\n  } else {\n    return null\n  }\n}\n","import React, { useRef, useState, useEffect } from 'react'\nimport { deepmerge } from './utils'\n\nimport {\n  valueOrCreate,\n  objectTraverse\n} from './utils'\nimport { createCoercers } from './coercing'\nimport { PubSub } from './pubsub'\n\nexport const useAutoformState = ({\n  initialValues,\n  onSubmit,\n  onChange,\n  schema,\n  skin,\n  formHook,\n  skipManualReset\n}) => {\n  const stateRef = useRef({\n    stateControl: new PubSub(),\n    fields: {}\n  })\n\n  const { stateControl } = stateRef.current\n\n  const coercersBase = {\n    initialValues,\n    stateRef,\n    skin,\n    onSubmit,\n    schema\n  }\n\n  const coercedSubmit = createCoercers({\n    ...coercersBase,\n    notify: onSubmit\n  })\n\n  let coercedChange\n  if (onChange) {\n    const coercedChangeDoc = onChange && createCoercers({\n      ...coercersBase,\n      notify: onChange\n    })\n\n    coercedChange = () => {\n      const doc = formHook.getValues()\n      return coercedChangeDoc(doc)\n    }\n  } else {\n    coercedChange = null\n  }\n\n  const schemaDef = schema.getSchema()\n  const findOrInitState = (name) => {\n    return valueOrCreate(stateRef.current.fields, name, () => {\n      const nameForVisible = `${name}.initiallyVisible`\n      const initiallyVisible = objectTraverse(schemaDef, nameForVisible, {\n        returnValue: true\n      })\n\n      return {\n        visible: initiallyVisible === null ? true : initiallyVisible,\n        helperText: null\n      }\n    })\n  }\n\n  const setValue = (name, value, options = {}) => {\n    const fieldState = findOrInitState(name)\n\n    const newState = {\n      ...fieldState,\n      value,\n      changed: true\n    }\n\n    if (!options.skipSetInput)\n      formHook.setValue(name, value, options)\n  }\n\n  stateControl.findOrInitState = findOrInitState\n  stateControl.setValue = setValue\n\n  /**\n   * Sets values in the stateRef. Doesn't trigger.\n   */\n  const setValues = (values, { parent = null, field }) => {\n    const fields = Object.keys(values)\n    fields.forEach(field => {\n      const cur = values[field]\n      if (typeof cur == 'object') {\n        return setValues(cur, { parent: field, field })\n      } else {\n        const name = inputName({ parent, field })\n        findOrInitState(fieldName)\n      }\n    })\n  }\n\n  const resetState = (values, omit) => {\n    stateRef.current.fields = {}\n\n    setValues(values || {}, {})\n\n    const currentValues = formHook.getValues()\n\n    if (!skipManualReset) {\n      // Reset by setting everything to initialValues or null.\n      function resetValues(obj, initials = {}, path = '', isArray = false) {\n        const fields = Object.keys(obj)\n        fields.forEach((field, idx) => {\n          const value = obj[field]\n          const elPath = isArray ?\n            `${path}.${idx}` : (path ? `${path}.${field}` : field)\n          const initial = initials[field]\n          if (typeof value == 'object')\n            resetValues(value, initial, elPath, Array.isArray(value))\n          else {\n            const initialOrNull = typeof initial == 'undefined' ? null : initial\n            formHook.setValue(elPath, initialOrNull)\n          }\n        })\n      }\n\n      resetValues(currentValues, initialValues)\n    }\n\n    formHook.reset(values, omit)\n  }\n\n  const changeAndPublish = (name, attr, value) => {\n    const state = findOrInitState(name)\n\n    stateControl.publish(name, {\n      ...state,\n      [attr]: value\n    })\n\n    state[attr] = value\n  }\n\n  const setVisible = (name, visible) => {\n    changeAndPublish(name, 'visible', visible)\n  }\n\n  const setHelperText = (name, text) => {\n    changeAndPublish(name, 'helperText', text)\n  }\n\n  const getValues = () => {\n    let values = {}\n\n    const coercedGetValues = createCoercers({\n      ...coercersBase,\n      notify: (coerced) => {\n        deepmerge(values, coerced)\n      }\n    })\n\n    const doc = formHook.getValues()\n    coercedGetValues(doc)\n\n    return values\n  }\n\n  return {\n    coercedSubmit,\n    coercedChange,\n    setValue,\n    setVisible,\n    setHelperText,\n    resetState,\n    stateControl,\n    getValues\n  }\n}\n\n// Subscribes to visible, helperText and potential future additions\nexport const useAutofieldState = ({ name, stateControl }) => {\n  const initialState = stateControl.findOrInitState(name)\n  const [ state, setState ] = useState({ ...initialState })\n\n  useEffect(() => {\n    stateControl.subscribe(name, setState)\n    return () => {\n      stateControl.unsubscribe(name, setState)\n    }\n  }, [])\n\n  return state\n}\n","import React, { Children } from 'react'\n\nimport {\n  schemaTypeEx,\n  inputName\n} from '../utils'\nimport { tr } from '../translate'\nimport { trError } from '../translation_utils'\nimport { FieldPropsOverride } from './components/FieldPropsOverride'\nimport { AutofieldContainer } from './AutofieldContainer'\n\nconst validations = {\n  required: ({ value, message }) => message,\n  maxLength: 'maxLength',\n  minLength: 'minLength',\n  max: 'max',\n  min: 'min',\n  pattern: 'pattern',\n  validate: 'validate'\n}\n\n/**\n * Creates validation rules after schema\n *\n * @param {object} fieldSchema\n */\nexport function validationRules(fieldSchema) {\n  const validationKeys = Object.keys(validations)\n  return validationKeys.reduce((result, key) => {\n    if (key in fieldSchema) {\n      const validation = fieldSchema[key]\n      let data\n      if (typeof validation == 'object') {\n        if (validation.message && typeof validation.message == 'function')\n          validation.message = validation.message(fieldSchema)\n        data = validation\n      } else if (key == 'validate') {\n        data = value => {\n          const erroring = validation(value)\n          return erroring === false || erroring\n        }\n      } else {\n        data = {\n          value: fieldSchema[key],\n          message: trError(key, fieldSchema)\n        }\n      }\n\n      result[key] = typeof validations[key] == 'function' ?\n        validations[key](data) : data\n    }\n\n    return result\n  }, {})\n}\n\n/**\n * Searches in children to find overrides.\n */\nfunction searchForOverrides(parent, name, children = []) {\n  const childrenArr = Children.map(children, child => child)\n\n  return childrenArr.reduce((override, child) => {\n    const childName = child.props.name\n    const dottedChild = childName && childName.replace(/(\\[|\\]\\.)/g, '.')\n    const isOverride = child.type == FieldPropsOverride\n    if (isOverride && dottedChild == name) {\n      const cloned = Object.assign({}, child.props)\n      delete cloned.name\n\n      return cloned\n    } else {\n      return override\n    }\n  }, {})\n}\n\n/**\n * Renders a single field.\n *\n * @param {object} params\n * @param {string} params.field Name of the field\n * @param {object} params.fieldSchema Schema specification\n *    for the field\n * @param {string} params.parent Prefix of the field name\n * @param {string} params.schemaTypeName Name of the schema\n *    (first argument while instantiating a schema)\n * @param {object} params.config Form configuration\n * @param {...object} params.rest props passed to the component\n */\nexport function renderInput({\n  field,\n  fieldSchema,\n  fieldSchema: {\n    type,\n    required,\n    defaultValue\n  },\n  initialValue,\n  parent,\n  children,\n  propOverrides,\n  schemaTypeName,\n  config = {},\n  index,\n  skin,\n  styles,\n  ...rest\n}) {\n  const strType = schemaTypeEx(type)\n\n  function describePlace() {\n    return `Schema \"${schemaTypeName}\" has field \"${field}\"`\n  }\n\n  if (!strType) {\n    throw `${describePlace()} that lacks type description.`\n  }\n\n  const skinElement = skin[strType]\n\n  if (!skinElement) {\n    throw `${describePlace()} with type \"${strType}\" `\n      + 'that doesn\\'t exist in skin.'\n  }\n\n  const rules = validationRules(fieldSchema)\n  const fullField = inputName({ parent, index, field })\n  const id = `${schemaTypeName}-${fullField}`\n\n  const overrides = searchForOverrides(parent, fullField, propOverrides)\n\n  defaultValue = typeof initialValue == 'undefined' ?\n    defaultValue : initialValue\n\n  return (\n    <AutofieldContainer\n      {...rest}\n      id={id}\n      key={fullField}\n      name={fullField}\n      field={field}\n      fieldSchema={fieldSchema}\n      schemaTypeName={schemaTypeName}\n      config={config}\n      parent={parent}\n      propOverrides={propOverrides}\n      rules={rules}\n      styles={styles}\n      skin={skin}\n      skinElement={skinElement}\n      defaultValue={defaultValue}\n      overrides={overrides}\n    />\n  )\n}\n\n/**\n * Renders the inputs to make the schema work.\n *\n * @param {object} params\n * @param {Schema} params.schema Schema instance\n * @param {object} params.config Rendering configuration\n * @param {string} params.config.arrayMode 'panels' or 'table'\n * @param {...object} params.rest Props passed to every input\n *\n * @returns {array} React elements with the form and inputs.\n */\nexport function renderInputs({\n  schema,\n  config = {},\n  children,\n  propOverrides,\n  initialValues = {},\n  styles = {},\n  ...rest\n}) {\n  const schemaDef = schema.getSchema()\n  const schemaKeys = Object.keys(schemaDef)\n\n  return schemaKeys.map(field =>\n    renderInput({\n      ...rest,\n      field,\n      config,\n      propOverrides: propOverrides || children,\n      fieldSchema: schemaDef[field],\n      schemaTypeName: schema.getType(),\n      initialValue: initialValues[field],\n      styles\n    })\n  )\n}\n","export const REMOVE = 'REMOVE'\nexport const ADD = 'ADD'\n\nexport const remove = (idx) => ({\n  type: REMOVE,\n  idx\n})\n\nexport const add = () => ({\n  type: ADD\n})\n\nexport const initialEmpty = { last: 0, num: 0, keys: [] }\nexport const initial = { last: 1, num: 1, keys: [0] }\n\nexport const initialFromDefault = (defaultValue, initiallyEmpty) => {\n  if (defaultValue && Array.isArray(defaultValue)) {\n    return {\n      last: defaultValue.length,\n      num: defaultValue.length,\n      keys: defaultValue.map((_, idx) => idx)\n    }\n  } else {\n    return initiallyEmpty ? initialEmpty : initial\n  }\n}\n\nexport const reducer = (state = initial, action) => {\n  switch (action.type) {\n  case REMOVE:\n    const { keys } = state\n\n    return {\n      last: state.last,\n      num: state.num - 1,\n      keys: [\n        ...keys.slice(0, action.idx),\n        null,\n        ...keys.slice(action.idx + 1)\n      ]\n    }\n  case ADD:\n    return {\n      last: state.last + 1,\n      num: state.num + 1,\n      keys: [ ...state.keys, state.last ]\n    }\n  default:\n    return state\n  }\n}\n","import React, {\n  forwardRef,\n  useReducer,\n  useRef,\n  useEffect\n} from 'react'\nimport classnames from 'classnames'\n\nimport { renderInputs } from '../componentRender'\nimport { inputArray } from '../ducks'\nimport { tr, trModel } from '../../translation_utils'\nimport { deletedMark } from '../deletedMark'\nimport { inputName, getSkinComponent } from '../../utils'\n\nconst renderAddButton = ({ onAdd, styles, Button, AddGlyph }) => {\n  const boundAdd = e => {\n    e.preventDefault()\n    onAdd()\n  }\n\n  return (\n    <Button\n      onClick={boundAdd}\n      styles={styles}\n      intent=\"add\"\n    >\n      <AddGlyph styles={styles} />\n    </Button>\n  )\n}\n\nconst renderCloseButton = ({\n  onRemove,\n  idx,\n  styles,\n  Button,\n  RemoveGlyph\n}) => {\n  const boundRemove = e => {\n    e.preventDefault()\n    onRemove(idx)\n  }\n\n  return (\n    <Button\n      onClick={boundRemove}\n      styles={styles}\n      intent=\"remove\"\n    >\n      <RemoveGlyph styles={styles} />\n    </Button>\n  )\n}\n\nconst renderPanelHeader = ({\n  onAdd,\n  schemaTypeName,\n  aliveItems,\n  name,\n  styles,\n  Button,\n  AddGlyph,\n  Div,\n  Text\n}) => {\n  const addButton = renderAddButton({ \n    onAdd,\n    styles,\n    Button,\n    AddGlyph,\n  })\n\n  return (\n    <Div className={styles.inputPanelWrap}>\n      <Text className={styles.inputPanelEntity}>\n        {trModel(schemaTypeName, name, '_field') + ' '}\n      </Text>\n      {addButton}\n    </Div>\n  )\n}\n\n/**\n * Used for the arrays in models, for\n * example clients: [Clients]\n *\n */\nexport let InputArrayWrap = ({\n  name,\n  newObject,\n  arrayHandler,\n  register,\n  unregister,\n  errorText = '',\n  fieldSchema,\n  fieldSchema: { type },\n  schemaTypeName,\n  formHook,\n  defaultValue,\n  initiallyEmpty,\n  onRemove,\n  config,\n  styles,\n  isTable,\n  setValue,\n  skin,\n  skinElement,\n  ...rest\n}) => {\n  const [ items, dispatch ] = useReducer(\n    inputArray.reducer,\n    inputArray.initialFromDefault(defaultValue, initiallyEmpty)\n  )\n\n  const schema = type[0]\n  const $arrayHandler = arrayHandler\n\n  const Button = getSkinComponent(skin.arrayButton)\n  const AddGlyph = getSkinComponent(skin.addGlyph)\n  const RemoveGlyph = getSkinComponent(skin.removeGlyph)\n  const Panel = getSkinComponent(skin.panel)\n  const Div = getSkinComponent(skin.div)\n  const Text = getSkinComponent(skin.text)\n\n  const aliveItems = items.keys.filter(idx => idx !== null)\n  const counterField = skinElement.nameForErrors(name)\n\n  const getErrorMessage = (num) => {\n    if ('minChildren' in fieldSchema) {\n      const { minChildren } = fieldSchema\n\n      if (num < minChildren)\n        return tr('error.minChildren', { minChildren })\n    }\n\n    if ('maxChildren' in fieldSchema) {\n      const { maxChildren } = fieldSchema\n      if (num > maxChildren)\n        return tr('error.maxChildren', { maxChildren })\n    }\n  }\n\n  const checkSetErrorMessage = (num) => {\n    const message = getErrorMessage(num)\n    if (message) {\n      formHook.setError(counterField, {\n        type: 'manual',\n        message\n      })\n    } else {\n      formHook.clearErrors(counterField)\n    }\n  }\n\n  const handleAdd = () => {\n    dispatch(inputArray.add())\n    checkSetErrorMessage(items.num + 1)\n  }\n\n  const itemsInputs = aliveItems.map(idx => {\n    const handleRemove = (removeIdx) => {\n      dispatch(inputArray.remove(removeIdx))\n      checkSetErrorMessage(items.num - 1)\n\n      const taint = `${name}.${removeIdx}.${deletedMark}`\n      setValue(taint, true)\n\n      const fieldNames = schema.getFieldNames()\n      fieldNames.forEach(fieldName => {\n        const toUnregister = inputName({\n          parent: name,\n          index: removeIdx,\n          field: fieldName\n        })\n        unregister(toUnregister)\n      })\n    }\n\n    const closeButton = renderCloseButton({\n      onRemove: handleRemove,\n      idx,\n      styles,\n      Button,\n      RemoveGlyph\n    })\n\n    let itemDefault\n    if (defaultValue && Array.isArray(defaultValue))\n      itemDefault = defaultValue[idx]\n    else\n      itemDefault = defaultValue\n\n    return {\n      idx,\n      closeButton,\n      inputs: renderInputs({\n        ...rest,\n        inline: isTable,\n        schema,\n        schemaTypeName,\n        setValue,\n        parent: name,\n        index: idx,\n        initialValues: itemDefault,\n        formHook,\n        styles,\n        register,\n        unregister,\n        arrayIdx: idx,\n        arrayInitialValues: itemDefault,\n        skin,\n        arrayControl: {\n          items,\n          index: idx,\n          remove: handleRemove,\n          add: handleAdd\n        }\n      })\n    }\n  })\n\n  const panelProps = {\n    onAdd: handleAdd,\n    schemaTypeName,\n    dispatch,\n    name,\n    styles,\n    Button,\n    AddGlyph,\n    Div,\n    Text\n  }\n\n  const panelClasses = classnames({\n    [styles.errored]: errorText\n  })\n\n  return (\n    <Panel\n      className={panelClasses}\n      header={renderPanelHeader(panelProps)}\n      styles={styles}\n    >\n      <$arrayHandler\n        schema={schema}\n        config={config}\n        name={name}\n        errorText={errorText}\n        component={arrayHandler}\n        onAdd={handleAdd}\n        newObject={newObject}\n        items={itemsInputs}\n        defaultValue={defaultValue}\n        schemaTypeName={schemaTypeName}\n        styles={styles}\n        skin={skin}\n        {...rest}\n      />\n    </Panel>\n  )\n}\n","import React, { forwardRef } from 'react'\n\nimport { renderInputs } from '../componentRender'\nimport { trModel } from '../../translation_utils'\nimport { getSkinComponent } from '../../utils'\n\nexport let Submodel = ({\n  config = {},\n  name,\n  field,\n  fieldSchema: { type },\n  defaultValue,\n  styles,\n  skin,\n  ...rest\n}, ref) => {\n  const inputsConf = {\n    ...rest,\n    schema: type,\n    config,\n    parent: name,\n    initialValues: defaultValue,\n    styles,\n    skin\n  }\n  const schemaTypeName = type.getType()\n  const Panel = getSkinComponent(skin.panel)\n\n  return (\n    <Panel\n      styles={styles}\n      header={trModel(schemaTypeName, field)}\n    >\n      {renderInputs(inputsConf)}\n    </Panel>\n  )\n}\n\nSubmodel = forwardRef(Submodel)\n","import React from 'react'\nimport { InputArrayWrap } from './components/InputArrayWrap'\nimport { Submodel } from './components/Submodel'\nimport { getSkinComponent } from '../utils'\n\nfunction getOtherSchema(schemaDef, fieldName, { isArray }) {\n  const field = schemaDef[fieldName]\n  const { type } = field\n  const other = isArray ? type[0] : type\n  return other.getSchema()\n}\n\nimport { deletedMark } from './deletedMark'\n\nexport default {\n  array: {\n    skipRegister: true,\n    nameForErrors: name => `${name}__count`,\n    coerce: (arr = [], { coerceObject, schemaDef, fieldName }) => {\n      const otherSchema = getOtherSchema(schemaDef, fieldName, {\n        isArray: true\n      })\n\n      if (Array.isArray(arr)) {\n        return arr.map(entry => {\n          if (entry[deletedMark])\n            return null\n          else\n            return coerceObject({ object: entry, schemaDef: otherSchema })\n        }).filter(entry => entry !== null)\n      } else {\n        return []\n      }\n    },\n    props: props => {\n      const {\n        config = {},\n        fieldSchema,\n        skin,\n        ...rest\n      } = props\n\n      const { arrayMode } = config\n      const finalArrayMode = fieldSchema.arrayMode || arrayMode\n      const isTable = finalArrayMode == 'table'\n      const ArrayTable = getSkinComponent(skin.arrayTable)\n      const ArrayPanel = getSkinComponent(skin.arrayPanel)\n      const arrayHandler = isTable ? ArrayTable : ArrayPanel\n\n      return {\n        ...rest,\n        config,\n        component: InputArrayWrap,\n        initiallyEmpty: fieldSchema.initiallyEmpty,\n        fieldSchema,\n        arrayHandler,\n        inline: true,\n        noRef: true,\n        isTable,\n        skin\n      }\n    },\n  },\n  schema: {\n    skipRegister: true,\n    coerce: (obj = {}, { coerceObject, schemaDef, fieldName }) => {\n      const otherSchema = getOtherSchema(schemaDef, fieldName, { isArray: false })\n\n      return coerceObject({ object: obj, schemaDef: otherSchema })\n    },\n    component: Submodel\n  }\n}\n","import React, { useState, useRef, useImperativeHandle, forwardRef } from 'react'\nimport {\n  objectTraverse,\n  isObject,\n  deepmerge,\n  getSkinComponent\n} from '../utils'\nimport { useForm } from 'react-hook-form'\nimport { getComponents, renderInputs } from './componentRender'\nimport { useAutoformState } from '../autoform_state'\n\nimport baseSkin from './baseSkin'\n\n/**\n * Creates a form using the provided skin. The form\n * has all the needed fields, styles and validation\n * errors in order to work.\n */\nexport let AutoformBase = (props, ref) => {\n  const {\n    schema,\n    elementProps,\n    initialValues = {},\n    children,\n    onSubmit,\n    onErrors,\n    styles,\n    submitButton,\n    submitButtonText,\n    skin,\n    skinOverride,\n    skipManualReset,\n    ...rest\n  } = props\n\n  if (!schema) {\n    throw new Error('<Autoform /> was rendered without schema.')\n  }\n\n  const formHook = useForm({\n    mode: 'all',\n    defaultValues: initialValues\n  })\n  const {\n    control,\n    formState,\n    register,\n    unregister,\n    handleSubmit,\n    reset\n  } = formHook\n\n  const finalSkin = { ...baseSkin, ...skin, ...skinOverride }\n\n  const {\n    coercedSubmit,\n    coercedChange,\n    setValue,\n    setVisible,\n    setHelperText,\n    resetState,\n    stateControl,\n    getValues\n  } = useAutoformState({\n    initialValues,\n    onSubmit,\n    onChange: props.onChange,\n    schema,\n    skin: finalSkin,\n    formHook,\n    skipManualReset\n  })\n\n  const submit = handleSubmit(coercedSubmit, onErrors)\n\n  useImperativeHandle(ref, () => ({\n    submit,\n    formHook: () => formHook,\n    setValue,\n    setVisible,\n    getValues,\n    reset: resetState\n  }))\n\n  const inputProps = {\n    ...rest,\n    ...elementProps,\n    reset,\n    children,\n    initialValues,\n    schema,\n    register,\n    unregister,\n    styles,\n    skin: finalSkin,\n    formHook,\n    autoformProps: props,\n    stateControl,\n    setValue,\n    setVisible,\n    setHelperText,\n    onChange: coercedChange\n  }\n\n  const Button = getSkinComponent(finalSkin.button)\n  const Form = getSkinComponent(finalSkin.form)\n\n  return (\n    <Form onSubmit={submit}>\n      {renderInputs(inputProps)}\n      {\n        submitButton &&\n          <Button\n            styles={styles}\n            onClick={submit}\n            type=\"submit\"\n          >\n            {submitButtonText}\n          </Button>\n      }\n      {children}\n    </Form>\n  )\n}\n\nAutoformBase = forwardRef(AutoformBase)\n"],"names":["root","factory","exports","module","require","define","amd","a","i","self","__WEBPACK_EXTERNAL_MODULE__156__","__WEBPACK_EXTERNAL_MODULE__369__","hasOwn","hasOwnProperty","classNames","classes","arguments","length","arg","argType","push","Array","isArray","inner","apply","toString","Object","prototype","key","call","join","default","getOwnPropertySymbols","propIsEnumerable","propertyIsEnumerable","toObject","val","TypeError","assign","test1","String","getOwnPropertyNames","test2","fromCharCode","map","n","test3","split","forEach","letter","keys","err","shouldUseNative","target","source","from","symbols","to","s","f","g","Symbol","for","h","m","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","ReactCurrentOwner","p","ref","__self","__source","q","c","k","b","d","e","l","defaultProps","$$typeof","type","props","_owner","current","jsx","jsxs","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","getter","__esModule","definition","o","defineProperty","enumerable","get","obj","prop","r","toStringTag","value","defLangs","en","add","remove","error","_","min","max","minLength","maxLength","required","minChildren","maxChildren","es","modelBasePath","setLanguageByName","name","addTranslations","addLanguageTranslations","lang","strings","deepmerge","trModel","modelName","field","op","tr","trPath","trField","schemaTypeName","trError","data","model","trPathSetBase","newBasePath","schemaTypeEx","_type","first","schemaType","isObject","item","Date","sources","shift","sourceIsArray","processOptions","fieldSchema","options","addDefault","rest","extracted","getLabel","option","processed","label","objectTraverse","object","pathOrArray","createIfMissing","returnValue","arrayed","replace","next","inputName","parent","index","valueOrCreate","attr","create","getSkinComponent","skinElement","component","render","translations","varRegex","refRegex","findString","id","part","lastIndex","reduce","nodeInfo","cur","node","found","isLast","regexReplace","regex","str","callback","match","result","re","RegExp","exec","vars","stringExists","setTranslator","translate","setTranslateVariableRegex","newVarRegex","setTranslateReferenceRegex","newRefRegex","createSchema","typeName","schema","getSchema","getFieldSchema","getType","getFieldNames","FieldPropsOverride","Autofield","wrapper","skin","defaultWrap","formHook","control","defaultValue","helperText","inputRef","forceErrors","inline","styles","noRef","noAutocomplete","onChange","onBlur","nameForErrors","errors","useFormState","fieldErrors","errorText","message","actualKey","$wrapper","$component","isComponent","componentBaseProps","className","classnames","input","standard","errored","addInputProps","componentProps","finalHelperText","helperId","autoComplete","addWrapperProps","createCoercers","initialValues","stateRef","notify","doc","coerceObject","schemaDef","fields","fieldName","typeKey","coerce","values","state","visible","container","docContainer","changed","coerced","coerceWithSchema","PubSub","constructor","this","handlers","subscribe","indexOf","unsubscribe","splice","publish","handler","AutofieldContainer","register","rules","overrides","stateControl","setVisible","setHelperText","setValue","arrayControl","initialState","findOrInitState","setState","useState","useEffect","useAutofieldState","baseProps","controlled","useController","skipRegister","registerProps","baseOnChange","overrideOnChange","onChangeArguments","fireOnChange","event","thing","checked","valueFromEvent","oldOnChange","propsTransform","getPropsTransform","transformedProps","validations","pattern","validate","validationRules","validation","erroring","renderInput","initialValue","children","propOverrides","config","strType","describePlace","fullField","Children","child","override","childName","dottedChild","cloned","searchForOverrides","renderInputs","REMOVE","initialEmpty","last","num","initial","reducer","action","slice","idx","renderPanelHeader","onAdd","aliveItems","Button","AddGlyph","Div","Text","addButton","onClick","preventDefault","intent","renderAddButton","inputPanelWrap","inputPanelEntity","InputArrayWrap","newObject","arrayHandler","unregister","initiallyEmpty","onRemove","isTable","items","dispatch","useReducer","inputArray","$arrayHandler","arrayButton","addGlyph","RemoveGlyph","removeGlyph","Panel","panel","div","text","filter","counterField","checkSetErrorMessage","getErrorMessage","setError","clearErrors","handleAdd","itemsInputs","handleRemove","removeIdx","toUnregister","closeButton","renderCloseButton","itemDefault","inputs","arrayIdx","arrayInitialValues","panelProps","panelClasses","header","Submodel","inputsConf","forwardRef","getOtherSchema","array","arr","otherSchema","entry","arrayMode","ArrayTable","arrayTable","ArrayPanel","arrayPanel","AutoformBase","elementProps","onSubmit","onErrors","submitButton","submitButtonText","skinOverride","skipManualReset","Error","useForm","mode","defaultValues","formState","handleSubmit","reset","finalSkin","baseSkin","coercedSubmit","coercedChange","resetState","getValues","useRef","coercersBase","coercedChangeDoc","initiallyVisible","skipSetInput","setValues","changeAndPublish","omit","currentValues","resetValues","initials","path","elPath","initialOrNull","coercedGetValues","useAutoformState","submit","useImperativeHandle","inputProps","autoformProps","button","Form","form"],"sourceRoot":""}